% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\setcounter{tocdepth}{5}
 	% One-column index
 	\makeatletter
 	\renewenvironment{theindex}{
 	\chapter*{\indexname}
 	\markboth{\MakeUppercase\indexname}{\MakeUppercase\indexname}
 	\setlength{\parskip}{0.1em}
 	\relax
 	\let\item\@idxitem
 	}{}
 	\makeatother
 	

\title{BASTet: Berkeley Analysis and Storage Toolkit}
\date{March 21, 2016}
\release{2.0.0}
\author{Oliver RÃ¼bel and Ben Bowen}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\setcounter{tocdepth}{4}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}

\begin{figure}[htbp]
\centering

\scalebox{0.350000}{\includegraphics{{bastet_logo_full}.pdf}}
\end{figure}


\chapter{Introduction}
\label{introduction:introduction}\label{introduction:documentation-bastet}\label{introduction::doc}
This documenation provides an introduction to the omsi HDF-based data format employed by the OpenMSI project as well as the omsi software stack including: i) the omsi file format API, ii) data analysis API, and iii) other tools and modules included in the omsi software stack


\section{Mass Spectrometry Imaging}
\label{introduction:mass-spectrometry-imaging}
Metabolite and protein analysis is vital to understanding the phenotype of a biological sample. Specifically, metabolite levels dynamically vary in response to energy demands, diet, disease, and environment. Typical analysis of metabolite levels begins with homogenization of a sample and the spatial relationships of the biological material are lost. Mass spectrometry imaging of metabolite and protein levels overcomes this limitation by directly measuring the relative abundance of biomolecules and mapping their position. An ``image'' constitutes a relative abundance map for a given biomolecule and large-numbers of molecules can be imaged simultaneously. While this technique is certainly revolutionary, the in-depth analysis of these datasets often provides a barrier to many researchers. OpenMSI provides a gateway for the management and storage of these datafiles (where each file is the size of a typical hard drive), the visualization of the hyper-dimensional contents of the data, and the statistical analysis of the data.

Mass Spectrometry Imaging (MSI) plays a key role in the study of the metabolism and energetics of cells and cellular communities. Metabolite imaging and metabolomic analysis are used to map the connectivity, dynamics and spatial topography of complex cellular systems. In contrast to optical imaging, using MSI allows us to study large numbers of metabolic compounds in a single image. A mass spectrometry image provides for each pixel information about the entire mass spectrum, which is described by a high-resolution spectrum, currently consisting of up to 200,000 m/z bins. A single high-resolution 2D image slice requires on the order of 50GB and several TB's in 3D. Analysis of extremely large and complex MSI data is challenging from both a computational as well as visualization/analysis point of view. Users often require assistance by experts analysts to explore and analyze their MSI data.


\section{OpenMSI: Science Gateway}
\label{introduction:openmsi-science-gateway}
The goal of OpenMSI is to provide a web-based gateway for management and storage of MSI data, the visualization of the hyper-dimensional contents of the data, and the statistical analysis of the data. Initially the gateway should support basic: i) data browsing capabilities and ii) data analysis and visualization capabilities. The visualization would provide easy-to-use selection capabilities allowing a user to: i) select regions of interest in a two-dimensional visualization of the imaging data and to retrieve and plot the spectra for the selected data portions and ii) to select peaks of interest in a spectrum and display an image showing which portions of the image contain similar features. Even such a simple exploratory tool would be extremely valuable in making the imaging data more accessible to end-users. In the longer term we envision to extend this simple browser step-by-step with more sophisticates analysis and interactions capabilities to support: i) interactive annotation of spectra, ii) execution of computationally intensive analysis tasks on remote parallel compute systems at NERSC, and iii) upload data and analysis results to OpenMSI to facilitate sharing of data/results with the MSI community. Similar to the CXIDB project at NERSC, we plan to us HDF5 to enable efficient and flexible: i) data storage, ii) retrieval of data subsets, iii) storage of meta-data information, and iv) extension of the data to include additional derived data. As part of this project we also plan to investigate the use of HPC to speed-up a select set of compute intensive analysis tasks. Many of the analysis tasks currently performed in serial ---such as peak detection and filtering--- involve large numbers of independent computations (e.g., on a per spectrum basis) and could efficiently utilize parallel compute resources to speed-up the analysis.


\section{OpenMSI: Software Infrastructure}
\label{introduction:openmsi-software-infrastructure}
The OpenMSI software infrastructure described in this document provides the foundations for interacting with and analyzing MSI data. In order to make MSI data accessible, the OpenMSI project has developed a HDF5 data layout scheme designed for MSI data. The data format enables storage of: i) raw MSI data, ii) metadata information about an experiment, sample and instrument, and iii) derived analysis results, in a single HDF5 file. Multiple experiments, each of which may included multiple MSI datasets and derived analysis results, may be stored in the same HDF5 file.

The OpenMSI software stack is based on Python using the h5py library for interacting with HDF5 files. omsi provides a custom API for reading/writing omsi HDF5 files. The file API employs a similar strucutre as the file format itself with each high-level HDF5 group being represented by a corresponding python class (see \code{omsi.dataformat.omsi\_file}). The \code{omsi.analysis} package then provides an API for integrating new anlaysis functions with the HDF5 format and the OpenMSI software stack (as well as a series of analysis functions currently available within omis). Additional helpful tools are availabel via the \code{omsi.tools} and \code{omsi.examples} packages.


\chapter{Converting and Files and Making them Accessible}
\label{convert_files:converting-and-files-and-making-them-accessible}\label{convert_files:converting-files}\label{convert_files::doc}

\section{Converting an MSI file at NERSC}
\label{convert_files:converting-an-msi-file-at-nersc}
To convert a mass spectrometry imaging file, e.g., in img or bruckerflex format, to HDF5 do the following:

\begin{Verbatim}[commandchars=\\\{\}]
ssh edison.nersc.gov
cd /project/projectdirs/openmsi/devel/convert
source setupEnvironment.csh
python convertToOMSI.py \PYGZlt{}infile1\PYGZgt{} \PYGZlt{}output HDF5File\PYGZgt{}
\end{Verbatim}

Note if you use the bash shell then use \code{setupEnvironment.bash} instead.

Note, if you want to use the output file from openmsi.nersc.gov then the output file path should be:

\begin{Verbatim}[commandchars=\\\{\}]
/project/projectdirs/openmsi/omsi\PYGZus{}data\PYGZus{}private/\PYGZlt{}username\PYGZgt{}/\PYGZlt{}filename\PYGZgt{}
\end{Verbatim}

where username is the name of the primary user that owns the file.


\section{Making a converted file accessible to OpenMSI (Private)}
\label{convert_files:making-a-converted-file-accessible-to-openmsi-private}
The conversion script will by default automatically try to register new files with the OpenMSI site and
assign them private to a single user if the output file is placed in the OpenMSI private data location:

\begin{Verbatim}[commandchars=\\\{\}]
python convertToOMSI.py \PYGZlt{}infile1\PYGZgt{} /project/projectdirs/openmsi/omsi\PYGZus{}data\PYGZus{}private/\PYGZlt{}username\PYGZgt{}/\PYGZlt{}filename\PYGZgt{}
\end{Verbatim}

The username in the path will determine the user the file is assigned to. E.g: The filename will also be
the name used in the listing on the site. In order to generate the HDF5 file without adding to the
database, use the \code{-{-}no-add-to-db} command line option, e.g,:


\section{Changing file permissions:}
\label{convert_files:changing-file-permissions}
Using the OpenMSI website the owner of the file can assign permissions to files online:

\href{https://openmsi.nersc.gov/openmsi/resources/filemanager}{https://openmsi.nersc.gov/openmsi/resources/filemanager}?file=\textless{}filename\textgreater{}


\section{\texttt{convertToOMSI}: Usage and Options}
\label{convert_files:converttoomsi-usage-and-options}
NOTE: In order to view a current, complete list of conversions options use:

\begin{Verbatim}[commandchars=\\\{\}]
python convertToOMSI.py \PYGZhy{}\PYGZhy{}help
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
python convertToOMSI.py \PYGZhy{}\PYGZhy{}help
USAGE: Call \PYGZdq{}convertToOMSI [options] imgBaseFile1 imgBaseFile2 ... imgBaseFileN HDF5File\PYGZdq{}

This converter script takes the basename (i.e., path+basefilename) of a single
or multiple MSI files as input and converts them to HDF5. Each MSI file is
stored as a separate experiment in the output HDF5 file. If an input file
defines multiple regions, then those regions can either be stored as separate
datasets of the same experiment and/or merged to a single MSI dataset.
Using the various paramter settings described below, one can define how the
conversion should be performed, how the data should be stored in HDF5, and
indicate which analyses should be executed.

===HELPER OPTIONS===
\PYGZhy{}\PYGZhy{}suggest\PYGZhy{}chunking : Iterate over all given input files and suggest a chunking strategy.
                     No data is converted when this option is given, i.e., no name for the
                     HDF5File should be given, but only input files should be listed.

===ERROR HANDLING OPTIONS===
\PYGZhy{}\PYGZhy{}error\PYGZhy{}handling \PYGZlt{}options\PYGZgt{}: Define how errors should be handled. Options are:
                   i)   terminate\PYGZhy{}and\PYGZhy{}cleanup (default) : Terminate the conversion, delete the
                           the HDF5 file and do not add the file to the database.
                   ii)  terminate\PYGZhy{}only, : Leave the generated HDF5 output file in place but  do not
                            add the file to the database.
                   iii) continue\PYGZhy{}on\PYGZhy{}error: Ignore errors if possible and continue, even if this
                            means that some data may be missing from the output.
\PYGZhy{}\PYGZhy{}email \PYGZlt{}email1 email2 ...\PYGZgt{}: Send notification in case of both error or success to the given email address.
\PYGZhy{}\PYGZhy{}email\PYGZhy{}success \PYGZlt{}email1 email2 ...\PYGZgt{}\PYGZgt{}: Send notification in case of success to the given email address.
\PYGZhy{}\PYGZhy{}email\PYGZhy{}error \PYGZlt{}email1 email2 ...\PYGZgt{}\PYGZgt{}: Send notification in case of error to the given email address.

===INPUT DATA OPTIONS===

Default input data options: \PYGZhy{}\PYGZhy{}format auto \PYGZhy{}\PYGZhy{}regions split+merge
\PYGZhy{}\PYGZhy{}format \PYGZlt{}option\PYGZgt{}: Define which file format is used as input. By default the program tries to
           automatically determine the input format. This option can be used to indicate
           the format explicitly to in case the auto option fails. Available options are:
          \PYGZob{}\PYGZsq{}bruckerflex\PYGZus{}file\PYGZsq{}: \PYGZlt{}class \PYGZsq{}omsi.dataformat.bruckerflex\PYGZus{}file.bruckerflex\PYGZus{}file\PYGZsq{}\PYGZgt{}, \PYGZsq{}img\PYGZus{}file\PYGZsq{}: \PYGZlt{}class \PYGZsq{}omsi.dataformat.img\PYGZus{}file.img\PYGZus{}file\PYGZsq{}\PYGZgt{}\PYGZcb{}
\PYGZhy{}\PYGZhy{}regions \PYGZlt{}option\PYGZgt{}: Some file formats (e.g., brucker) allow multiple regions to be imaged and stored
           in a single file. This option allows one to specify how these regions should be
           treated during file conversion. E.g., one may want to store i) each region as a
           separate dataset in the output file (\PYGZhy{}\PYGZhy{}regions split), ii) all regions combined
           in a single dataset (\PYGZhy{}\PYGZhy{}regions merge), or both (\PYGZhy{}\PYGZhy{}regions split+merge)
           Available options are:
          [\PYGZsq{}split\PYGZsq{}, \PYGZsq{}merge\PYGZsq{}, \PYGZsq{}split+merge\PYGZsq{}]

===FILE WRITE OPTIONS===

\PYGZhy{}\PYGZhy{}\PYGZhy{}FILE WRITE OPTIONS: Chunking\PYGZhy{}\PYGZhy{}\PYGZhy{}

Default HDF5 Chunking options: Enabled by default using \PYGZhy{}\PYGZhy{}auto\PYGZhy{}chunking :
\PYGZhy{}\PYGZhy{}auto\PYGZhy{}chunking : Automatically decide which chunking should be used. This option
                automatically generates two copies of the data, one with a chunking
                optimized for selection of spectra and another one optimized for
                selection of ion image slices. All \PYGZhy{}\PYGZhy{}chunking, \PYGZhy{}\PYGZhy{}no\PYGZhy{}chunking, and
                \PYGZhy{}\PYGZhy{}optimized\PYGZhy{}chunking options are ignored if this paramter is given
\PYGZhy{}\PYGZhy{}chunking \PYGZlt{}x y z\PYGZgt{} : Use chunking when writing the HDF5 file. (DEFAULT, x=4,y=4,z=2048)
\PYGZhy{}\PYGZhy{}no\PYGZhy{}chunking : Disable chunking when writing the HDF5 file. Use in combination with
                \PYGZhy{}\PYGZhy{}no\PYGZhy{}compression since compression depends on chunking and will enable
                it if compression is used.
\PYGZhy{}\PYGZhy{}optimized\PYGZhy{}chunking \PYGZlt{}x y z\PYGZgt{} : Use this option to generate additional copies of the data
                with different chunked data layouts. Generating multiple copies of the
                data with different chunked data layouts can be help accelerate selective
                data read opeations. (DEFAULT OFF). We recommend a spectra\PYGZhy{}aligned chunking
                for the raw data, e.g., \PYGZsq{}\PYGZhy{}\PYGZhy{}chunking 1 1 32768\PYGZsq{} and an image\PYGZhy{}aligned chunked
                secondary copy of the data, e.g., \PYGZsq{}\PYGZhy{}\PYGZhy{}optimzied\PYGZhy{}chunking 20 20 100\PYGZsq{}.

\PYGZhy{}\PYGZhy{}\PYGZhy{}FILE WRITE OPTIONS: Compression\PYGZhy{}\PYGZhy{}\PYGZhy{}
HDF5 Compression: Default ON using (gzip, 4):
\PYGZhy{}\PYGZhy{}compression: Enable compression using (gzip,4). NOTE: Compression requires the use of chunking.
\PYGZhy{}\PYGZhy{}no\PYGZhy{}compression: Disable the use of compression.

===I/O OPTIONS===
\PYGZhy{}\PYGZhy{}io \PYGZlt{}option\PYGZgt{}: Available options are: [\PYGZsq{}chunk\PYGZsq{}, \PYGZsq{}spectrum\PYGZsq{}, \PYGZsq{}all\PYGZsq{}]
             i) all : Read the full data in memory and write it at once
             ii) spectrum : Read one spectrum at a time and write it to the file.
             iii) chunk : Read one chunk at a time and write it to the file.

===DATABSE OPTIONS===

These options control whether the generated output file should be added to a server database
to manage web file access permissions
Default options are: \PYGZhy{}\PYGZhy{}add\PYGZhy{}to\PYGZhy{}db \PYGZhy{}\PYGZhy{}db\PYGZhy{}server http://openmsi.nersc.gov
\PYGZhy{}\PYGZhy{}add\PYGZhy{}to\PYGZhy{}db : Add the output HDF5 file to the database.
\PYGZhy{}\PYGZhy{}no\PYGZhy{}add\PYGZhy{}to\PYGZhy{}db : Disable adding the file to the database.
\PYGZhy{}\PYGZhy{}db\PYGZhy{}server : Specify the online server where the file should be registers. Default is
              http://openmsi.nersc.gov
\PYGZhy{}\PYGZhy{}owner : Name of the user that should be assigned as owner. By default the owner is
          determined automatically based on the file path.

===ANALYSIS OPTIONS===

NMF: Default ON: (nc=20, timeout=600, niter=2000, tolerance=0.0001, raw=False)
\PYGZhy{}\PYGZhy{}nmf : Compute the nmf for all the input data files and store the results in the
        HDF5 file. NOTE: If global peak\PYGZhy{}finding (fpg) is performed, then
        nmf will be performed on the peak\PYGZhy{}cube, otherwise on the raw data
\PYGZhy{}\PYGZhy{}no\PYGZhy{}nmf: Disable the execution of nmf
\PYGZhy{}\PYGZhy{}nmf\PYGZhy{}nc \PYGZlt{}number\PYGZgt{}: Number of components to be computed by the NMF. (default nc=20)
\PYGZhy{}\PYGZhy{}nmf\PYGZhy{}timeout \PYGZlt{}number\PYGZgt{}: Maximum time in seconds to be used for computing the NMF. (default timeout=600)
\PYGZhy{}\PYGZhy{}nmf\PYGZhy{}niter \PYGZlt{}number\PYGZgt{}: Number of iterations (minimum is 2)(default niter=2000)
\PYGZhy{}\PYGZhy{}nmf\PYGZhy{}tolerance \PYGZlt{}number\PYGZgt{}: Tolerance value for a relative stopping condition. (default tolerance=0.0001)
\PYGZhy{}\PYGZhy{}nmf\PYGZhy{}raw \PYGZlt{}number\PYGZgt{}: Force execution of the NMF on the raw data. By default the results from
            the global peak finding (\PYGZhy{}\PYGZhy{}fpg) are used to compute the NMF.

Global Peak Finding: Default ON:
\PYGZhy{}\PYGZhy{}fpg : Compute the global peak finding for all input data files and save results
           in the HDF5 file (DEFAULT)
\PYGZhy{}\PYGZhy{}no\PYGZhy{}fpg: Disable the global peak finding

Local Peak Finding: Default OFF:
\PYGZhy{}\PYGZhy{}fpl : Compute the local peak finding for all input data files and save results
        in the HDF5 file
\PYGZhy{}\PYGZhy{}no\PYGZhy{}fpl: Disable the local peak finding (DEFAULT)

\PYGZhy{}\PYGZhy{}\PYGZhy{}OTHER OPTIONS\PYGZhy{}\PYGZhy{}\PYGZhy{}

Generate Thumbnail image: Default OFF:
\PYGZhy{}\PYGZhy{}thumbnail: Generate thumbnail image for the file based on, in order of availability:
             * The first three components of the NMF
             * The three most intense peaks from the global peak finding (fpg)
             * The three most intense peaks in the raw data that are at least 1 percent
               of the total m/z range apart.
\PYGZhy{}\PYGZhy{}no\PYGZhy{}thumbnail: Do not generate a thumbnail image.

Generate XDMF header file for output file: Default OFF:
\PYGZhy{}\PYGZhy{}xdmf: Write XDMF XML\PYGZhy{}based header\PYGZhy{}file for the output HDF5 file.
\PYGZhy{}\PYGZhy{}no\PYGZhy{}xdmf: Do not generate a XDMF XML\PYGZhy{}based header for the HDF5 file.
\end{Verbatim}


\chapter{Integrating new file formats}
\label{custom_filereader:custom-filereader}\label{custom_filereader:integrating-new-file-formats}\label{custom_filereader::doc}

\section{Developing a file reader}
\label{custom_filereader:developing-a-file-reader}
In order to develop a new file reader we need to implement a corresponding class for the file format that inherits form \code{file\_reader\_base} (for formats that always contain a single region) or \code{file\_reader\_base\_with\_regions} (for formats that support multiple imaging regions in a single file). Both
base classes are availble in the \code{omsi.dataformat.file\_reader\_base} module. The developer then needs
to implement the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{omsi.dataformat.file\PYGZus{}reader\PYGZus{}base} \PYG{k+kn}{import} \PYG{n}{file\PYGZus{}reader\PYGZus{}base}

\PYG{k}{class} \PYG{n+nc}{formatname\PYGZus{}file}\PYG{p}{(}\PYG{n}{file\PYGZus{}reader\PYGZus{}base}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} 1. Implement the init function which must accept basename and requires\PYGZus{}slicing as inputs}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{basename}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{requires\PYGZus{}slicing}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        basename : Name of the file/folder to be opened}
\PYG{l+s+sd}{        requires\PYGZus{}slicing: Boolean indicating whether the user requires array slicing via}
\PYG{l+s+sd}{            the \PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{} function to work or not. This is an optimization, because many MSI}
\PYG{l+s+sd}{            data formats do not easily support arbitrary slicing of data but rather only}
\PYG{l+s+sd}{            iteration over spectra.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{formatname\PYGZus{}file}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n}{basename}\PYG{p}{,} \PYG{n}{requires\PYGZus{}slicing}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} 1.1 Call super \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data\PYGZus{}type} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{uint16}\PYG{l+s+s1}{\PYGZsq{}}   \PYG{c+c1}{\PYGZsh{} 1.2 Define the data type used}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{shape} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}      \PYG{c+c1}{\PYGZsh{} 1.3 Define the shape of the dataset}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mz} \PYG{o}{=} \PYG{l+m+mi}{0}                 \PYG{c+c1}{\PYGZsh{} 1.4 Define the m/z axis}

    \PYG{c+c1}{\PYGZsh{} 2. Implement \PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{}}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{key}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Implement array\PYGZhy{}based slicing for the format so that the data can be read}
        \PYG{c+c1}{\PYGZsh{} via [x,y,z]}

    \PYG{c+c1}{\PYGZsh{} 3. Implement close\PYGZus{}file}
    \PYG{k}{def} \PYG{n+nf}{close\PYGZus{}file}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Function called to close any open files when deleting the object}

    \PYG{c+c1}{\PYGZsh{} 4. Implement is\PYGZus{}valid\PYGZus{}dataset}
    \PYG{n+nd}{@classmethod}
    \PYG{k}{def} \PYG{n+nf}{is\PYGZus{}valid\PYGZus{}dataset}\PYG{p}{(}\PYG{n}{cls}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Given the name of a file or directory, determine whether the given}
        \PYG{c+c1}{\PYGZsh{} data defines a valid dataset for the current format}
\end{Verbatim}

For file formats that support multiple regions the implementation is aside from a few additions he same. The main difference are:
\begin{enumerate}
\item {} 
Inherit from \code{file\_reader\_base\_with\_regions} instead of \code{file\_reader\_base}

\item {} 
Set the \code{self.region\_dicts} and \code{self.select\_region} attributes in the \code{\_\_init\_\_} function

\item {} 
Implement the \code{set\_region\_selection} function

\end{enumerate}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{omsi.dataformat.file\PYGZus{}reader\PYGZus{}base} \PYG{k+kn}{import} \PYG{n}{file\PYGZus{}reader\PYGZus{}base\PYGZus{}with\PYGZus{}regions}

\PYG{k}{class} \PYG{n+nc}{formatname\PYGZus{}file}\PYG{p}{(}\PYG{n}{file\PYGZus{}reader\PYGZus{}base}\PYG{p}{)}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} 1. Implement the init function which must accept basename and requires\PYGZus{}slicing as inputs}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{basename}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{requires\PYGZus{}slicing}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{formatname\PYGZus{}file}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n}{basename}\PYG{p}{,} \PYG{n}{requires\PYGZus{}slicing}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} 1.1 Call super \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data\PYGZus{}type} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{uint16}\PYG{l+s+s1}{\PYGZsq{}}    \PYG{c+c1}{\PYGZsh{} 1.2 Define the data type used}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{shape} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}       \PYG{c+c1}{\PYGZsh{} 1.3 Define the shape of the dataset}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mz} \PYG{o}{=} \PYG{l+m+mi}{0}                  \PYG{c+c1}{\PYGZsh{} 1.4 Define the m/z axis}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{region\PYGZus{}dicts} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}       \PYG{c+c1}{\PYGZsh{} 1.5 Define a list of dicts where each dict describes}
                                     \PYG{c+c1}{\PYGZsh{}     the parameters of a region. In the simplest case}
                                     \PYG{c+c1}{\PYGZsh{}     of rectangular regions, a dict would specify the}
                                     \PYG{c+c1}{\PYGZsh{}     {}`origin{}` and {}`extends{}` of a region.}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{select\PYGZus{}region} \PYG{o}{=} \PYG{n+nb+bp}{None}    \PYG{c+c1}{\PYGZsh{} 1.6 Define the index of the selected region.}
                                     \PYG{c+c1}{\PYGZsh{}     Set to None to treat dataset as a whole (i.e.,}
                                     \PYG{c+c1}{\PYGZsh{}     merge all regions). If set to a region index,}
                                     \PYG{c+c1}{\PYGZsh{}     then the \PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{} function is expected to}
                                     \PYG{c+c1}{\PYGZsh{}     behave as if the file consisted of just the}
                                     \PYG{c+c1}{\PYGZsh{}     selected region and the self.shape parameter}
                                     \PYG{c+c1}{\PYGZsh{}     must be set accordingly}

    \PYG{c+c1}{\PYGZsh{} 2\PYGZhy{}4: Implement the other functions of file\PYGZus{}reader\PYGZus{}base as described above.}
    \PYG{c+c1}{\PYGZsh{}      Note, \PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{} must consider the value of self.select\PYGZus{}region and}
    \PYG{c+c1}{\PYGZsh{}      treat any data requests as if they referred to the selected region}
    \PYG{c+c1}{\PYGZsh{}      only. Depending on the data format this may require transformation}
    \PYG{c+c1}{\PYGZsh{}      of the selection keys to locate the appropriate data}

    \PYG{c+c1}{\PYGZsh{} 5. Implement the set\PYGZus{}region\PYGZus{}selection function to allow a user to select a region}
    \PYG{k}{def} \PYG{n+nf}{set\PYGZus{}region\PYGZus{}selection}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{region\PYGZus{}index}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Define which region should be selected for local data reads.}

\PYG{l+s+sd}{       :param region\PYGZus{}index: The index of the region that should be read. The shape of the}
\PYG{l+s+sd}{                data will be adjusted accordingly. Set to None to select all regions and}
\PYG{l+s+sd}{                treat the data as a single full 3D image.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} 5.1 Select all data}
    \PYG{k}{if} \PYG{n}{region\PYGZus{}index} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{select\PYGZus{}region} \PYG{o}{=} \PYG{n+nb+bp}{None}           \PYG{c+c1}{\PYGZsh{} 5.1.1 Set the region selection to None}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{shape} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{full\PYGZus{}shape}        \PYG{c+c1}{\PYGZsh{} 5.1.2 Define shape of the complete data}
    \PYG{c+c1}{\PYGZsh{} 5.2 Select a particular region}
    \PYG{k}{elif} \PYG{n}{region\PYGZus{}index} \PYG{o}{\PYGZlt{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}number\PYGZus{}of\PYGZus{}regions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{select\PYGZus{}region} \PYG{o}{=} \PYG{n}{region\PYGZus{}index}   \PYG{c+c1}{\PYGZsh{} 5.2.1 Set region index}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{shape} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}                    \PYG{c+c1}{\PYGZsh{} 5.2.2 Define the 3D shape of the region}
\end{Verbatim}


\section{Integrating the file reader with OpenMSI}
\label{custom_filereader:integrating-the-file-reader-with-openmsi}
Integrating a new file reader with OpenMSI is simple:
\begin{enumerate}
\item {} 
Add the file reader module to the \code{omsi.dataformat} format module and

\item {} 
Add the name of your module to the \code{\_\_all\_\_} variable in \code{omis.dataformat.\_\_init\_\_.py}

\end{enumerate}

Once these steps are complete, the \code{omsi.dataformat.file\_reader\_base} module will automatically detect the new format and make it available as part of the file conversion script \code{omsi.tools.convertToOMSI}. To check which formats are registered, simply do:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{omsi.dataformat} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{formats} \PYG{o}{=} \PYG{n}{file\PYGZus{}reader\PYGZus{}base}\PYG{o}{.}\PYG{n}{file\PYGZus{}reader\PYGZus{}base}\PYG{o}{.}\PYG{n}{available\PYGZus{}formats}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{formats}
\PYG{g+go}{\PYGZob{}\PYGZsq{}bruckerflex\PYGZus{}file\PYGZsq{}: \PYGZlt{}class \PYGZsq{}omsi.dataformat.bruckerflex\PYGZus{}file.bruckerflex\PYGZus{}file\PYGZsq{}\PYGZgt{},}
\PYG{g+go}{ \PYGZsq{}img\PYGZus{}file\PYGZsq{}: \PYGZlt{}class \PYGZsq{}omsi.dataformat.img\PYGZus{}file.img\PYGZus{}file\PYGZsq{}\PYGZgt{}\PYGZcb{}}
\end{Verbatim}

Using this basic feature makes it possible to easily iterate over all available formats and the consistent interface described by the \code{file\_format\_base} module allows us to use all the formats in a consistent manner (avoiding special cases). E.g., if we want to read a file of an unknown format we can simply:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{omsi.dataformat} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{formats} \PYG{o}{=} \PYG{n}{file\PYGZus{}reader\PYGZus{}base}\PYG{o}{.}\PYG{n}{file\PYGZus{}reader\PYGZus{}base}\PYG{o}{.}\PYG{n}{available\PYGZus{}formats}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{filename} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{my\PYGZus{}unknown\PYGZus{}file}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{filereader} \PYG{o}{=} \PYG{n+nb+bp}{None}
\PYG{n}{formatname} \PYG{o}{=} \PYG{n+nb+bp}{None}
\PYG{k}{for} \PYG{n}{fname}\PYG{p}{,} \PYG{n}{fclass} \PYG{o+ow}{in} \PYG{n}{formats}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{fclass}\PYG{o}{.}\PYG{n}{is\PYGZus{}valid\PYGZus{}dataset}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{filereader} \PYG{o}{=} \PYG{n}{fclass}
        \PYG{n}{formatname} \PYG{o}{=} \PYG{n}{fname}
\PYG{k}{if} \PYG{n}{filereader} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n+nb+bp}{None}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Using }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{formatname}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ to read the file}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{openfile} \PYG{o}{=} \PYG{n}{filereader}\PYG{p}{(}\PYG{n}{basename}\PYG{o}{=}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{requires\PYGZus{}slicing}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}


\chapter{Developing a new Analysis for BASTet}
\label{custom_analysis::doc}\label{custom_analysis:developing-a-new-analysis-for-bastet}

\section{Overview:}
\label{custom_analysis:overview}
The OpenMSI Toolkit includes a basic template for implementing new analyses as part of OpenMSI. The template is located in \code{omsi.templates.omsi\_analysis\_template.py}. The template provides step-by-step instructions on how to implement a new analysis. Simply search top-to-bottom for EDIT\_ME markers to find locations that need to be edited and what changes need to be made.

The implementation of a new analysis is divided into three main steps. We here provide a brief overview of these steps. A detailed walk-through the required implementation is provided in the following sections.

\textbf{Step 1) Basic integration of your analysis with OpenMSI (Required)}
\begin{quote}

The basic integration is simple and should requires only minimal additional effort. The basic integration with the OpenMSI provides:
\begin{itemize}
\item {} 
full integration of the analysis with the OpenMSI file format and API

\item {} 
full support for OpenMSI's data provenance capabilities

\item {} 
full integration with analysis drivers (e.g, the command line driver) enabling direct execution of the analysis with automatic handling of user input specification, help, etc.

\item {} 
basic integration of the analysis with the website, in that a user will be able to browse the analysis in the online file browser. The basic integration automatically provides full support for the \code{qmetadata} and \code{qcube} URL data access patterns. The basic integration provides limited support for the \code{qslice}, \code{qspectrum}, and \code{qmz} patterns, in that it automatically exposes all dependencies of the analysis that support these patterns but it does not expose the data of the analysis itself. This is part of step 2.

\end{itemize}
\end{quote}

\textbf{Step 2)  Integrating your analysis with the OpenMSI web-based viewer (Recommended)}

Once the basic integration is complete, you may want integrate your analysis fully with the OpenMSI online viewer, in order to make your analysis easily accesible to the OpenMSI user community. This step requires the implementation of the \code{qslice}, \code{qspectrum}, and \code{qmz} URL patterns for the analysis. This step completes the integration with the OpenMSI framework itself.

\textbf{Step 3) Making your analysis self-sufficient (Recommended)}

This step makes your analysis ``self-sufficient'' in that it allows you to execute your analysis from the command-line.


\subsection{Some important features of \texttt{analysis\_base}}
\label{custom_analysis:some-important-features-of-analysis-base}
\code{omsi.analysis.analysis\_base} is the base class for all omsi analysis functionality. The class provides a large set of functionality designed to facilitate i) storage of analysis data in the omsi HDF5 file format and ii) integration of new analysis capabilities with the OpenMSI web API and the OpenMSI web-based viewer (see Viewer functions below for details), iii) support for data provenance, and iv) in combination with the \emph{omsi\_analysis\_driver} module enable the direct execution of analysis, e.g, from the command line


\subsubsection{Slicing}
\label{custom_analysis:slicing}
\code{analysis\_base} implements basic slicing to access data stored in the main member variables. By default the data is retrieved from \_\_data\_list by the \_\_getitem\_\_(key) function, which implements the {[}..{]} operator, i.e., the functions returns \_\_data\_list{[}key{]}{[}'data'{]}. The key is a string indicating the name of the paramter to be retrieved. If the key is not found in the \_\_data\_list then the function will try to retrieve the data from \_\_parameter\_list instead. By adding ``parameter/key'' or ``dependency/key'' one may also explicitly retrieve values from the \_\_parameter\_list and \_\_dependency\_list.


\subsubsection{Important Member Variables}
\label{custom_analysis:important-member-variables}\begin{itemize}
\item {} 
\code{analysis\_identifier} defines the name for the analysis used as key in search operations.

\item {} 
\code{\_\_data\_list} defines a list of \code{omsi.analysis.analysis\_data.analysis\_data} objects to be written to the HDF5 file. Derived classes need to add all data that should be saved for the analysis in the omsi HDF5 file to this dictionary. See \code{omsi.analysis.analysis\_data} for details.

\item {} 
\code{parameters}  List of \code{parameter\_data} to be written to the HDF5 file. Derived classes need to add all parameter data that should be saved for the analysis in the omsi HDF5 file to this dictionary using the provided \code{add\_parameter(...)} function. See \code{omsi.analysis.analysis\_data} and \code{add\_parameter(..)} function of \code{analysis\_base} for details.

\item {} 
\code{data\_names} is a list of strings of all names of analysis output datasets. These are the target names for \_\_data\_list. \textbf{NOTE} Names of parameters specified in \code{parameters} and \code{data\_names} should be distinct.

\end{itemize}


\subsubsection{I/O functions}
\label{custom_analysis:i-o-functions}
These functions can be optionally overwritten to control how the analysis data should be written/read from the omsi HDF5 file. Default implementations are provided here, which should be sufficient for most cases.
\begin{itemize}
\item {} 
\code{write\_analysis\_data} By default all data is written by \code{omsi.dataformat.omsi\_file.analysis.omsi\_file\_analysis}. By implementing this function we can implement the write for the main data (i.e., what is stored in self.\_\_data\_list) ourselves. In practice (at least in the serial case) this should not be needed. However, overwriting the function can be useful when implementing an analysis using MPI and we want to avoid gathering the data on rank the root rank (usually rank 0).

\item {} 
\code{add\_custom\_data\_to\_omsi\_file}: The default implementation is empty as the default data write is  managed by the omsi\_file\_experiment.create\_analysis() function.  Overwrite this function, in case that the analysis needs to write data to the HDF5 omsi file beyond what the defualt omsi data API does.

\item {} 
\code{read\_from\_omsi\_file}: The default implementation tries to reconstruct the original data as far  as possible, however, in particular in case that a custom add\_custom\_data\_to\_omsi\_file            funtion has been implemented, the default implementation may not be sufficien. The default implementation reconstructs: i) analysis\_identifier and reads all custom data into ii)\_\_data\_list. Note, an error will be raised in case that the analysis type specified in the HDF5 file does not match the analysis type specified by get\_analysis\_type(). This function can be optionally overwritten to implement a custom data read.

\end{itemize}


\subsubsection{Web API Functions}
\label{custom_analysis:web-api-functions}
Several convenient functions are used to allow the OpenMSI online viewer to interact with the analysis and to visualize it. The default implementations provided here simply indicate that the analysis does not support the data access operations required by the online viewer. Overwrite these functions in the derived analysis classes in order to interface them with the viewer. All viewer-related functions start with \code{v\textbackslash{}\_...} .

NOTE: the default implementation of the viewer functions defined in \code{analysis\_base} are designed to take care of the common requirement for providing viewer access to data from all depencies of an analysis. In many cases, the default implementation is often sill called at the end of custom viewer functions.

NOTE: The viewer functions typically support a viewerOption parameter. viewerOption=0 is expected to refer to the analysis itself.
\begin{itemize}
\item {} 
\code{v\_qslice}: Retrieve/compute data slices as requested via qslice URL requests. The corrsponding view of the DJANGO data access server already translates all input parameters and takes care of generating images/plots if needed. This function is only responsible for retrieving the data.

\item {} 
\code{v\_qspectrum}: Retrieve/compute spectra as requested via qspectrum URL requests. The corrsponding view of the DJANGO data access server already translates all input parameters and takes care of generating images/plots if needed. This function is only responsible for retrieving the data.

\item {} 
\code{v\_qmz}: Define the m/z axes for image slices and spectra as requested by qspectrum URL requests.

\item {} 
\code{v\_qspectrum\_viewer\_options}: Define a list of strings, describing the different viewer options available for the analysis for qspectrum requests (i.e., \code{v\_qspectrum}). This feature allows the analysis developer to define multiple different visualization modes for the analysis. For example, when performing a data rediction (e.g., PCA or NMF) one may want to show the raw spectra or the loadings vector of the projection in the spectrum view (v\_qspectrum). By providing different viewer options we allow the user to decide which option they are most interested in.

\item {} 
\code{v\_qslice\_viewer\_options}: Define a list of strings, describing the different viewer options available for the analysis for qslice requests (i.e., \code{v\_qslice}). This feature allows the analysis developer to define multiple different visualization modes for the analysis. For example, when performing a data rediction (e.g., PCA or NMF) one may want to show the raw spectra or the loadings vector of the projection in the spectrum view (v\_qspectrum). By providing different viewer options we allow the user to decide which option they are most interested in.

\end{itemize}


\subsubsection{Executing, saving, and restoring an analysis object}
\label{custom_analysis:executing-saving-and-restoring-an-analysis-object}
Using the command-line driver we can directly execute analysis as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{omsi}\PYG{o}{/}\PYG{n}{analysis}\PYG{o}{/}\PYG{n}{omsi\PYGZus{}analysis\PYGZus{}driver} \PYG{o}{\PYGZlt{}}\PYG{n}{analysis\PYGZus{}module\PYGZus{}class}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZlt{}}\PYG{n}{analysis\PYGZus{}parameters}\PYG{o}{\PYGZgt{}}
\end{Verbatim}

E.g. to execute a non-negative matrix factorization (NMF) using the \emph{omsi.analysis.multivariate\_stats.omsi\_nmf} module we can simply:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{omsi}\PYG{o}{/}\PYG{n}{analysis}\PYG{o}{/}\PYG{n}{omsi\PYGZus{}analysis\PYGZus{}driver}\PYG{o}{.}\PYG{n}{py} \PYG{n}{multivariate\PYGZus{}stats}\PYG{o}{/}\PYG{n}{omsi\PYGZus{}nmf}\PYG{o}{.}\PYG{n}{py}
    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{msidata} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test\PYGZus{}brain\PYGZus{}convert.h5:/entry\PYGZus{}0/data\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{save} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test\PYGZus{}ana\PYGZus{}save.h5}\PYG{l+s+s2}{\PYGZdq{}}
\end{Verbatim}

Any analysis based on the infrastructure provided by \code{analysis\_base} is fully integrated with OpenMSI file API provided by{}`{}`omsi.dataformat.omsi\_file{}`{}`. This means the analysis can be directly saved to an OMSI HDF5 file and  the saved analysis can be restored from file. In OMSI files, analyses are generally associated with experiments, so that we use the \code{omsi.dataformat.omsi\_file.omsi\_file\_experiment} API here.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{} Open the MSI file and get the desired experiment}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.dataformat.omsi\PYGZus{}file} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{omsi\PYGZus{}file}\PYG{p}{(} \PYG{n}{filename}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{)}
\PYG{n}{e} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{get\PYGZus{}experiment}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Execute the analysis}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{e}\PYG{o}{.}\PYG{n}{get\PYGZus{}msidata}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{omsi\PYGZus{}myanalysis}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{a}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{n}{msidata}\PYG{o}{=}\PYG{n}{d}\PYG{p}{,} \PYG{n}{integration\PYGZus{}width}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{msidata\PYGZus{}dependency}\PYG{o}{=}\PYG{n}{d}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Save the analysis object.}
\PYG{n}{analysis\PYGZus{}object} \PYG{p}{,} \PYG{n}{analysis\PYGZus{}index} \PYG{o}{=} \PYG{n}{exp}\PYG{o}{.}\PYG{n}{create\PYGZus{}analysis}\PYG{p}{(} \PYG{n}{a} \PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} This single line is sufficient to store the complete analysis to the omsi file.}
\PYG{c+c1}{\PYGZsh{} By default the call will block until the write is complete. Setting the}
\PYG{c+c1}{\PYGZsh{} parameter flushIO=False enables buffered write, so that the call will}
\PYG{c+c1}{\PYGZsh{} return once all data write operations have been scheduled. Here we get}
\PYG{c+c1}{\PYGZsh{} an omsi.dataformat.omsi\PYGZus{}file.omsi\PYGZus{}file\PYGZus{}analysis}
\PYG{c+c1}{\PYGZsh{} object for management of the data stored in HDF5 and the integer index of the analysis.}

\PYG{c+c1}{\PYGZsh{} To restore an analysis from file, i.e., read all the analysis data from file}
\PYG{c+c1}{\PYGZsh{} and store it in a corresponding analysis object we can do the following.}
\PYG{c+c1}{\PYGZsh{} Similar to the read\PYGZus{}from\PYGZus{}omsi\PYGZus{}file(...) function of analysis\PYGZus{}base}
\PYG{c+c1}{\PYGZsh{} mentioned below, we can decide via parameter settings of the function,}
\PYG{c+c1}{\PYGZsh{} which portions of the analysis should be loaded into memory}
\PYG{n}{a2} \PYG{o}{=} \PYG{n}{analysis\PYGZus{}object}\PYG{o}{.}\PYG{n}{restore\PYGZus{}analysis}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} If we want to now re\PYGZhy{}execute the same analysis we can simply call}
\PYG{n}{a2}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} If we want to rerun the analysis but change one or more parameter settings,}
\PYG{c+c1}{\PYGZsh{} then we can simply change those parameters when calling the execute function}
\PYG{n}{d2} \PYG{o}{=} \PYG{n}{e}\PYG{o}{.}\PYG{n}{get\PYGZus{}msidata}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Get another MSI dataset}
\PYG{n}{a2}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{n}{msidata}\PYG{o}{=}\PYG{n}{d2}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Execute the analysis on the new MSI dataset}

\PYG{c+c1}{\PYGZsh{} The omsi\PYGZus{}file\PYGZus{}analysis class also provides a convenient function that allows us}
\PYG{c+c1}{\PYGZsh{} to recreate, i.e., restore and run the analysis, in a single function call}
\PYG{n}{a3} \PYG{o}{=} \PYG{n}{analysis\PYGZus{}object}\PYG{o}{.}\PYG{n}{recreate\PYGZus{}analysis}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} The recreate\PYGZus{}analysis(...) function supports additional keyword arguments}
\PYG{c+c1}{\PYGZsh{} which will be passed to the execute(...) call of the analysis, so that we}
\PYG{c+c1}{\PYGZsh{} can change parameter settings for the analysis also when using the}
\PYG{c+c1}{\PYGZsh{} recreate analysis call.}

\PYG{c+c1}{\PYGZsh{} If we know the type of analysis object (which we can also get from file), then we}
\PYG{c+c1}{\PYGZsh{} naturally also restore the analysis from file ourselves via}
\PYG{n}{a4} \PYG{o}{=} \PYG{n}{omsi\PYGZus{}myanalysis}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read\PYGZus{}from\PYGZus{}omsi\PYGZus{}file}\PYG{p}{(}\PYG{n}{analysisGroup}\PYG{o}{=}\PYG{n}{analysis\PYGZus{}object}\PYG{p}{,} \PYGZbs{}
                                           \PYG{n}{load\PYGZus{}data}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYGZbs{}
                                           \PYG{n}{load\PYGZus{}parameters}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYGZbs{}
                                           \PYG{n}{load\PYGZus{}runtime\PYGZus{}data}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYGZbs{}
                                           \PYG{n}{dependencies\PYGZus{}omsi\PYGZus{}format}\PYG{o}{=}\PYG{n+nb+bp}{True} \PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} By setting load\PYGZus{}data and/or load\PYGZus{}parameters to False, we create h5py instead of}
\PYG{c+c1}{\PYGZsh{} numpy objects, avoiding the actual load of the data. CAUTION: To avoid the accidental}
\PYG{c+c1}{\PYGZsh{} overwrite of data we recommend to use load\PYGZus{}data and load\PYGZus{}parameters as False only}
\PYG{c+c1}{\PYGZsh{} when the file has been opened in read\PYGZhy{}only mode \PYGZsq{}r\PYGZsq{}.}

\PYG{c+c1}{\PYGZsh{} Rerunning the same analysis again}
\PYG{n}{a4}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Integrating a new Analysis using the OpenMSI Analysis Template}
\label{custom_analysis:integrating-a-new-analysis-using-the-openmsi-analysis-template}

\subsection{Step 1) Basic integration}
\label{custom_analysis:step-1-basic-integration}
The simple steps outlined below provide you now with full integration of your analysis with the OpenMSI file format and API and full support for OpenMSI's data provenance capabilities. It also provides basic integration of your analysis with the OpenMSI website, in that a user will be able to browse your analysis in the online file browser. The basic integration also automatically provides full support for the \code{qmetadata} and \code{qcube} URL data access patterns, so that you can start to program against your analysis remotely. The basic integration provides limited support for the \code{qslice}, \code{qspectrum}, and \code{qmz} patterns, in that it automatically exposes all dependencies of the analysis that support these patterns but it does not expose the data of your analysis itself. This is part of step 2. Once you have completed the basic integation yout final analysis code should look something like this:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{omsi\PYGZus{}mypeakfinder}\PYG{p}{(}\PYG{n}{analysis\PYGZus{}base}\PYG{p}{)} \PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name\PYGZus{}key}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{undefined}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Initalize the basic data members\PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{omsi\PYGZus{}mypeakfinder}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{)}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{analysis\PYGZus{}identifier} \PYG{o}{=} \PYG{n}{name\PYGZus{}key}
        \PYG{c+c1}{\PYGZsh{} Define the names of the outputs generated by the analysis}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data\PYGZus{}names} \PYG{o}{=} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak\PYGZus{}cube}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak\PYGZus{}mz}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}

        \PYG{c+c1}{\PYGZsh{} Define the input parameters of the analysis}
        \PYG{n}{dtypes} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}default\PYGZus{}dtypes}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{groups} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}default\PYGZus{}parameter\PYGZus{}groups}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}parameter}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{msidata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                           \PYG{n}{help}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The MSI dataset to be analyzed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                           \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{dtypes}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ndarray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                           \PYG{n}{group}\PYG{o}{=}\PYG{n}{groups}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{input}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                           \PYG{n}{required}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}parameter}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mzdata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                           \PYG{n}{help}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The m/z values for the spectra of the MSI dataset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                           \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{dtypes}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ndarray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                           \PYG{n}{group}\PYG{o}{=}\PYG{n}{groups}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{input}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                           \PYG{n}{required}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}parameter}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{integration\PYGZus{}width}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                           \PYG{n}{help}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The window over which peaks should be integrated}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                           \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{float}\PYG{p}{,}
                           \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,}
                           \PYG{n}{group}\PYG{o}{=}\PYG{n}{groups}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{settings}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                           \PYG{n}{required}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}parameter}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peakheight}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                           \PYG{n}{help}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Peak height parameter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                           \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{,}
                           \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,}
                           \PYG{n}{group}\PYG{o}{=}\PYG{n}{groups}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{settings}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                           \PYG{n}{required}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}


    \PYG{k}{def} \PYG{n+nf}{execute\PYGZus{}analysis}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)} \PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}...\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{c+c1}{\PYGZsh{} Copy parameters to local variables. This is purely for convenience and is not mandatory.}
        \PYG{c+c1}{\PYGZsh{} NOTE: Input parameters are automatically record (i.e., we don\PYGZsq{}t need to to anything special.}
        \PYG{n}{msidata} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{msidata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n}{mzdata} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mzdata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n}{integration\PYGZus{}width} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{integration\PYGZus{}width}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n}{peakheight} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peakheight}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

        \PYG{c+c1}{\PYGZsh{} Implementation of my peakfinding algorithm}

        \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

        \PYG{c+c1}{\PYGZsh{} Return the result.}
        \PYG{c+c1}{\PYGZsh{} NOTE: We need to return the output in the order we specified them in self.data\PYGZus{}names}
        \PYG{c+c1}{\PYGZsh{} NOTE: The outputs will be automatically recorded (i.e., we don\PYGZsq{}t need to anything special).}
        \PYG{k}{return} \PYG{n}{peakCube}\PYG{p}{,} \PYG{n}{peakMZ}
        \PYG{n+nb+bp}{self}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak\PYGZus{}cube}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{peakCube}

    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\PYG{c+c1}{\PYGZsh{} Defining a main function is optional. However, allowing a user to directly execute your analysis}
\PYG{c+c1}{\PYGZsh{} from the command line is simple, as we can easily reuse the command\PYGZhy{}line driver module}
\PYG{k}{if} \PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{k+kn}{from} \PYG{n+nn}{omsi.analysis.omsi\PYGZus{}analysis\PYGZus{}driver} \PYG{k+kn}{import} \PYG{n}{cl\PYGZus{}analysis\PYGZus{}driver}
    \PYG{n}{cl\PYGZus{}analysis\PYGZus{}driver}\PYG{p}{(}\PYG{n}{analysis\PYGZus{}class}\PYG{o}{=}\PYG{n}{omsi\PYGZus{}mypeakfinder}\PYG{p}{)}\PYG{o}{.}\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\subsubsection{1.1 Creating a new analysis skeleton}
\label{custom_analysis:creating-a-new-analysis-skeleton}\begin{itemize}
\item {} 
Copy the analysis template to the appropriate location where your analysis should live (NOTE: The analysis template may have been updated since this documentation was written). Any new analysis should be located in a submodule of the \code{omsi.analysis.} module. E.g., if you implement a new peak finding algorithm, it should be placed in omsi/analysis/findpeaks. For example:

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
cp omsi/templates/omsi\PYGZus{}analysis\PYGZus{}template.py openmsi\PYGZhy{}tk/omsi/analysis/findpeaks/omsi\PYGZus{}mypeakfinder.py
\end{Verbatim}
\begin{itemize}
\item {} 
Replace all occurrences of \code{omsi\_analysis\_template} in the file with the name of your analysis class, e.g, omsi\_mypeakfinder. You can do this easily using ``Replace All'' feature of most text editors.  or on most Unix systems  (e.g, Linux or MacOS) on the commandline via:

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
cd openmsi\PYGZhy{}tk/omsi/analysis/findpeaks
sed \PYGZhy{}i.bak \PYGZsq{}s/omsi\PYGZus{}analysis\PYGZus{}template/omsi\PYGZus{}mypeakfinder/\PYGZsq{} omsi\PYGZus{}mypeakfinder.py
rm omsi\PYGZus{}mypeakfinder.py.bak
\end{Verbatim}
\begin{itemize}
\item {} 
Add your analysis to the \code{\_\_init\_\_.py} file of the python module where your analysis lives. In the \code{\_\_init\_\_.py} file you need to add the name of your analysis class to the \code{all\_\_} list and add a an import of your class, e.g,  \code{from omsi\_mypeakfinder import *} . For example:

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{all\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{p}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{omsi\PYGZus{}mypeakfinder}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{omsi\PYGZus{}findpeaks\PYGZus{}global}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
\PYG{k+kn}{from} \PYG{n+nn}{omsi\PYGZus{}findpeaks\PYGZus{}global} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{omsi\PYGZus{}findpeaks\PYGZus{}local} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{Verbatim}
\begin{itemize}
\item {} 
The analysis template contains documentation on how to implement a new analysis. Simply search for \emph{EDIT\_ME} to locate where you should add code and descriptions of what code to add.

\end{itemize}


\subsubsection{1.2 Specifying analysis inputs and outputs}
\label{custom_analysis:specifying-analysis-inputs-and-outputs}
In the \code{\_\_init\_\_} function specify the names of the input parameters of your analysis as well as the names of the output data generated by your analysis. Note, the \code{\_\_init\_\_} function should have a signature that allows us to instantiate the analysis without having to provide any inputs. E.g.,

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{name\PYGZus{}key}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{undefined}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Initalize the basic data members\PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{omsi\PYGZus{}mypeakfinder}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{)}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{analysis\PYGZus{}identifier} \PYG{o}{=} \PYG{n}{name\PYGZus{}key}

    \PYG{c+c1}{\PYGZsh{} Define the names of the outputs}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{data\PYGZus{}names} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak\PYGZus{}cube}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak\PYGZus{}mz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} Define the input parameters}
    \PYG{n}{dtypes} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}default\PYGZus{}dtypes}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} List of default data types. Build\PYGZhy{}in types are}
                                        \PYG{c+c1}{\PYGZsh{} available as well but can be safely used directly as well}
    \PYG{n}{groups} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{get\PYGZus{}default\PYGZus{}parameter\PYGZus{}groups}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} List of default groups to organize parameters. We suggest}
                                                 \PYG{c+c1}{\PYGZsh{} to use the \PYGZsq{}input\PYGZsq{} group for all input data to be analyzed}
                                                 \PYG{c+c1}{\PYGZsh{} as this will make the integration with OpenMSI easier}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}parameter}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{msidata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                       \PYG{n}{help}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The MSI dataset to be analyzed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                       \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{dtypes}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ndarray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                       \PYG{n}{group}\PYG{o}{=}\PYG{n}{groups}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{input}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                       \PYG{n}{required}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}parameter}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mzdata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                       \PYG{n}{help}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The m/z values for the spectra of the MSI dataset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                       \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{dtypes}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ndarray}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                       \PYG{n}{group}\PYG{o}{=}\PYG{n}{groups}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{input}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                       \PYG{n}{required}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}parameter}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{integration\PYGZus{}width}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                       \PYG{n}{help}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The window over which peaks should be integrated}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                       \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{float}\PYG{p}{,}
                       \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,}
                       \PYG{n}{group}\PYG{o}{=}\PYG{n}{groups}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{settings}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                       \PYG{n}{required}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}parameter}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peakheight}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                       \PYG{n}{help}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Peak height parameter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                       \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{,}
                       \PYG{n}{default}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,}
                       \PYG{n}{group}\PYG{o}{=}\PYG{n}{groups}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{settings}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}
                       \PYG{n}{required}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}


\subsubsection{1.3: Implementing the \texttt{execute\_analysis} function}
\label{custom_analysis:implementing-the-execute-analysis-function}
\textbf{1.3.1} Document your execute\_analysis function. OpenMSI typically uses Sphynx notation in the doc-string. The doc-string of the execute\_analysis(..) function and the class are used by the analysis driver modules to provide a description of your analysis as part of the help and will also be included in the help string generated by the \emph{get\_help\_string()} inherited via \emph{analysis\_base} function.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{execute\PYGZus{}analysis}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)} \PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}This analysis computes global peaks in MSI data...}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
\end{Verbatim}

\textbf{1.3.2}  Implement your analysis. For convenience it is often useful to assign the your parameters to local variables, although, this is by no means required. Note, all values are stored as 1D+ numpy arrays, however, are automatically converted for you, so that we can just do:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{integration\PYGZus{}width} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{integration\PYGZus{}width}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

\textbf{1.3.4} Return the outputs of your analysis in the same order as specified in the \emph{self.data\_names} you specified in your \emph{\_\_init\_\_} function (here \emph{{[}'peak\_cube', `peak\_mz'{]}}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{return} \PYG{n}{peakCube}\PYG{p}{,} \PYG{n}{peakMZ}
\end{Verbatim}

Results returned by your analysis will be automatically saved to the respective output variables. This allows users to conveniently access your results and it enables the OpenMSI file API to save your results to file. We here automatically convert single scalars to 1D numpy arrays to ensure consistency. Although, the data write function can handle a large range of python built\_in types by automatically converting them to numpy for storage in HDF5, we generally recommend to convert use numpy directly here to save your data.

With this you have now completed the basic integration of your analysis with the OpenMSI framework.


\subsection{Step 2) Integrating the Analysis with the OpenMSI Web API:}
\label{custom_analysis:step-2-integrating-the-analysis-with-the-openmsi-web-api}
Once the analysis is stored in the OMSI file format, integration with \code{qmetadata} and \code{qcube} calls of the web API is automatic. The \code{qmetadata} and \code{qcube} functions provide general purpose access to the data so that we can immediatly start to program against our analysis.

Some applications---such as the OpenMSI web-based viewer---utilize the simplified, special data access patterns \code{qslice}, \code{qspectrum}, and \code{qmz} in order to interact with the data. The default implementation of these function available in \code{omsi.analysis.analysis\_base} exposes the data from all depencdencies of the analysis that support these patterns. For full integration with the web API, however, we need to implement this functionality in our analysis class. The \code{qmz} pattern in particular is relevant to both the \code{qslice} and \code{qspectrum} pattern and should be always implemented as soon as one of the two patterns is defined.


\subsubsection{2.1 Implementing the \texttt{qslice} pattern}
\label{custom_analysis:implementing-the-qslice-pattern}
\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{omsi\PYGZus{}myanalysis}\PYG{p}{(}\PYG{n}{analysis\PYGZus{}base}\PYG{p}{)} \PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

    \PYG{n+nd}{@classmethod}
    \PYG{k}{def} \PYG{n+nf}{v\PYGZus{}qslice}\PYG{p}{(}\PYG{n}{cls} \PYG{p}{,} \PYG{n}{anaObj} \PYG{p}{,} \PYG{n}{z} \PYG{p}{,} \PYG{n}{viewer\PYGZus{}option}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Implement support for qslice URL requests for the viewer}

\PYG{l+s+sd}{           anaObj: The omsi\PYGZus{}file\PYGZus{}analysis object for which slicing should be performed.}
\PYG{l+s+sd}{           z: Selection string indicting which z values should be selected.}
\PYG{l+s+sd}{           viewer\PYGZus{}option: An analysis can provide different default viewer behaviors}
\PYG{l+s+sd}{                         for how slice operation should be performed on the data.}
\PYG{l+s+sd}{                         This is a simple integer indicating which option is used.}

\PYG{l+s+sd}{           :returns: numpy array with the data to be displayed in the image slice}
\PYG{l+s+sd}{                     viewer. Slicing will be performed typically like [:,:,zmin:zmax].}

\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{k+kn}{from} \PYG{n+nn}{omsi.shared.omsi\PYGZus{}data\PYGZus{}selection} \PYG{k+kn}{import} \PYG{o}{*}
        \PYG{c+c1}{\PYGZsh{}Implement custom analysis viewer options}
        \PYG{k}{if} \PYG{n}{viewer\PYGZus{}option} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{p}{:}
            \PYG{n}{dataset} \PYG{o}{=}  \PYG{n}{anaObj}\PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{labels}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]} \PYG{c+c1}{\PYGZsh{}We assume labels was a 3D image cube of labels}
            \PYG{n}{zselect} \PYG{o}{=} \PYG{n}{selection\PYGZus{}string\PYGZus{}to\PYGZus{}object}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
            \PYG{k}{return} \PYG{n}{dataset}\PYG{p}{[} \PYG{p}{:} \PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{n}{zselect} \PYG{p}{]}

        \PYG{c+c1}{\PYGZsh{}Expose recursively the slice options for any data dependencies. This is useful}
        \PYG{c+c1}{\PYGZsh{}to allow one to trace back data and generate comlex visualizations involving}
        \PYG{c+c1}{\PYGZsh{}multiple different data sources that have some from of dependency in that they}
        \PYG{c+c1}{\PYGZsh{}led to the generation of this anlaysis. This behavior is already provided by}
        \PYG{c+c1}{\PYGZsh{}the default implementation of this function ins analysis\PYGZus{}base.}
        \PYG{k}{elif} \PYG{n}{viewer\PYGZus{}option} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{:}
            \PYG{c+c1}{\PYGZsh{}Note, the base class does not know out out viewer\PYGZus{}options so we need to adjust}
            \PYG{c+c1}{\PYGZsh{}the vieweOption accordingly by substracting the number of our custom options.}
            \PYG{k}{return} \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{omsi\PYGZus{}myanalysis}\PYG{p}{,}\PYG{n}{cls}\PYG{p}{)}\PYG{o}{.}\PYG{n}{v\PYGZus{}qslice}\PYG{p}{(} \PYG{n}{anaObj} \PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{n}{viewer\PYGZus{}option}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{}Invalid viewer\PYGZus{}option}
        \PYG{k}{else} \PYG{p}{:}
            \PYG{k}{return} \PYG{n+nb+bp}{None}

     \PYG{n+nd}{@classmethod}
        \PYG{k}{def} \PYG{n+nf}{v\PYGZus{}qslice\PYGZus{}viewer\PYGZus{}options}\PYG{p}{(}\PYG{n}{cls} \PYG{p}{,} \PYG{n}{anaObj} \PYG{p}{)} \PYG{p}{:}
            \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Define which viewer\PYGZus{}options are supported for qspectrum URL\PYGZsq{}s\PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{c+c1}{\PYGZsh{}Get the options for all data dependencies}
            \PYG{n}{dependent\PYGZus{}options} \PYG{o}{=} \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{omsi\PYGZus{}findpeaks\PYGZus{}global}\PYG{p}{,}\PYG{n}{cls}\PYG{p}{)}\PYG{o}{.}\PYG{n}{v\PYGZus{}qslice\PYGZus{}viewer\PYGZus{}options}\PYG{p}{(}\PYG{n}{anaObj}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{}Define our custom viewer options}
            \PYG{n}{re} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Labels}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{+} \PYG{n}{dependent\PYGZus{}options}
            \PYG{k}{return} \PYG{n}{re}
\end{Verbatim}

NOTE: We here convert the selection string to a python selection (i.e., a list, slice, or integer) object using the \code{omsi.shared.omsi\_data\_selection.check\_selection\_string(...)} . This has the advantage that we can use the given selection directly in our code and avoids the use of a potentially dangerous \code{eval} , e.g., \code{return eval("dataset{[}:,:, \%s{]}" \%(z,))} . While we can also check the validity of the  seletion string  using  \code{omsi.shared.omsi\_data\_selection.check\_selection\_string(...)} , it is recommened to convert the string to a valid python selection to avoid possible attacks.


\subsubsection{2.2 Implementing the \texttt{qspectrum} pattern}
\label{custom_analysis:implementing-the-qspectrum-pattern}
\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{omsi\PYGZus{}myanalysis}\PYG{p}{(}\PYG{n}{analysis\PYGZus{}base}\PYG{p}{)} \PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
    \PYG{n+nd}{@classmethod}
    \PYG{k}{def} \PYG{n+nf}{v\PYGZus{}qspectrum}\PYG{p}{(} \PYG{n}{cls}\PYG{p}{,} \PYG{n}{anaObj} \PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{p}{,} \PYG{n}{viewer\PYGZus{}option}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Implement support for qspectrum URL requests for the viewer.}

\PYG{l+s+sd}{           anaObj: The omsi\PYGZus{}file\PYGZus{}analysis object for which slicing should be performed}
\PYG{l+s+sd}{           x: x selection string}
\PYG{l+s+sd}{           y: y selection string}
\PYG{l+s+sd}{           viewer\PYGZus{}option: If multiple default viewer behaviors are available for a given}
\PYG{l+s+sd}{                         analysis then this option is used to switch between them.}

\PYG{l+s+sd}{           :returns: The following two elemnts are expected to be returned by this function :}

\PYG{l+s+sd}{                1) 1D, 2D or 3D numpy array of the requested spectra. NOTE: The spectrum axis,}
\PYG{l+s+sd}{                e.g., mass (m/z), must be the last axis. For index selection x=1,y=1 a 1D array}
\PYG{l+s+sd}{                is usually expected. For indexList selections x=[0]\PYGZam{}y=[1] usually a 2D array}
\PYG{l+s+sd}{                is expected. For range selections x=0:1\PYGZam{}y=1:2 we one usually expect a 3D array.}
\PYG{l+s+sd}{                This behavior is consistent with numpy and h5py.}

\PYG{l+s+sd}{                2) None in case that the spectra axis returned by v\PYGZus{}qmz are valid for the}
\PYG{l+s+sd}{                returned spectrum. Otherwise, return a 1D numpy array with the m/z values}
\PYG{l+s+sd}{                for the spectrum (i.e., if custom m/z values are needed for interpretation}
\PYG{l+s+sd}{                of the returned spectrum).This may be needed, e.g., in cases where a}
\PYG{l+s+sd}{                per\PYGZhy{}spectrum peak analysis is performed and the peaks for each spectrum}
\PYG{l+s+sd}{                appear at different m/z values.}

\PYG{l+s+sd}{            Developer Note: h5py currently supports only a single index list. If the user provides}
\PYG{l+s+sd}{            an index\PYGZhy{}list for both x and y, then we need to construct the proper merged list and}
\PYG{l+s+sd}{            load the data manually, or, if the data is small enough, one can load the full data}
\PYG{l+s+sd}{            into a numpy array which supports mulitple lists in the selection. This, however, is}
\PYG{l+s+sd}{            only recommended for small datasets.}

\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

        \PYG{n}{data} \PYG{o}{=} \PYG{n+nb+bp}{None}
        \PYG{n}{customMZ} \PYG{o}{=} \PYG{n+nb+bp}{None}
        \PYG{k}{if} \PYG{n}{viewer\PYGZus{}option} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{p}{:}
            \PYG{k+kn}{from} \PYG{n+nn}{omsi.shared.omsi\PYGZus{}data\PYGZus{}selection} \PYG{k+kn}{import} \PYG{o}{*}
            \PYG{n}{dataset} \PYG{o}{=}  \PYG{n}{anaObj}\PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{labels}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{check\PYGZus{}selection\PYGZus{}string}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{==} \PYG{n}{selection\PYGZus{}type}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{indexlist}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)} \PYG{o+ow}{and}  \PYGZbs{}
               \PYG{p}{(}\PYG{n}{check\PYGZus{}selection\PYGZus{}string}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)} \PYG{o}{==} \PYG{n}{selection\PYGZus{}type}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{indexlist}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)} \PYG{p}{:}
                \PYG{c+c1}{\PYGZsh{}Assuming that the data is small enough, we can handle the multiple list}
                \PYG{c+c1}{\PYGZsh{}selection case here just by loading the full data use numpy to do the}
                \PYG{c+c1}{\PYGZsh{}subselection. Note, this version would work for all selection types but}
                \PYG{c+c1}{\PYGZsh{}we would like to avoid loading the full data if we don\PYGZsq{}t have to.}
                \PYG{n}{xselect} \PYG{o}{=} \PYG{n}{selection\PYGZus{}string\PYGZus{}to\PYGZus{}object}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
                \PYG{n}{yselect} \PYG{o}{=} \PYG{n}{selection\PYGZus{}string\PYGZus{}to\PYGZus{}object}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
                \PYG{n}{data} \PYG{o}{=} \PYG{n}{dataset}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{p}{[}\PYG{n}{xselect}\PYG{p}{,}\PYG{n}{yselect}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}
                \PYG{c+c1}{\PYGZsh{}Since we alredy confirmed that both selection strings are index lists we could}
                \PYG{c+c1}{\PYGZsh{}also just do an eval as follows.}
                \PYG{c+c1}{\PYGZsh{}data = eval(\PYGZdq{}dataset[:][\PYGZpc{}s,\PYGZpc{}s, :]\PYGZdq{} \PYGZpc{}(x,y))}
            \PYG{k}{else} \PYG{p}{:}
                \PYG{n}{xselect} \PYG{o}{=} \PYG{n}{selection\PYGZus{}string\PYGZus{}to\PYGZus{}object}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
                \PYG{n}{yselect} \PYG{o}{=} \PYG{n}{selection\PYGZus{}string\PYGZus{}to\PYGZus{}object}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
                \PYG{n}{data} \PYG{o}{=} \PYG{n}{dataset}\PYG{p}{[}\PYG{n}{xselect}\PYG{p}{,}\PYG{n}{yselect}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}
            \PYG{c+c1}{\PYGZsh{}Return the spectra and indicate that no customMZ data values (i.e. None) are needed}
            \PYG{k}{return} \PYG{n}{data}\PYG{p}{,} \PYG{n+nb+bp}{None}
        \PYG{c+c1}{\PYGZsh{}Expose recursively the slice options for any data dependencies. This is useful}
        \PYG{c+c1}{\PYGZsh{}to allow one to trace back data and generate comlex visualizations involving}
        \PYG{c+c1}{\PYGZsh{}multiple different data sources that have some from of dependency in that they}
        \PYG{c+c1}{\PYGZsh{}led to the generation of this anlaysis. This behavior is already provided by}
        \PYG{c+c1}{\PYGZsh{}the default implementation of this function ins analysis\PYGZus{}base.}
        \PYG{k}{elif} \PYG{n}{viewer\PYGZus{}option} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{:}
            \PYG{c+c1}{\PYGZsh{}Note, the base class does not know out out viewer\PYGZus{}options so we need to adjust}
            \PYG{c+c1}{\PYGZsh{}the vieweOption accordingly by substracting the number of our custom options.}
            \PYG{k}{return} \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{omsi\PYGZus{}findpeaks\PYGZus{}global}\PYG{p}{,}\PYG{n}{cls}\PYG{p}{)}\PYG{o}{.}\PYG{n}{v\PYGZus{}qspectrum}\PYG{p}{(} \PYG{n}{anaObj} \PYG{p}{,} \PYG{n}{x} \PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{viewer\PYGZus{}option}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}

        \PYG{k}{return} \PYG{n}{data} \PYG{p}{,} \PYG{n}{customMZ}

    \PYG{n+nd}{@classmethod}
    \PYG{k}{def} \PYG{n+nf}{v\PYGZus{}qspectrum\PYGZus{}viewer\PYGZus{}options}\PYG{p}{(}\PYG{n}{cls} \PYG{p}{,} \PYG{n}{anaObj} \PYG{p}{)} \PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Define which viewer\PYGZus{}options are supported for qspectrum URL\PYGZsq{}s\PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{c+c1}{\PYGZsh{}Get the options for all data dependencies}
        \PYG{n}{dependent\PYGZus{}options} \PYG{o}{=} \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{omsi\PYGZus{}findpeaks\PYGZus{}global}\PYG{p}{,}\PYG{n}{cls}\PYG{p}{)}\PYG{o}{.}\PYG{n}{v\PYGZus{}qspectrum\PYGZus{}viewer\PYGZus{}options}\PYG{p}{(}\PYG{n}{anaObj}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{}Define our custom viewer options}
        \PYG{n}{re} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Labels}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{+} \PYG{n}{dependent\PYGZus{}options}
        \PYG{k}{return} \PYG{n}{re}
\end{Verbatim}


\subsubsection{2.3 Implementing the \texttt{qmz} pattern}
\label{custom_analysis:implementing-the-qmz-pattern}
\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{omsi\PYGZus{}myanalysis}\PYG{p}{(}\PYG{n}{analysis\PYGZus{}base}\PYG{p}{)} \PYG{p}{:}
    \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

    \PYG{n+nd}{@classmethod}
        \PYG{k}{def} \PYG{n+nf}{v\PYGZus{}qmz}\PYG{p}{(}\PYG{n}{cls}\PYG{p}{,} \PYG{n}{anaObj}\PYG{p}{,} \PYG{n}{qslice\PYGZus{}viewer\PYGZus{}option}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{qspectrum\PYGZus{}viewer\PYGZus{}option}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{:}
            \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Implement support for qmz URL requests for the viewer.}

\PYG{l+s+sd}{                Get the mz axes for the analysis}

\PYG{l+s+sd}{                anaObj: The omsi\PYGZus{}file\PYGZus{}analysis object for which slicing should be performed.}
\PYG{l+s+sd}{                qslice\PYGZus{}viewer\PYGZus{}option: If multiple default viewer behaviors are available for}
\PYG{l+s+sd}{                            a given analysis then this option is used to switch between them}
\PYG{l+s+sd}{                            for the qslice URL pattern.}
\PYG{l+s+sd}{                qspectrum\PYGZus{}viewer\PYGZus{}option: If multiple default viewer behaviors are available}
\PYG{l+s+sd}{                            for a given analysis then this option is used to switch between}
\PYG{l+s+sd}{                            them for the qspectrum URL pattern.}

\PYG{l+s+sd}{                :returns: The following four arrays are returned by the analysis:}

\PYG{l+s+sd}{                  \PYGZhy{} mzSpectra : 1D numpy array with the static mz values for the spectra.}
\PYG{l+s+sd}{                  \PYGZhy{} labelSpectra : String with lable for the spectral mz axis}
\PYG{l+s+sd}{                  \PYGZhy{} mzSlice : 1D numpy array of the static mz values for the slices or}
\PYG{l+s+sd}{                              None if identical to the mzSpectra array.}
\PYG{l+s+sd}{                  \PYGZhy{} labelSlice : String with label for the slice mz axis or None if}
\PYG{l+s+sd}{                                 identical to labelSpectra.}
\PYG{l+s+sd}{                  \PYGZhy{} valuesX: The values for the x axis of the image (or None)}
\PYG{l+s+sd}{                  \PYGZhy{} labelX: Label for the x axis of the image}
\PYG{l+s+sd}{                  \PYGZhy{} valuesY: The values for the y axis of the image (or None)}
\PYG{l+s+sd}{                  \PYGZhy{} labelY: Label for the y axis of the image}
\PYG{l+s+sd}{                  \PYGZhy{} valuesZ: The values for the z axis of the image (or None)}
\PYG{l+s+sd}{                  \PYGZhy{} labelZ: Label for the z axis of the image}

\PYG{l+s+sd}{                 Developer Note: Here we need to handle the different possible combinations}
\PYG{l+s+sd}{                 for the differnent viewer\PYGZus{}option patterns. It is in general safe to populate}
\PYG{l+s+sd}{                 mzSlice and lableSlice also if they are identical with the spectrum settings,}
\PYG{l+s+sd}{                 however, this potentially has a significant overhead when the data is transfered}
\PYG{l+s+sd}{                 via a slow network connection, this is why we allow those values to be None}
\PYG{l+s+sd}{                 in case that they are identical.}

\PYG{l+s+sd}{            \PYGZdq{}\PYGZdq{}\PYGZdq{}}
            \PYG{c+c1}{\PYGZsh{}The four values to be returned}
            \PYG{n}{mzSpectra} \PYG{o}{=}  \PYG{n+nb+bp}{None}
            \PYG{n}{labelSpectra} \PYG{o}{=} \PYG{n+nb+bp}{None}
            \PYG{n}{mzSlice} \PYG{o}{=} \PYG{n+nb+bp}{None}
            \PYG{n}{labelSlice} \PYG{o}{=} \PYG{n+nb+bp}{None}
            \PYG{n}{peak\PYGZus{}cube\PYGZus{}shape} \PYG{o}{=} \PYG{n}{anaObj}\PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{labels}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}\PYG{o}{.}\PYG{n}{shape} \PYG{c+c1}{\PYGZsh{}We assume labels was a 3D image cube of labels}
            \PYG{n}{valuesX} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{peak\PYGZus{}cube\PYGZus{}shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
            \PYG{n}{labelX} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pixel index X}\PYG{l+s+s1}{\PYGZsq{}}
            \PYG{n}{valuesY} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{peak\PYGZus{}cube\PYGZus{}shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
            \PYG{n}{labelY} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pixel index Y}\PYG{l+s+s1}{\PYGZsq{}}
            \PYG{n}{valuesZ} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{peak\PYGZus{}cube\PYGZus{}shape}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)} \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{peak\PYGZus{}cube\PYGZus{}shape}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{3} \PYG{k}{else} \PYG{n+nb+bp}{None}
            \PYG{n}{labelZ} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pixel index Z}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{peak\PYGZus{}cube\PYGZus{}shape}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{3} \PYG{k}{else} \PYG{n+nb+bp}{None}

            \PYG{c+c1}{\PYGZsh{}Both qslice and qspectrum here point to our custom analysis}
            \PYG{k}{if} \PYG{n}{qspectrum\PYGZus{}viewer\PYGZus{}option} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{qslice\PYGZus{}viewer\PYGZus{}option}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}Loadings}
                \PYG{n}{mzSpectra} \PYG{o}{=}  \PYG{n}{anaObj}\PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{labels}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
                \PYG{n}{labelSpectra} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Labels}\PYG{l+s+s2}{\PYGZdq{}}
            \PYG{c+c1}{\PYGZsh{}Both viewer\PYGZus{}options point to a data dependency}
            \PYG{k}{elif} \PYG{n}{qspectrum\PYGZus{}viewer\PYGZus{}option} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{qslice\PYGZus{}viewer\PYGZus{}option}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0} \PYG{p}{:}
                \PYG{n}{mzSpectra}\PYG{p}{,} \PYG{n}{labelSpectra}\PYG{p}{,} \PYG{n}{mzSlice}\PYG{p}{,} \PYG{n}{labelSlice} \PYG{o}{=} \PYGZbs{}
                       \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{omsi\PYGZus{}findpeaks\PYGZus{}global}\PYG{p}{,}\PYG{n}{cls}\PYG{p}{)}\PYG{o}{.}\PYG{n}{v\PYGZus{}qmz}\PYG{p}{(} \PYG{n}{anaObj}\PYG{p}{,} \PYGZbs{}
                             \PYG{n}{qslice\PYGZus{}viewer\PYGZus{}option}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{p}{,} \PYG{n}{qspectrum\PYGZus{}viewer\PYGZus{}option}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{}Only the a qlice options point to a data dependency}
            \PYG{k}{elif} \PYG{n}{qspectrum\PYGZus{}viewer\PYGZus{}option} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{qslice\PYGZus{}viewer\PYGZus{}option}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0} \PYG{p}{:}
                \PYG{n}{mzSpectra} \PYG{o}{=}  \PYG{n}{anaObj}\PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak\PYGZus{}mz}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
                \PYG{n}{labelSpectra} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{m/z}\PYG{l+s+s2}{\PYGZdq{}}
                \PYG{n}{tempA}\PYG{p}{,} \PYG{n}{tempB}\PYG{p}{,} \PYG{n}{mzSlice}\PYG{p}{,} \PYG{n}{labelSlice}\PYG{p}{,} \PYG{n}{valuesX}\PYG{p}{,} \PYG{n}{labelX}\PYG{p}{,} \PYG{n}{valuesY}\PYG{p}{,} \PYG{n}{labelY}\PYG{p}{,} \PYG{n}{valuesZ}\PYG{p}{,} \PYG{n}{labelZ} \PYG{o}{=} \PYGZbs{}
                        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{omsi\PYGZus{}findpeaks\PYGZus{}global}\PYG{p}{,}\PYG{n}{cls}\PYG{p}{)}\PYG{o}{.}\PYG{n}{v\PYGZus{}qmz}\PYG{p}{(} \PYG{n}{anaObj}\PYG{p}{,} \PYGZbs{}
                              \PYG{n}{qslice\PYGZus{}viewer\PYGZus{}option}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{}Only the qspectrum option points to a data dependency}
            \PYG{k}{elif} \PYG{n}{qspectrum\PYGZus{}viewer\PYGZus{}option} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{qslice\PYGZus{}viewer\PYGZus{}option}\PYG{o}{==}\PYG{l+m+mi}{0} \PYG{p}{:}
                \PYG{n}{mzSlice} \PYG{o}{=}  \PYG{n}{anaObj}\PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak\PYGZus{}mz}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
                \PYG{n}{labelSlice} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{m/z}\PYG{l+s+s2}{\PYGZdq{}}
                \PYG{c+c1}{\PYGZsh{} Ignore the spatial axes and slize axis as we use our own}
                \PYG{n}{mzSpectra}\PYG{p}{,} \PYG{n}{labelSpectra}\PYG{p}{,} \PYG{n}{tempA}\PYG{p}{,} \PYG{n}{tempB}\PYG{p}{,} \PYG{n}{vX}\PYG{p}{,} \PYG{n}{lX}\PYG{p}{,} \PYG{n}{vY}\PYG{p}{,} \PYG{n}{lY}\PYG{p}{,} \PYG{n}{vZ}\PYG{p}{,} \PYG{n}{lZ} \PYG{o}{=} \PYGZbs{}
                        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{omsi\PYGZus{}findpeaks\PYGZus{}global}\PYG{p}{,}\PYG{n}{cls}\PYG{p}{)}\PYG{o}{.}\PYG{n}{v\PYGZus{}qmz}\PYG{p}{(} \PYG{n}{anaObj}\PYG{p}{,} \PYGZbs{}
                              \PYG{l+m+mi}{0} \PYG{p}{,} \PYG{n}{qspectrum\PYGZus{}viewer\PYGZus{}option}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}

            \PYG{k}{return} \PYG{n}{mzSpectra}\PYG{p}{,} \PYG{n}{labelSpectra}\PYG{p}{,} \PYG{n}{mzSlice}\PYG{p}{,} \PYG{n}{labelSlice}\PYG{p}{,} \PYG{n}{valuesX}\PYG{p}{,} \PYG{n}{labelX}\PYG{p}{,} \PYG{n}{valuesY}\PYG{p}{,} \PYG{n}{labelY}\PYG{p}{,} \PYG{n}{valuesZ}\PYG{p}{,} \PYG{n}{labelZ}
\end{Verbatim}


\subsection{Step 3) Making your analysis self-sufficient}
\label{custom_analysis:step-3-making-your-analysis-self-sufficient}
Making your analysis self sufficient is trivial. If you used the analysis template provided by the toolkit, then you have already completed this step for free. In order to allow a user to run our analysis from the command line we need a main function. We here can simply reuse the command line driver provided by the toolkit. Using the command line driver we can run the analysis via:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{omsi}\PYG{o}{/}\PYG{n}{analysis}\PYG{o}{/}\PYG{n}{omsi\PYGZus{}analysis\PYGZus{}driver}\PYG{o}{.}\PYG{n}{py} \PYG{n}{findpeaks}\PYG{o}{.}\PYG{n}{omsi\PYGZus{}mypeakfinder}
    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{msidata} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test\PYGZus{}brain\PYGZus{}convert.h5:/entry\PYGZus{}0/data\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{mzdata} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test\PYGZus{}brain\PYGZus{}convert.h5:/entry\PYGZus{}0/data\PYGZus{}0/mz}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{save} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test\PYGZus{}ana\PYGZus{}save.h5}\PYG{l+s+s2}{\PYGZdq{}}
\end{Verbatim}

To now enable us to execute our analysis module itself we simply need to add the following code (which is already part of the template)

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{if} \PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{k+kn}{from} \PYG{n+nn}{omsi.analysis.omsi\PYGZus{}analysis\PYGZus{}driver} \PYG{k+kn}{import} \PYG{n}{cl\PYGZus{}analysis\PYGZus{}driver}
    \PYG{n}{cl\PYGZus{}analysis\PYGZus{}driver}\PYG{p}{(}\PYG{n}{analysis\PYGZus{}class}\PYG{o}{=}\PYG{n}{omsi\PYGZus{}mypeakfinder}\PYG{p}{)}\PYG{o}{.}\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

With this we can now directly execute our analysis from the command line, get a command-line help, specify all our input parameters on the command line, and save our analysis to file. To run the analysis we can now do:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{omsi}\PYG{o}{/}\PYG{n}{analysis}\PYG{o}{/}\PYG{n}{findpeaks}\PYG{o}{/}\PYG{n}{omsi\PYGZus{}findpeaks\PYGZus{}global}\PYG{o}{.}\PYG{n}{py}
    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{msidata} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test\PYGZus{}brain\PYGZus{}convert.h5:/entry\PYGZus{}0/data\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{mzdata} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test\PYGZus{}brain\PYGZus{}convert.h5:/entry\PYGZus{}0/data\PYGZus{}0/mz}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{save} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test\PYGZus{}ana\PYGZus{}save.h5}\PYG{l+s+s2}{\PYGZdq{}}
\end{Verbatim}

This will run our peak finder on the given input data and save the result to the first experiment in the test\_ana\_save.h5 (the output file will be automatically created if it does not exist).

The command line driver also provides us a well-formated help based on the our parameter specification and the doc-string of the analysis class and its execute\_analysis(...) function. E.g:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{python} \PYG{n}{omsi}\PYG{o}{/}\PYG{n}{analysis}\PYG{o}{/}\PYG{n}{findpeaks}\PYG{o}{/}\PYG{n}{omsi\PYGZus{}findpeaks\PYGZus{}global}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{help}

\PYG{g+go}{usage: omsi\PYGZus{}findpeaks\PYGZus{}global.py [\PYGZhy{}h] [\PYGZhy{}\PYGZhy{}save SAVE] \PYGZhy{}\PYGZhy{}msidata MSIDATA \PYGZhy{}\PYGZhy{}mzdata}
\PYG{g+go}{                                MZDATA [\PYGZhy{}\PYGZhy{}integration\PYGZus{}width INTEGRATION\PYGZus{}WIDTH]}
\PYG{g+go}{                                [\PYGZhy{}\PYGZhy{}peakheight PEAKHEIGHT]}
\PYG{g+go}{                                [\PYGZhy{}\PYGZhy{}slwindow SLWINDOW]}
\PYG{g+go}{                                [\PYGZhy{}\PYGZhy{}smoothwidth SMOOTHWIDTH]}

\PYG{g+go}{class description:}

\PYG{g+go}{    Basic global peak detection analysis. The default implementation}
\PYG{g+go}{    computes the peaks on the average spectrum and then computes the peak\PYGZhy{}cube data,}
\PYG{g+go}{    i.e., the values for the detected peaks at each pixel.}

\PYG{g+go}{    TODO: The current version assumes 2D data}


\PYG{g+go}{execution description:}

\PYG{g+go}{        Execute the global peak finding for the given msidata and mzdata.}


\PYG{g+go}{optional arguments:}
\PYG{g+go}{  \PYGZhy{}h, \PYGZhy{}\PYGZhy{}help            show this help message and exit}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}save SAVE           Define the file and experiment where the analysis}
\PYG{g+go}{                        should be stored. A new file will be created if the}
\PYG{g+go}{                        given file does not exists but the directory does. The}
\PYG{g+go}{                        filename is expected to be of the from:}
\PYG{g+go}{                        \PYGZlt{}filename\PYGZgt{}:\PYGZlt{}entry\PYGZus{}\PYGZsh{}\PYGZgt{} . If no experiment index is}
\PYG{g+go}{                        given, then experiment index 0 (i.e, entry\PYGZus{}0) will be}
\PYG{g+go}{                        assumed by default. A validpath may, e.g, be}
\PYG{g+go}{                        \PYGZdq{}test.h5:/entry\PYGZus{}0\PYGZdq{} or jus \PYGZdq{}test.h5\PYGZdq{} (default: None)}

\PYG{g+go}{analysis settings:}
\PYG{g+go}{  Analysis settings}

\PYG{g+go}{  \PYGZhy{}\PYGZhy{}integration\PYGZus{}width INTEGRATION\PYGZus{}WIDTH}
\PYG{g+go}{                        The window over which peaks should be integrated}
\PYG{g+go}{                        (default: 0.1)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}peakheight PEAKHEIGHT}
\PYG{g+go}{                        Peak height parameter (default: 2)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}slwindow SLWINDOW   Sliding window parameter (default: 100)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}smoothwidth SMOOTHWIDTH}
\PYG{g+go}{                        Smooth width parameter (default: 3)}

\PYG{g+go}{input data:}
\PYG{g+go}{  Input data to be analyzed}

\PYG{g+go}{  \PYGZhy{}\PYGZhy{}msidata MSIDATA     The MSI dataset to be analyzed (default: None)}
\PYG{g+go}{  \PYGZhy{}\PYGZhy{}mzdata MZDATA       The m/z values for the spectra of the MSI dataset}
\PYG{g+go}{                        (default: None)}

\PYG{g+go}{how to specify ndarray data?}
\PYG{g+go}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{g+go}{n\PYGZhy{}dimensional arrays stored in OpenMSI data files may be specified as}
\PYG{g+go}{input parameters via the following syntax:}
\PYG{g+go}{      \PYGZhy{}\PYGZhy{} MSI data: \PYGZlt{}filename\PYGZgt{}.h5:/entry\PYGZus{}\PYGZsh{}/data\PYGZus{}\PYGZsh{}}
\PYG{g+go}{      \PYGZhy{}\PYGZhy{} Analysis data: \PYGZlt{}filename\PYGZgt{}.h5:/entry\PYGZus{}\PYGZsh{}/analysis\PYGZus{}\PYGZsh{}/\PYGZlt{}dataname\PYGZgt{}}
\PYG{g+go}{      \PYGZhy{}\PYGZhy{} Arbitrary dataset: \PYGZlt{}filename\PYGZgt{}.h5:\PYGZlt{}object\PYGZus{}path\PYGZgt{}}
\PYG{g+go}{E.g. a valid definition may look like: \PYGZsq{}test\PYGZus{}brain\PYGZus{}convert.h5:/entry\PYGZus{}0/data\PYGZus{}0\PYGZsq{}}
\PYG{g+go}{In rear cases we may need to manually define an array (e.g., a mask)}
\PYG{g+go}{Here we can use standard python syntax, e.g, \PYGZsq{}[1,2,3,4]\PYGZsq{} or \PYGZsq{}[[1, 3], [4, 5]]\PYGZsq{}}

\PYG{g+go}{This command\PYGZhy{}line tool has been auto\PYGZhy{}generated using the OpenMSI Toolkit}
\end{Verbatim}


\section{Advanced: Customizing core features}
\label{custom_analysis:advanced-customizing-core-features}

\subsection{Custom data save}
\label{custom_analysis:custom-data-save}
In most cases the default data save and restore functions should be sufficient. However, the \code{analysis\_base} API also supports implementation of custom HDF5 write. To extend the existing data write code, simple implement the following function provided by \code{analysis\_base} .

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}custom\PYGZus{}data\PYGZus{}to\PYGZus{}omsi\PYGZus{}file}\PYG{p}{(}\PYG{n+nb+bp}{self} \PYG{p}{,} \PYG{n}{analysisGroup}\PYG{p}{)} \PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}This function can be optionally overwritten to implement a custom data write}
\PYG{l+s+sd}{       function for the analysis to be used by the omsi\PYGZus{}file API.}

\PYG{l+s+sd}{       Note, this function should be used only to add additional data to the analysis}
\PYG{l+s+sd}{       group. The data that is written by default is typically still written by the}
\PYG{l+s+sd}{       omsi\PYGZus{}file\PYGZus{}experiment.create\PYGZus{}analysis() function, i.e., the following data is}
\PYG{l+s+sd}{       wirtten by default: i) analysis\PYGZus{}identifier ,ii) get\PYGZus{}analysis\PYGZus{}type,}
\PYG{l+s+sd}{       iii)\PYGZus{}\PYGZus{}data\PYGZus{}list, iv) \PYGZus{}\PYGZus{}parameter\PYGZus{}list , v) \PYGZus{}\PYGZus{}dependency\PYGZus{}list. Since the}
\PYG{l+s+sd}{       omsi\PYGZus{}file.experiment.create\PYGZus{}analysis() functions takes care of setting up the}
\PYG{l+s+sd}{       basic structure of the analysis storage (included the subgroubs for storing}
\PYG{l+s+sd}{       parameters and data dependencies) this setup can generally be assumed to exist}
\PYG{l+s+sd}{       before this function is called. This function is called automatically at the}
\PYG{l+s+sd}{       end omsi\PYGZus{}file.experiment.create\PYGZus{}analysis() (i.e, actually}
\PYG{l+s+sd}{       omsi\PYGZus{}file\PYGZus{}analysis.\PYGZus{}\PYGZus{}populate\PYGZus{}analysis\PYGZus{}\PYGZus{}(..)) so that this function does not need}
\PYG{l+s+sd}{       to be called explicitly.}

\PYG{l+s+sd}{       Keyword Arguments:}

\PYG{l+s+sd}{       :param analysisGroup: The omsi\PYGZus{}file\PYGZus{}analysis object of the group for the}
\PYG{l+s+sd}{                             analysis that can be used for writing.}

\PYG{l+s+sd}{       \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{pass}
\end{Verbatim}


\subsection{Custom analysis restore}
\label{custom_analysis:custom-analysis-restore}
Similarly in order implement custom data restore behavior we can overwrite the default implementation of \code{omsi.analysis.analysis\_base.analysis\_base.read\_from\_omsi\_file()} . In this case one will usually call the default implementation via \code{super(omsi\_myanalysis,self).read\_from\_omsi\_file(...)} first and then add any additional behavior.


\subsection{Custom analysis execution}
\label{custom_analysis:custom-analysis-execution}
Analysis are typically executed using the \code{omsi.analysis.analysis\_base.analysis\_base.execute()} function we inherit from py:class:\emph{omsi.analysis.analysis\_base.analysis\_base}. The \code{execute()} function controls many pieces, from recording and defining input parameters and outputs to executing the actual analysis. We, therefore, for NOT recommend to overwrite the \code{exceute(..)} function, but rather to customize specific portions of the execution. To do this, \emph{execute()} is broken into a number of functions which are called in a specific order. In this way we can easily overwrite select functions to customize a particular feature without having to overwrite the complete \code{execute(..)} function.


\subsubsection{Customizing setting of parameters}
\label{custom_analysis:customizing-setting-of-parameters}
First, the execute function uses \code{omsi.analysis.analysis\_base.analysis\_base.update\_analysis\_parameters()} to set all parameters that have been passed to execute accordingly. The default implementation of \code{update\_analysis\_parameters(..)}, hence, simply calls \code{self.set\_parameter\_values(...)} to set all parameter values. We can customize this behavior simply by overwriting the \code{update\_analysis\_parameters(...)} function.


\subsubsection{Customizing setting of default settings}
\label{custom_analysis:customizing-setting-of-default-settings}
Second, the execute function uses the \code{omsi.analysis.analysis\_base.analysis\_base.define\_missing\_parameters()} function to set any required parameters that have not been set by the user to their respective values. Overwrite this function to customize how default parameter values are determined/set.


\subsubsection{Customizing the recording of runtime information}
\label{custom_analysis:customizing-the-recording-of-runtime-information}
The recording of runtime information is performed using the \code{omsi.shared.run\_info\_data.run\_info\_dict()} data structure. This data structure provides a series of functions that are called in order, in particular:
\begin{itemize}
\item {} 
\code{omsi.shared.run\_info\_data.run\_info\_dict.clear()} : This function is called first to clear the runtime dictionary. This is the same as the standard dict.clear.

\item {} 
\code{omsi.shared.run\_info\_data.run\_info\_dict.record\_preexecute()} : This function is called before the \code{execute\_analysis} function is called and records basic system information,

\item {} 
\code{omsi.shared.run\_info\_data.run\_info\_dict.record\_postexecute()} : This function is called after the  \code{execute\_analysis} function has completed to record additional information, e.g, the time and duration of the analysis,

\item {} 
\code{omsi.shared.run\_info\_data.run\_info\_dict..runinfo\_clean\_up()} : This function is called at the end to clean up the recorded runtime information. By default, \code{runinfo\_clean\_up()} removes any empty entries, i.e., key/value pairs where the value is either None or an empty string.

\end{itemize}

We can customize any of these function by implementing a derived class of \code{omsi.shared.run\_info\_data.run\_info\_dict()} where we can overwrite the functions. In order to use our derived class we can then assign our object to \code{omsi.analysis.analysis\_base.analysis\_base.run\_info()}. This design allows us to modularly use the runtime information tracking also for other tasks, not just with our analysis base infrastructure.


\subsubsection{Customizing the analysis execution}
\label{custom_analysis:customizing-the-analysis-execution}
The analysis is completely implemented in the \code{omsi.analysis.analysis\_base.analysis\_base.execute\_analysis()} function, which we have to implement in our derived class, i.e, running the analysis is fully custom anyways.


\subsubsection{Customizing the recording of analysis outputs}
\label{custom_analysis:customizing-the-recording-of-analysis-outputs}
Finally (i.e., right before returning analysis results), \code{execute(..)} uses the \code{omsi.analysis.analysis\_base.analysis\_base.record\_execute\_analysis\_outputs()} function to save all analysis outputs. Analysis outputs are stored in the self.\_\_data\_list variable. We can save analysis outputs simply by slicing and assignment, e.g., \emph{self{[}output\_name{]} = my\_output}. By overwriting \emph{record\_execute\_analysis\_outputs(...)} we can customize the recording of data outputs.


\section{Wrapping a function: The quick-and-dirty way}
\label{custom_analysis:wrapping-a-function-the-quick-and-dirty-way}
Sometimes developers just want to debug some analysis function or experiment with different variants of a code. At the same time, we want to be able to track the results of these kind of experiments in a simple fashion. The {\hyperref[omsi.analysis:module\string-omsi.analysis.generic]{\emph{\code{omsi.analysis.generic()}}}} provides us with such a quick-and-dirty solution. We say quick-and-dirty because it sacrifices some generality and features in favor for a very simple process.

Using the {\hyperref[omsi.analysis:omsi.analysis.generic.analysis_generic.from_function]{\emph{\code{omsi.analysis.generic.analysis\_generic.from\_function()}}}} or {\hyperref[omsi.analysis:omsi.analysis.generic.bastet_analysis]{\emph{\code{omsi.analysis.generic.bastet\_analysis()}}}} decorator, we can easily construct a generic {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}} instance container object for a given function. We can then use this container object to execute our function, while tracking its provenance as well as save the results to file as we would with any other analysis object. This approach allows us to easily track, record, safe, share and reproduce code experiments with only minimal extra effort needed. Here we briefly outline the two main options to do this:


\subsection{Option 1: Explicitly track specific excutions of a function}
\label{custom_analysis:option-1-explicitly-track-specific-excutions-of-a-function}
Instead of calling our analysis function \code{f()} directly, we create an instance of {\hyperref[omsi.analysis:omsi.analysis.generic.analysis_generic]{\emph{\code{omsi.analysis.generic.analysis\_generic()}}}} via \code{g = analysis\_generic.from\_function(f)} which we then use instead of our function. To execute our function we can now either call \code{g.execute(...)} as usual or treat \code{g} as a function and call it directly \code{g(...)}

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.analysis.generic} \PYG{k+kn}{import} \PYG{n}{analysis\PYGZus{}generic}

\PYG{c+c1}{\PYGZsh{} Define some example function we want to wrap to track results}
\PYG{k}{def} \PYG{n+nf}{mysum}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create an analysis object for our function}
\PYG{n}{g} \PYG{o}{=} \PYG{n}{analysis\PYGZus{}generic}\PYG{o}{.}\PYG{n}{from\PYGZus{}function}\PYG{p}{(}\PYG{n}{mysum}\PYG{p}{)}
\PYG{n}{g}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} This is the same as:  g(np.arange(10))}
\end{Verbatim}


\subsection{Option 2: Implicitly track the last execution of a function}
\label{custom_analysis:option-2-implicitly-track-the-last-execution-of-a-function}
If we are only interested in recording the last execution of our function, then we can alternatively wrap our function directly using the \code{@bastet\_analysis} decorator. The main difference between the two approaches is that using the decorator we only record the last execution of our function, while using the explicit approach of option 1, we can create as many wrapped instances of our functions as we want and track the execution of each independently.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.shared.log} \PYG{k+kn}{import} \PYG{n}{log\PYGZus{}helper}
\PYG{n}{log\PYGZus{}helper}\PYG{o}{.}\PYG{n}{set\PYGZus{}log\PYGZus{}level}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DEBUG}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.analysis.generic} \PYG{k+kn}{import} \PYG{n}{bastet\PYGZus{}analysis}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.dataformat.omsi\PYGZus{}file.main\PYGZus{}file} \PYG{k+kn}{import} \PYG{n}{omsi\PYGZus{}file}

\PYG{c+c1}{\PYGZsh{} Define some example function and wrap it}
\PYG{n+nd}{@bastet\PYGZus{}analysis}
\PYG{k}{def} \PYG{n+nf}{mysum}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Our own sum function\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Execute the analysis}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{mysum}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}


\subsection{Example 1: Defining and using wrapped functions}
\label{custom_analysis:example-1-defining-and-using-wrapped-functions}
The code example shown below illustrates the ``wrapping'' of a simple example function \code{mysum(a)}, which simply uses \code{numpy.sum} to compute the sum of objects in an array. (NOTE: We could naturally also use \code{numpy.sum} directly, we use \code{mysum(a)} mainly to illustrate that this approach also works wit functions defined in the interpreter.)

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.shared.log} \PYG{k+kn}{import} \PYG{n}{log\PYGZus{}helper}
\PYG{n}{log\PYGZus{}helper}\PYG{o}{.}\PYG{n}{set\PYGZus{}log\PYGZus{}level}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{INFO}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.analysis.generic} \PYG{k+kn}{import} \PYG{n}{analysis\PYGZus{}generic}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.dataformat.omsi\PYGZus{}file.main\PYGZus{}file} \PYG{k+kn}{import} \PYG{n}{omsi\PYGZus{}file}

\PYG{c+c1}{\PYGZsh{} Define some example function we want to wrap to track results}
\PYG{k}{def} \PYG{n+nf}{mysum}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create an analysis object for our function}
\PYG{n}{g} \PYG{o}{=} \PYG{n}{analysis\PYGZus{}generic}\PYG{o}{.}\PYG{n}{from\PYGZus{}function}\PYG{p}{(}\PYG{n}{mysum}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Execute the analysis}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{n}{a}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{log\PYGZus{}helper}\PYG{o}{.}\PYG{n}{log\PYGZus{}var}\PYG{p}{(}\PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{,} \PYG{n}{res}\PYG{o}{=}\PYG{n}{res}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Logging the result}

\PYG{c+c1}{\PYGZsh{} Save the analysis to file}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{omsi\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{autowrap\PYGZus{}test.h5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{e} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{create\PYGZus{}experiment}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{exp\PYGZus{}index} \PYG{o}{=} \PYG{n}{e}\PYG{o}{.}\PYG{n}{get\PYGZus{}experiment\PYGZus{}index}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ana\PYGZus{}obj}\PYG{p}{,} \PYG{n}{ana\PYGZus{}index} \PYG{o}{=} \PYG{n}{e}\PYG{o}{.}\PYG{n}{create\PYGZus{}analysis}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Close the file}
\PYG{n}{f}\PYG{o}{.}\PYG{n}{flush}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{del} \PYG{n}{f}

\PYG{c+c1}{\PYGZsh{} Restore the analysis from file}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{omsi\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{autowrap\PYGZus{}test.h5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{e} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{get\PYGZus{}experiment}\PYG{p}{(}\PYG{n}{exp\PYGZus{}index}\PYG{p}{)}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{e}\PYG{o}{.}\PYG{n}{get\PYGZus{}analysis}\PYG{p}{(}\PYG{n}{ana\PYGZus{}index}\PYG{p}{)}
\PYG{n}{g2} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{restore\PYGZus{}analysis}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{res2} \PYG{o}{=} \PYG{n}{g2}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{log\PYGZus{}helper}\PYG{o}{.}\PYG{n}{log\PYGZus{}var}\PYG{p}{(}\PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{,} \PYG{n}{res2}\PYG{o}{=}\PYG{n}{res2}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Logging the result}
\PYG{k}{if} \PYG{n}{res} \PYG{o}{==} \PYG{n}{res2}\PYG{p}{:}
    \PYG{n}{log\PYGZus{}helper}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CONGRATULATIONS\PYGZhy{}\PYGZhy{}\PYGZhy{}The results matched}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{log\PYGZus{}helper}\PYG{o}{.}\PYG{n}{error}\PYG{p}{(}\PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SORRY\PYGZhy{}\PYGZhy{}\PYGZhy{}The results did not match}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

When we run our script, we can see that we were able to successfully capture the
execution of our function and recreate the analysis from file.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
machine:dir username\PYGZdl{} python autowrap\PYGZus{}function.py
2015\PYGZhy{}09\PYGZhy{}29 15:21:32,729 \PYGZhy{} \PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{} \PYGZhy{} INFO \PYGZhy{} \PYG{n+nv}{res} \PYG{o}{=} 45
2015\PYGZhy{}09\PYGZhy{}29 15:21:32,778 \PYGZhy{} \PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{} \PYGZhy{} INFO \PYGZhy{} \PYG{n+nv}{res2} \PYG{o}{=} 45
2015\PYGZhy{}09\PYGZhy{}29 15:21:32,778 \PYGZhy{} \PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{} \PYGZhy{} INFO \PYGZhy{} CONGRATULATIONS\PYGZhy{}\PYGZhy{}\PYGZhy{}The results matched
\end{Verbatim}

The figure below shows a view of the file generated by our wrapped function execution example shown above.
\begin{figure}[htbp]
\centering

\scalebox{0.500000}{\includegraphics{{wrap_function_result}.png}}
\label{custom_analysis:wrap-function-result-figure}\end{figure}

Note, we can use the wrapped function objects as usual in an analysis workflow to combine our functions with other analyses. For example, the simple example shown below shows how we can quickly define a simple filter to set all intensities that are less than 10 to a value of 0 before executing an analysis. We here first execute global peak finding to reduce the data, than apply a simple wrapped filter function to filter the data values, and then compute NMF on the filtered data.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{omsi.dataformat.omsi\PYGZus{}file} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.analysis.findpeaks.omsi\PYGZus{}findpeaks\PYGZus{}global} \PYG{k+kn}{import} \PYG{n}{omsi\PYGZus{}findpeaks\PYGZus{}global}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.analysis.multivariate\PYGZus{}stats.omsi\PYGZus{}nmf} \PYG{k+kn}{import} \PYG{n}{omsi\PYGZus{}nmf}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.analysis.generic} \PYG{k+kn}{import} \PYG{n}{analysis\PYGZus{}generic}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{n}{f} \PYG{o}{=} \PYG{n}{omsi\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/Users/oruebel/Devel/openmsi\PYGZhy{}data/msidata/20120711\PYGZus{}Brain.h5}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{get\PYGZus{}experiment}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{get\PYGZus{}msidata}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Specify the analysis workflow}
\PYG{n}{a1} \PYG{o}{=} \PYG{n}{omsi\PYGZus{}findpeaks\PYGZus{}global}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{a1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{msidata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{d}
\PYG{n}{a1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mzdata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{d}\PYG{o}{.}\PYG{n}{mz}

\PYG{c+c1}{\PYGZsh{} Wrap a simple function to filter all peaks with less than 10 counts}
\PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a}\PYG{p}{[}\PYG{n}{a}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{return} \PYG{n}{a}
\PYG{n}{a2} \PYG{o}{=} \PYG{n}{analysis\PYGZus{}generic}\PYG{o}{.}\PYG{n}{from\PYGZus{}function}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
\PYG{n}{a2}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak\PYGZus{}cube}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}    \PYG{c+c1}{\PYGZsh{} Use the peak\PYGZus{}cube from a1 as input for the filter}

\PYG{c+c1}{\PYGZsh{} Create an NMF for the filtered data}
\PYG{n}{a3} \PYG{o}{=} \PYG{n}{omsi\PYGZus{}nmf}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{a3}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{msidata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a2}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{output\PYGZus{}0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} Make the output of our analysis the input of the NMF}
\PYG{n}{a3}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{numIter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}

\PYG{c+c1}{\PYGZsh{} Run our simple workflow, i.e.,: peak\PYGZus{}finder \PYGZhy{}\PYGZhy{}\PYGZgt{} our\PYGZus{}filter \PYGZhy{}\PYGZhy{}\PYGZgt{} nmf}
\PYG{n}{a3}\PYG{o}{.}\PYG{n}{execute\PYGZus{}recursive}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

By default, the outputs are named and numbered using the schema \code{output\_\#}, i.e., in the above example we used \code{a2{[}'output\_0'{]}} to access the output our wrapped function. To define user-defined names for the outputs of a wrapped function we can simply provide a list of strings to the input parameter \code{output\_names} of the \code{analysis\_generic.from\_function(...)}.

\textbf{NOTE:} Wrapping functions directly is not recommended for production workflows but is intended for development and debugging purposes only. This mechanism relies on that the library does the right thing in automatically determining input parameters, outputs, and their types and that we can handle all those types in the end-to-end process, from definition to storage. We do our best to make this mechanism work with a broad set of cases but we do not guarantee that the simple wrapping always work.


\chapter{Defining and Executing Analysis Workflows}
\label{basic_workflows::doc}\label{basic_workflows:defining-and-executing-analysis-workflows}
Figure {\hyperref[basic_workflows:workflow\string-illustration]{\emph{Illustration of an example workflow for image normalization}}}, illustrates the basic steps of using analysis workflows, i.e,.:
\begin{enumerate}
\item {} 
Create the analysis tasks

\item {} 
Define the analysis inputs

\item {} 
Execute

\end{enumerate}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{1.000000}{\includegraphics{{workflow_illustration}.png}}
\caption{Illustration of an example workflow for image normalization}\label{basic_workflows:workflow-illustration}\end{figure}

In the following we will use a simple analysis---workflow in which we compute a peak-cube from a raw MSI dataset and then compute an NMF from the peak cube---to illustrate the main steps involved for performing complex analysis workflows.


\section{Step 1: Create the analysis tasks:}
\label{basic_workflows:step-1-create-the-analysis-tasks}
First we need to create our main analysis objects.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{omsi.dataformat.omsi\PYGZus{}file} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.analysis.findpeaks.omsi\PYGZus{}findpeaks\PYGZus{}global} \PYG{k+kn}{import} \PYG{n}{omsi\PYGZus{}findpeaks\PYGZus{}global}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.analysis.multivariate\PYGZus{}stats.omsi\PYGZus{}nmf} \PYG{k+kn}{import} \PYG{n}{omsi\PYGZus{}nmf}

\PYG{c+c1}{\PYGZsh{} Open a file to get some MSI data}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{omsi\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/Users/oruebel/Devel/openmsi\PYGZhy{}data/msidata/20120711\PYGZus{}Brain.h5}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{get\PYGZus{}experiment}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{get\PYGZus{}msidata}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Specify the analysis workflow}
\PYG{c+c1}{\PYGZsh{} Create a global peak finding analysis}
\PYG{n}{a1} \PYG{o}{=} \PYG{n}{omsi\PYGZus{}findpeaks\PYGZus{}global}\PYG{p}{(}\PYG{p}{)}      \PYG{c+c1}{\PYGZsh{} Create the analysis}
\PYG{c+c1}{\PYGZsh{} Create an NMF that processes our peak cube}
\PYG{n}{a2}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{numIter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}                 \PYG{c+c1}{\PYGZsh{} Set input to perform 2 iterations only}
\end{Verbatim}


\section{Step 2: Define analysis inputs:}
\label{basic_workflows:step-2-define-analysis-inputs}
We can define the input parameters of analysis simply using standard dict-like assignment. Any dependencies between analysis tasks or OpenMSI files are created automatically for us.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{} Define the inputs of the global peak finder}
\PYG{n}{a1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{msidata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{d}                 \PYG{c+c1}{\PYGZsh{} Set the input msidata}
\PYG{n}{a1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mzdata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{d}\PYG{o}{.}\PYG{n}{mz}               \PYG{c+c1}{\PYGZsh{} Set the input mz data}
\PYG{c+c1}{\PYGZsh{} Define the inputs of the NMF}
\PYG{n}{a2}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{msidata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak\PYGZus{}cube}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}   \PYG{c+c1}{\PYGZsh{} Set the input data to the peak cube}
\PYG{n}{a2}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{numIter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}                 \PYG{c+c1}{\PYGZsh{} Set input to perform 2 iterations only}
\end{Verbatim}

NOTE: So far we have only specified our workflow. We have not executed any analysis yet, nor have we loaded any actual data yet.


\section{Step 3: Execute}
\label{basic_workflows:step-3-execute}
Finally we need to execute our analyses. For this we have various options, depending on which parts of our workflow we want to execute.


\subsection{Executing a single analysis}
\label{basic_workflows:executing-a-single-analysis}
To execute a single analysis, we can simply call the \code{execute()} function of our analysis. Note, the execute may raise and \code{AnalysisReadyError} in case that the inputs of the analsis are not ready. E.g.:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{a2}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Will fail with {}`{}`AnalysisReadyError{}`{}`}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{a1}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Will successfully execute a1}
\end{Verbatim}


\subsection{Executing a single sub-workflow}
\label{basic_workflows:executing-a-single-sub-workflow}
To execute a single analysis including any missing dependencies, we can simply call the \code{execute\_recursive()} function. E.g.:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{a2}\PYG{o}{.}\PYG{n}{execute\PYGZus{}recursive}\PYG{p}{(}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Will successfully execute a1}
\end{Verbatim}

The above will execute \code{a1} as well as \code{a2} since \code{a2} depends on \code{a1}.

\textbf{NOTE:} Recursive execution will only execute other analyses that are actually needed to complete our analysis and analysis results of dependent analyses that have been executed before will be reused. E.g., if we would call \code{a2.execute\_recursive()} again, then only \code{a2} would be executed again.

\textbf{NOTE:} When executing multiple dependent analyses, then the execution is typically controlled by a workflow executor py:meth:\emph{omsi.workflow.executor}. By default, \code{execute\_recursive(..)} will automatically create a default driver. If we want to customize the driver to be used then we can simply assign a driver to the analysis before-hand by setting the py:var:\emph{omsi.analysis.base.analysis\_base.driver{}`} instance variable.


\subsection{Executing all analyses}
\label{basic_workflows:executing-all-analyses}
To run all analyses that have been created---independent of whether they depend on each other or not---we can simply call {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base.execute_all]{\emph{\code{omsi.analysis.base.analysis\_base.execute\_all()}}}}.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{a1}\PYG{o}{.}\PYG{n}{execute\PYGZus{}all}\PYG{p}{(}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Execute all analyses}
\end{Verbatim}

The above will execute any analysis that have not up-to-date. NOTE: In contrast to py:meth:\emph{omsi.analysis.base.analysis\_base.execute} and py:meth:\emph{omsi.analysis.base.analysis\_base.execute\_recursive}, this is a class-level method and not an object-method. Again, the function uses a workflow driver, which we can customize by providing as driver as input to the function.


\subsection{Executing multiple sub-workflows}
\label{basic_workflows:executing-multiple-sub-workflows}
To explicitly execute a subset of analyses (and all their dependencies) we can explicitly define a driver for the workflow we want to execute:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{from} \PYG{n+nn}{omsi.workflow.driver.greedy\PYGZus{}executor} \PYG{k+kn}{import} \PYG{n}{greedy\PYGZus{}executor}
\PYG{n}{driver} \PYG{o}{=} \PYG{n}{greedy\PYGZus{}executor}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Create a driver}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{add\PYGZus{}analysis}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{)}            \PYG{c+c1}{\PYGZsh{} Add one ore more analyses}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{add\PYGZus{}analysis}\PYG{p}{(}\PYG{n}{a2}\PYG{p}{)}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{p}{)}                   \PYG{c+c1}{\PYGZsh{} Execute the workflow and its dependencies}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{driver2} \PYG{o}{=} \PYG{n}{greedy\PYGZus{}executor}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{driver2}\PYG{o}{.}\PYG{n}{add\PYGZus{}analysis\PYGZus{}all}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Add all analyses}
\PYG{n}{driver2}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Execute all analyses}
\end{Verbatim}


\section{Example: Normalizing an image}
\label{basic_workflows:example-normalizing-an-image}
The goal of this example is to 1) illustrate the general concepts of how we can define analysis workflows and 2) illustrate the use of simple wrapped functions in combination with integrated analytics to create complex analysis workflows. The example shown below defines a basic image normalization workflow in which we:
\begin{enumerate}
\item {} 
Compute a reduced peak cube from an MSI image using the global peak finding analysis provided by BASTet

\item {} 
Use a simple wrapped function to compute the total intensity image for the peak cube dataset computed in step 1

\item {} 
use a simple wrapped function to normalize the peak cube computed in step 1 using the total intensity image computed in step 2

\end{enumerate}

This is the same workflow as shown in Figure {\hyperref[basic_workflows:workflow\string-illustration]{\emph{Illustration of an example workflow for image normalization}}}.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{\PYGZsh{} Illustration of the basic image normalization workflow defined below:}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}a1\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}a2\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}a3\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}global\PYGZhy{}peak\PYGZhy{}finder\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+       +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}total\PYGZus{}intensities\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+       +\PYGZhy{}\PYGZhy{}\PYGZhy{}normalize\PYGZus{}intensities\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{} \textbar{}                         \textbar{}       \textbar{}                               \textbar{}       \textbar{}                           \textbar{}}
\PYG{c+c1}{\PYGZsh{} \textbar{} msidata       peak\PYGZus{}cube +\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} msidata      total\PYGZus{}intensities+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} norm\PYGZus{}factors     output\PYGZus{}0 \textbar{}}
\PYG{c+c1}{\PYGZsh{} \textbar{}                         \textbar{}   \textbar{}   \textbar{}                               \textbar{}       \textbar{}                           \textbar{}}
\PYG{c+c1}{\PYGZsh{} \textbar{} mzdata                  \textbar{}   \textbar{}   \textbar{} axis=2                        \textbar{}   +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} msidata                   \textbar{}}
\PYG{c+c1}{\PYGZsh{} +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+   \textbar{}   +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+   \textbar{}   +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\PYG{c+c1}{\PYGZsh{}                               \textbar{}                                       \textbar{}}
\PYG{c+c1}{\PYGZsh{}                               \textbar{}                                       \textbar{}}
\PYG{c+c1}{\PYGZsh{}                               +\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.shared.log} \PYG{k+kn}{import} \PYG{n}{log\PYGZus{}helper}
\PYG{n}{log\PYGZus{}helper}\PYG{o}{.}\PYG{n}{set\PYGZus{}log\PYGZus{}level}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DEBUG}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.analysis.findpeaks.omsi\PYGZus{}findpeaks\PYGZus{}global} \PYG{k+kn}{import} \PYG{n}{omsi\PYGZus{}findpeaks\PYGZus{}global}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.dataformat.omsi\PYGZus{}file.main\PYGZus{}file} \PYG{k+kn}{import} \PYG{n}{omsi\PYGZus{}file}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.analysis.generic} \PYG{k+kn}{import} \PYG{n}{analysis\PYGZus{}generic}

\PYG{c+c1}{\PYGZsh{} Define a simple function to compute the total intensity image}
\PYG{k}{def} \PYG{n+nf}{total\PYGZus{}intensity}\PYG{p}{(}\PYG{n}{msidata}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
    \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{msidata}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{n}{axis}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define a simple function to normalize an MSI data cube by per\PYGZhy{}spectrum normalization factors}
\PYG{k}{def} \PYG{n+nf}{normalize\PYGZus{}intensities}\PYG{p}{(}\PYG{n}{msidata}\PYG{p}{,} \PYG{n}{normfactors}\PYG{p}{)}\PYG{p}{:}
    \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
    \PYG{k}{return} \PYG{n}{msidata} \PYG{o}{/} \PYG{n}{normfactors}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{newaxis}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Get an ezample MSI image}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{omsi\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/Users/oruebel/Devel/openmsi\PYGZhy{}data/msidata/20120711\PYGZus{}Brain.h5}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{get\PYGZus{}experiment}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{get\PYGZus{}msidata}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define the global peak finder}
\PYG{n}{a1} \PYG{o}{=} \PYG{n}{omsi\PYGZus{}findpeaks\PYGZus{}global}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{a1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{msidata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{d}
\PYG{n}{a1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mzdata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{d}\PYG{o}{.}\PYG{n}{mz}

\PYG{c+c1}{\PYGZsh{} Define compute of total intensity image}
\PYG{n}{a2} \PYG{o}{=} \PYG{n}{analysis\PYGZus{}generic}\PYG{o}{.}\PYG{n}{from\PYGZus{}function}\PYG{p}{(}\PYG{n}{analysis\PYGZus{}function}\PYG{o}{=}\PYG{n}{total\PYGZus{}intensity}\PYG{p}{,}
                                    \PYG{n}{output\PYGZus{}names}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{total\PYGZus{}intensities}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{a2}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{msidata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak\PYGZus{}cube}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Define the normalization of the peak cube}
\PYG{n}{a3} \PYG{o}{=} \PYG{n}{analysis\PYGZus{}generic}\PYG{o}{.}\PYG{n}{from\PYGZus{}function}\PYG{p}{(}\PYG{n}{normalize\PYGZus{}intensities}\PYG{p}{)}
\PYG{n}{a3}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{msidata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak\PYGZus{}cube}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{a3}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{normfactors}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a2}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{total\PYGZus{}intensities}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} To run the workflow we now have several basic options}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} 1) a3.execute\PYGZus{}recursive()  : Recursively execute the last analysis and all its dependencies (i.e., a1, a2)}
\PYG{c+c1}{\PYGZsh{} 2) a1.execute\PYGZus{}all() : Tell any analysis to execute all available analyses (i.e., a1,a2,a3)}
\PYG{c+c1}{\PYGZsh{} 3) Create our own workflow driver to control the execution of the analyses}
\PYG{c+c1}{\PYGZsh{} 4) Manually call execute on a1, a2, and a3 in order of their dependencies}

\PYG{c+c1}{\PYGZsh{} Execute the workflow}
\PYG{n}{a3}\PYG{o}{.}\PYG{n}{execute\PYGZus{}recursive}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\chapter{Workflow Tools}
\label{basic_workflows:workflow-tools}
Similar to the {\hyperref[omsi.workflow.driver:module\string-omsi.workflow.driver.cl_analysis_driver]{\emph{\code{omsi.workflow.driver.cl\_analysis\_driver}}}} (and the corresponding tool {\hyperref[omsi.tools:module\string-omsi.tools.run_analysis]{\emph{\code{omsi.tools.run\_analysis}}}}) for running single analysis tasks, BASTet provides basic tools for executing complete workflows via the concept of workflow dirvers. Users may implement their own drivers using the approbriate base classes {\hyperref[omsi.workflow.driver:module\string-omsi.workflow.driver.base]{\emph{\code{omsi.workflow.driver.base}}}}.

Some basic drivers and tools are already available with BASTet, e.g., the {\hyperref[omsi.workflow.driver:module\string-omsi.workflow.driver.cl_workflow_driver]{\emph{\code{omsi.workflow.driver.cl\_workflow\_driver}}}} module (and the corresponding tool \code{omsi.tools.run\_workflow}) defines a driver for driving and executing one or multiple workflows defined via workflow scripts, directly from the command-line.


\section{Workflow Scripts}
\label{basic_workflows:workflow-scripts}
Workflow scripts are regular python scripts that include the i) creation of the analusis objects, and ii) full or partial definition of analysis parameters but usually \textbf{NOT} the actual execution of any of the analyses. Following our example from earlier, we may simply save the following code in python source file, e.g, \emph{normalize\_image.py}.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.analysis.findpeaks.omsi\PYGZus{}findpeaks\PYGZus{}global} \PYG{k+kn}{import} \PYG{n}{omsi\PYGZus{}findpeaks\PYGZus{}global}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.dataformat.omsi\PYGZus{}file.main\PYGZus{}file} \PYG{k+kn}{import} \PYG{n}{omsi\PYGZus{}file}
\PYG{k+kn}{from} \PYG{n+nn}{omsi.analysis.generic} \PYG{k+kn}{import} \PYG{n}{analysis\PYGZus{}generic}

\PYG{c+c1}{\PYGZsh{} Define a simple function to compute the total intensity image}
\PYG{k}{def} \PYG{n+nf}{total\PYGZus{}intensity}\PYG{p}{(}\PYG{n}{msidata}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
    \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{msidata}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{n}{axis}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define a simple function to normalize an MSI data cube by per\PYGZhy{}spectrum normalization factors}
\PYG{k}{def} \PYG{n+nf}{normalize\PYGZus{}intensities}\PYG{p}{(}\PYG{n}{msidata}\PYG{p}{,} \PYG{n}{normfactors}\PYG{p}{)}\PYG{p}{:}
    \PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
    \PYG{k}{return} \PYG{n}{msidata} \PYG{o}{/} \PYG{n}{normfactors}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{newaxis}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Define the global peak finder}
\PYG{n}{a1} \PYG{o}{=} \PYG{n}{omsi\PYGZus{}findpeaks\PYGZus{}global}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define compute of total intensity image}
\PYG{n}{a2} \PYG{o}{=} \PYG{n}{analysis\PYGZus{}generic}\PYG{o}{.}\PYG{n}{from\PYGZus{}function}\PYG{p}{(}\PYG{n}{analysis\PYGZus{}function}\PYG{o}{=}\PYG{n}{total\PYGZus{}intensity}\PYG{p}{,}
                                    \PYG{n}{output\PYGZus{}names}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{total\PYGZus{}intensities}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{a2}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{msidata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak\PYGZus{}cube}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Define the normalization of the peak cube}
\PYG{n}{a3} \PYG{o}{=} \PYG{n}{analysis\PYGZus{}generic}\PYG{o}{.}\PYG{n}{from\PYGZus{}function}\PYG{p}{(}\PYG{n}{normalize\PYGZus{}intensities}\PYG{p}{)}
\PYG{n}{a3}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{msidata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a1}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{peak\PYGZus{}cube}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{a3}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{normfactors}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a2}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{total\PYGZus{}intensities}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{Verbatim}

When using our command-line tool, all parameters that are not defined for any of the analyses are automatically exposed via command-line options. In contrast to our previous example, we here, e.g., do not set the input msidata and mzdata parameters for our global peak finder (a1). In this way, we can now easily set the input file we want to process directly via the command line. In cases where we want to expose a parameter via the command line but still want to provide a good default setting for the user, we can set the default value of a parameter via, e.g, \code{a1.get\_parameter\_data\_by\_name('peakheight'){[}'default'{]} = 3}.

To execute our above example from the command line we can now simply do the following:

\begin{Verbatim}[commandchars=\\\{\}]
python run\PYGZus{}workflow.py \PYGZhy{}\PYGZhy{}script normalize\PYGZus{}image.py
                       \PYGZhy{}\PYGZhy{}ana\PYGZus{}0:msidata \PYG{n+nv}{\PYGZdl{}HOME}/20120711\PYGZus{}Brain.h5:/entry\PYGZus{}0/data\PYGZus{}0
                       \PYGZhy{}\PYGZhy{}ana\PYGZus{}0:mzdata  \PYG{n+nv}{\PYGZdl{}HOME}/20120711\PYGZus{}Brain.h5:/entry\PYGZus{}0/data\PYGZus{}0/mz
\end{Verbatim}

In order to avoid collisions between parameters with the same name for different analyses, the tool prepends the unique \code{analysis\_identifier} to each parameter. Since we did not set any explicit \code{analysis\_identifier{}` (e.g, via {}`{}`a1.analysis\_identifier='a1'}), the tool automatically generated unique identifiers (i.e, \code{ana\_0}, \code{ana\_1}, and \code{ana\_3} for our 3 analyses). To view all available command line option we can simply call the script with \code{-{-}help}. If one or more workflow scipts are given (here via seperate \code{-{-}script} parameters), then all unfilled options of those workflows and the corresponding analyses will be listed as. E.g.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
newlappy:tools oruebel\PYGZdl{} python run\PYGZus{}workflow.py \PYGZhy{}\PYGZhy{}script normalize\PYGZus{}image.py \PYGZhy{}\PYGZhy{}help
usage: run\PYGZus{}workflow.py \PYGZhy{}\PYGZhy{}script SCRIPT [\PYGZhy{}\PYGZhy{}save SAVE] [\PYGZhy{}\PYGZhy{}profile]
                       [\PYGZhy{}\PYGZhy{}memprofile]
                       [\PYGZhy{}\PYGZhy{}loglevel \PYGZob{}INFO,WARNING,CRITICAL,ERROR,DEBUG,NOTSET\PYGZcb{}]
                       \PYGZhy{}\PYGZhy{}ana\PYGZus{}0:msidata ANA\PYGZus{}0:MSIDATA \PYGZhy{}\PYGZhy{}ana\PYGZus{}0:mzdata
                       ANA\PYGZus{}0:MZDATA
                       [\PYGZhy{}\PYGZhy{}ana\PYGZus{}0:integration\PYGZus{}width ANA\PYGZus{}0:INTEGRATION\PYGZus{}WIDTH]
                       [\PYGZhy{}\PYGZhy{}ana\PYGZus{}0:peakheight ANA\PYGZus{}0:PEAKHEIGHT]
                       [\PYGZhy{}\PYGZhy{}ana\PYGZus{}0:slwindow ANA\PYGZus{}0:SLWINDOW]
                       [\PYGZhy{}\PYGZhy{}ana\PYGZus{}0:smoothwidth ANA\PYGZus{}0:SMOOTHWIDTH]
                       [\PYGZhy{}\PYGZhy{}ana\PYGZus{}1:axis ANA\PYGZus{}1:AXIS]
                       [\PYGZhy{}\PYGZhy{}reduce\PYGZus{}memory\PYGZus{}usage REDUCE\PYGZus{}MEMORY\PYGZus{}USAGE]
                       [\PYGZhy{}\PYGZhy{}synchronize SYNCHRONIZE] [\PYGZhy{}h]

Execute analysis workflow(s) based on a given set of scripts

required arguments:
  \PYGZhy{}\PYGZhy{}script SCRIPT       The workflow script to be executed. Multiple scripts
                        may be added via separate \PYGZhy{}\PYGZhy{}script arguments (default:
                        None)

optional arguments:
  \PYGZhy{}\PYGZhy{}save SAVE           Define the file and experiment where all analysis
                        results should be stored. A new file will be created
                        if the given file does not exists but the directory
                        does. The filename is expected to be of the from:
                        \PYGZlt{}filename\PYGZgt{}:\PYGZlt{}entry\PYGZus{}\PYGZsh{}\PYGZgt{} . If no experiment index is
                        given, then experiment index 0 (i.e, entry\PYGZus{}0) will be
                        assumed by default. A validpath may, e.g, be
                        \PYGZdq{}test.h5:/entry\PYGZus{}0\PYGZdq{} or jus \PYGZdq{}test.h5\PYGZdq{} (default: None)
  \PYGZhy{}\PYGZhy{}profile             Enable runtime profiling of the analysis. NOTE: This
                        is intended for debugging and investigation of the
                        runtime behavior of an analysis.Enabling profiling
                        entails certain overheads in performance (default:
                        False)
  \PYGZhy{}\PYGZhy{}memprofile          Enable runtime profiling of the memory usage of
                        analysis. NOTE: This is intended for debugging and
                        investigation of the runtime behavior of an analysis.
                        Enabling profiling entails certain overheads in
                        performance. (default: False)
  \PYGZhy{}\PYGZhy{}loglevel \PYGZob{}INFO,WARNING,CRITICAL,ERROR,DEBUG,NOTSET\PYGZcb{}
                        Specify the level of logging to be used. (default:
                        INFO)
  \PYGZhy{}h, \PYGZhy{}\PYGZhy{}help            show this help message and exit

ana\PYGZus{}0:omsi.analysis.findpeaks.omsi\PYGZus{}findpeaks\PYGZus{}global:analysis settings:
  Analysis settings

  \PYGZhy{}\PYGZhy{}ana\PYGZus{}0:integration\PYGZus{}width ANA\PYGZus{}0:INTEGRATION\PYGZus{}WIDTH
                        The window over which peaks should be integrated
                        (default: 0.1)
  \PYGZhy{}\PYGZhy{}ana\PYGZus{}0:peakheight ANA\PYGZus{}0:PEAKHEIGHT
                        Peak height parameter (default: 2)
  \PYGZhy{}\PYGZhy{}ana\PYGZus{}0:slwindow ANA\PYGZus{}0:SLWINDOW
                        Sliding window parameter (default: 100)
  \PYGZhy{}\PYGZhy{}ana\PYGZus{}0:smoothwidth ANA\PYGZus{}0:SMOOTHWIDTH
                        Smooth width parameter (default: 3)

ana\PYGZus{}0:omsi.analysis.findpeaks.omsi\PYGZus{}findpeaks\PYGZus{}global:input data:
  Input data to be analyzed

  \PYGZhy{}\PYGZhy{}ana\PYGZus{}0:msidata ANA\PYGZus{}0:MSIDATA
                        The MSI dataset to be analyzed (default: None)
  \PYGZhy{}\PYGZhy{}ana\PYGZus{}0:mzdata ANA\PYGZus{}0:MZDATA
                        The m/z values for the spectra of the MSI dataset
                        (default: None)

ana\PYGZus{}1 : generic:
  \PYGZhy{}\PYGZhy{}ana\PYGZus{}1:axis ANA\PYGZus{}1:AXIS

optional workflow executor options:
  Additional, optional settings for the workflow execution controls

  \PYGZhy{}\PYGZhy{}reduce\PYGZus{}memory\PYGZus{}usage REDUCE\PYGZus{}MEMORY\PYGZus{}USAGE
                        Reduce memory usage by pushing analyses to file each
                        time they complete, processing dependencies out\PYGZhy{}of\PYGZhy{}
                        core. (default: False)
  \PYGZhy{}\PYGZhy{}synchronize SYNCHRONIZE
                        Place an MPI\PYGZhy{}barrier at the beginning of the exection
                        of the workflow. This can be useful when we require
                        that all MPI ranks are fully initalized. (default:
                        False)

how to specify ndarray data?
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
n\PYGZhy{}dimensional arrays stored in OpenMSI data files may be specified as
input parameters via the following syntax:
      \PYGZhy{}\PYGZhy{} MSI data: \PYGZlt{}filename\PYGZgt{}.h5:/entry\PYGZus{}\PYGZsh{}/data\PYGZus{}\PYGZsh{}
      \PYGZhy{}\PYGZhy{} Analysis data: \PYGZlt{}filename\PYGZgt{}.h5:/entry\PYGZus{}\PYGZsh{}/analysis\PYGZus{}\PYGZsh{}/\PYGZlt{}dataname\PYGZgt{}
      \PYGZhy{}\PYGZhy{} Arbitrary dataset: \PYGZlt{}filename\PYGZgt{}.h5:\PYGZlt{}object\PYGZus{}path\PYGZgt{}
E.g. a valid definition may look like: \PYGZsq{}test\PYGZus{}brain\PYGZus{}convert.h5:/entry\PYGZus{}0/data\PYGZus{}0\PYGZsq{}
In rear cases we may need to manually define an array (e.g., a mask)
Here we can use standard python syntax, e.g, \PYGZsq{}[1,2,3,4]\PYGZsq{} or \PYGZsq{}[[1, 3], [4, 5]]\PYGZsq{}

This command\PYGZhy{}line tool has been auto\PYGZhy{}generated by BASTet (Berkeley Analysis \PYGZam{} Storage Toolkit)
\end{Verbatim}


\chapter{OMSI Data Format}
\label{HDF5_format:data-format}\label{HDF5_format::doc}\label{HDF5_format:omsi-data-format}
The following discusses the specification and use of OMSI mass spectrometry imaging data files.


\section{Data Layout}
\label{HDF5_format:data-layout}\label{HDF5_format:id1}\begin{figure}[htbp]
\centering
\capstart

\scalebox{1.000000}{\includegraphics{{HDF5_Layout}.png}}
\caption{Illustration of an example HDF5 file using the OpenMSI data format.}\label{HDF5_format:hdf5-figure}\end{figure}

\textbf{Experiment Information}
\begin{itemize}
\item {} 
\code{/entry\_\#} \emph{(HDF5 group)} : Each /entry\# groups stores data for a single imaging experiment. Data from multiple related experiments may be stored in different /entry\_\# groups within the same file. To link data from related experiments that are stored in separate HDF5 files, one could create a master-file in which the /entry\_\# are softlinks to the corresponding groups in the external HDF5 files
\begin{itemize}
\item {} 
\code{/entry\_\#/experiment\_identifier} \emph{(String dataset)} :  For each experiment a user-defined identifier name ---which should be unique--- is stored. This can be used to search for a particular experiment based on its name.

\end{itemize}

\textbf{MSI Data}
\begin{itemize}
\item {} 
\code{/entry\_\#/data\_\#} \emph{(HDF5 dataset)} : Multiple original images may be stored for each imaging experiment. The OMSI format manages the data associated with each dataset in a seperate group. For a standard MSI dataset this group contains the following datasets:
\begin{itemize}
\item {} 
\code{/entry\_\#/data\_\#/data\_\#} \emph{(3D dataset)} : Each data group may contain multiple copies of the same data. This is to allow for optimziations of the data layout for different selective read operations. This is important to enable fast data access to spectra and images via the web. By default the omsi format uses 3D arrays to store the spectral imaging data because:
\begin{itemize}
\item {} 
This allows the use of chunking in HDF5 to optimize data access for slicing operations in all dimensions. 1D and 2D layout allow for optimization only for a limited set of selection operations.

\item {} 
When using, e.g., a 1D data array to store the data, one would also need to store the resolution and order of the different dimensions to make sure that one can interpreted and read the data correctly.

\end{itemize}

\item {} 
\code{/entry\_\#/data\_\#/format} \emph{(String dataset)}  : Simple string dataset describing the internal layout type of the dataset. While the most common data layout is to store the data in a single 3D array, other data layouts are supported as well, e.g., to enable more efficient storage for sparse MSI datasets.

\item {} 
\code{/entry\_\#/data\_\#/mz} \emph{(1D dataset)} : The m/z values associated with the data.

\end{itemize}

\end{itemize}

\textbf{Instrument Information}
\begin{itemize}
\item {} 
\code{/entry\_\#/instrument} \emph{(HDF5 group)} : For each experiment a group with additional data about the instrument is stored. The example shown above defines a name for the instrument but we could define a larger list of optional instrument information that we would like to store here. The CXIDB format allows multiple instruments for each experiment. To assign data uniquely to an instrument the data is stored in the corresponding instrument group. However, to ease access to the data, CXIDB defines soft-links to the data in the /entry\_\# group for the experiment as well. Allowing multiple instruments for a single experiment makes the format very complicated and is unnecceasry in most cases. In the OMSI format defined here, one can still store data from related experiments in a single file, simply by creating separate \code{entry\_\# group}.
\begin{itemize}
\item {} 
\code{/entry\_\#/instrument/name} \emph{(String dataset)} : The name of instrument used

\item {} 
\code{/entry\_\#/instrument/mz} \emph{(1D dataset)} : The mz data of the instrument

\end{itemize}

\end{itemize}

\textbf{Sample Information}
\begin{itemize}
\item {} 
\code{/entry\_\#/sample} \emph{(HDF5 group)} : For each experiment a group with additional data about the sample used in the experiment is stored. The example shown below only defines a name for the sample but we could define a larger list of optional instrument information that we would like to store here. The proposed format here makes a similar simplification compared to the CXIDB format as in the case of the instrument. For each experiment ---represented by a \code{/entry\_\# group}--- only a single sample may by used. Data from related samples may be stored in the proposed format in separate \code{/entry\_\#} groups representing different experiments.
\begin{itemize}
\item {} 
\code{/entry\_\#/sample/name} \emph{(String dataset)} : Name of the sample imaged.

\end{itemize}

\end{itemize}

\textbf{Data Analysis Results}
\begin{itemize}
\item {} 
\code{/entry\_\#/analysis\_\#} \emph{(HDF5 group)} : Multiple derived analysis results may be stored in the proposed format in analysis\_\# groups associated with the experiment they were created from.  Similar to the experiment a user-defined analysis-identifier string should be given to each analysis to allow searches for analysis results by name. Which data needs to be stored for an analysis will depend on the analysis. The omsi python API specifies some base classes to ease integration of analysis algorithms with the API and the HDF5 data format. Further formalizations may be specified to ease support of specific types of analysis results ---e.g., clustering results--- via the OpenMSI web-interface.
\begin{itemize}
\item {} 
\code{/entry\_\#/analysis\_\#/analysis\_identifier} \emph{(String dataset)} :  For each analysis a user-defined identifier name ---which should be unique--- is stored. This can be used to search for a particular experiment based on its name.

\item {} 
\code{/entry\_\#/analysis\_\#/analysis\_type} \emph{(String dataset)} : String describing the type of analysis. This should be high-level category, e.g., peak\_finding\_local, peak\_finding\_global, clustering etc. We will define a set of these categories that should be used. Having high-level categories for different algorithms that store their data in the same fashion will help later on with analyzing and visualizing the results from different algorithms that essentially produce the same output.

\item {} 
\code{/entry\_\#/analysis\_\#/...} \emph{(Arbitrary HDF5 dataset)} : In the example shown in {\hyperref[HDF5_format:hdf5\string-figure]{\emph{Illustration of an example HDF5 file using the OpenMSI data format.}}} above, we have an example /entry\_0/analysis\_0/peakcube. The name for the output datasets from the analysis is currently not restricted. A set of name convention will however be defined by the omsi\_analysis associated with the indicated analysis\_type to ensure that the data can be handled gracefully. Otherwise, if an unkown analysis type is given then all datasets in the /entry\_\#/analysis\_\#/ group that are not part of the standard are assumed to be analysis datasets.

\item {} 
\code{/entry\_\#/analysis\_\#/parameter} \emph{(HDF5 Group)} : Group containing addional datasets with input parameters of the analysis
\begin{itemize}
\item {} 
\code{/entry\_\#/analysis\_\#/parameter/...} \emph{(Arbitrary HDF5 datasets)} : Datasets defining input parameters of the analysis

\end{itemize}

\item {} 
\code{/entry\_\#/analysis\_\#/dependency} \emph{(HDF5 Group)} : Group containing additional datasets specifying dependnecies of the analysis.

\code{/entry\_\#/analysis\_\#/dependency/...} \emph{(HDF5 Group)} : Each dependency is defined in a seperate group containting the following required datasets
\begin{itemize}
\item {} 
\code{/entry\_\#/analysis\_\#/dependency/.../main\_name} \emph{(String dataset)} : Path to the HDF5 object the analysis depends on.

\item {} 
\code{/entry\_\#/analysis\_\#/dependency/.../parameter\_name} \emph{(String dataset)} : Name of the analysis parameter that has the dependency.

\item {} 
\code{/entry\_\#/analysis\_\#/dependency/.../selection} \emph{(String dataset)} : Optional Numpy selection string, indicating the subset of the data used.

\end{itemize}

\end{itemize}

\end{itemize}

\end{itemize}

\textbf{Attributes}

HDF5 attributes are used by the OMSI file format only to store format related information but not to store any data. Currently the following attributes are associated with the different high level groups:
\begin{itemize}
\item {} 
\code{omsi\_type} \emph{(String)} : Attribute indicating the omsi\_file API object to be used to manage the given groupt. If the attribute is not present then the API decides which API object to use base  on the name conventions described above.

\item {} 
\code{version} \emph{(String)} : Attribute indicating the version of the API class that should be used to represent this group.

\end{itemize}


\section{Accessing OMSI data files}
\label{HDF5_format:using-hdf5}\label{HDF5_format:accessing-omsi-data-files}
The \code{omsi.dataformat.omsi\_file} module provides a convenient python-based API for reading and writing OMSI data files. The class also provides a convenient function for generating a XML-format XMDF header for the OMSI HDF5 file. Using the XDMF header file, the HDF5 data can be loaded in VisIt using VisIt's XDMF file reader. OMSI data files are valid HDF5 data files and can be accessed via the standard HDF5 libraries.
\begin{itemize}
\item {} 
\textbf{C/C++:}
\begin{itemize}
\item {} 
More information about HDF5 can be found here: \href{http://www.hdfgroup.org/HDF5/}{http://www.hdfgroup.org/HDF5/}

\end{itemize}

\item {} 
\textbf{Python:}
\begin{itemize}
\item {} 
H5Py is a python interface to the HDF5 library. More detailed information can be found here: \href{http://h5py.alfven.org/docs-2.0/}{http://h5py.alfven.org/docs-2.0/}

\end{itemize}

\item {} 
\textbf{MATLAB:}
\begin{itemize}
\item {} 
MATLAB provides both high-level and low-level access functions to HDF5. For more details see \href{http://www.mathworks.com/help/techdoc/ref/hdf5.html}{http://www.mathworks.com/help/techdoc/ref/hdf5.html}

\item {} 
Simple example usin the high-level API:

\begin{Verbatim}[commandchars=\\\{\}]
file=\PYGZsq{}\PYGZti{}/Data/Imaging/DoubleV.hdf5\PYGZsq{}
h5disp(file)
mz=h5read(file,\PYGZsq{}/entry\PYGZus{}0/instrument/mz\PYGZsq{});
[m mx]=min(abs(mz\PYGZhy{}746.22))
tic
y=h5read(file,\PYGZsq{}/entry\PYGZus{}0/data\PYGZus{}0\PYGZsq{},[mx 1 1],[1 250 160]);
toc
imagesc(squeeze(y))
axis equal
axis tight
\end{Verbatim}

\item {} 
Simple example using the low-level API:

\begin{Verbatim}[commandchars=\\\{\}]
file=\PYGZsq{}\PYGZti{}/Data/Imaging/DoubleV.hdf5\PYGZsq{}
plist = \PYGZsq{}H5P\PYGZus{}DEFAULT\PYGZsq{};
fid = H5F.open(file);
gid = H5G.open(fid,\PYGZsq{}/entry\PYGZus{}0\PYGZsq{});
dset\PYGZus{}id = H5D.open(fid,\PYGZsq{}/entry\PYGZus{}0/data\PYGZus{}0\PYGZsq{});
dims = [160 250 1];
offset = [0 0 mx]
block = dims;
mem\PYGZus{}space\PYGZus{}id = H5S.create\PYGZus{}simple(3,dims,[]);
file\PYGZus{}space\PYGZus{}id = H5D.get\PYGZus{}space(dset\PYGZus{}id);
H5S.select\PYGZus{}hyperslab(file\PYGZus{}space\PYGZus{}id,\PYGZsq{}H5S\PYGZus{}SELECT\PYGZus{}SET\PYGZsq{},offset,[],[],block);
tic
data = H5D.read(dset\PYGZus{}id,\PYGZsq{}H5ML\PYGZus{}DEFAULT\PYGZsq{},mem\PYGZus{}space\PYGZus{}id,file\PYGZus{}space\PYGZus{}id,plist);
toc
H5D.close(dset\PYGZus{}id);
H5F.close(fid);
data=squeeze(data);
imagesc(data)
axis equal
axis tight
\end{Verbatim}

\end{itemize}

\item {} 
\textbf{Using HDF5 at NERSC}
\begin{itemize}
\item {} 
Overview of python at NERSC: \href{http://www.nersc.gov/users/software/development-tools/python-tools/}{http://www.nersc.gov/users/software/development-tools/python-tools/}

\item {} 
HDF5 modules are installed on most machines at NERSC:

\begin{Verbatim}[commandchars=\\\{\}]
module load hdf5
module load python
python
\PYGZgt{}\PYGZgt{}\PYGZgt{} import h5py
\PYGZgt{}\PYGZgt{}\PYGZgt{} import numpy
\end{Verbatim}

\end{itemize}

\end{itemize}


\section{Convert Mass Spectrometry Imaging Data to OMSI (HDF5) format}
\label{HDF5_format:convert-mass-spectrometry-imaging-data-to-omsi-hdf5-format}\label{HDF5_format:convert-img-hdf5}
See section {\hyperref[convert_files:converting\string-files]{\emph{Converting and Files and Making them Accessible}}} for details.
\begin{itemize}
\item {} 
\code{omsi.tools.convertToOMSI} : This python script, which is available via the OMSI software toolkit, provides functionality for converting img files to HDF5. The script takes a single or multiple img files as input and writes them to a single HDF5 file. The data of each img file is stored in a separate \code{/entry\_\#/data\_\#} object. The script also supports execution of a number of different analysis, such as, peak finding or nmf, directly during the data conversion. For up-to-date information about the usage of the script see \code{python imgToHDF5 -{-}help}. A summary of the main command-line options of the tool are available below.

\item {} 
\code{omsi.dataformat.omsi\_file} : Module containing a set of python class for reading and writing HDF5 data files for the proposed OMSI HDF5 data layout.

\item {} 
\code{omsi.dataformat.img\_file} : Simple python class for reading img data files.

\item {} 
\code{omsi.dataformat.bruckerflex\_file} : Simple python class for reading bruckerflex files.

\end{itemize}


\chapter{HDF5 I/O Performance}
\label{HDF5_format_performance:hdf5-i-o-performance}\label{HDF5_format_performance::doc}
Analysis and visualization of mass spectrometry imaging (MSI) data is often based on selected subsets of the data, e.g., single or multiple spectra or m/z data slices. It is, therefore, crucial that we are able to quickly access select subsets of the data. In the context of web-based applications ---such as the OpenMSI Viewer--- this is particularly crucial in order to enable interactive data analysis and to provide a satisfactory user experience. The tests described here focus on characterizing and optimizing the performance of data access operations performed in serial on OMSI HDF5 files. While we here focus on the performance of serial data accesses, the optimizations described here are fundamental to optimizing parallel data access as well.

In the following, we first identify a select set of target compute platforms (Section {\hyperref[HDF5_format_performance:hdf5\string-test\string-platforms]{\emph{Test Platforms}}}) and define a set of representative use cases in order to evaluate the performance of different data layouts (Section {\hyperref[HDF5_format_performance:hdf5\string-test\string-cases]{\emph{Test Cases}}}). We then discuss the basic layout of the MSI data (Section {\hyperref[HDF5_format_performance:hdf5\string-test\string-data\string-layout]{\emph{Dataset Layout}}}) and establish the baseline performance using the default contiguous data layout (Section {\hyperref[HDF5_format_performance:hdf5\string-test\string-baseline]{\emph{Baseline Performance}}}). Afterwards, we  explore further optimization of the data layout using HDF5's data chunking (Section {\hyperref[HDF5_format_performance:hdf5\string-test\string-chunking]{\emph{Chunking: Part 1}}}) and data compression (Section {\hyperref[HDF5_format_performance:hdf5\string-test\string-compress]{\emph{Compression}}}) capabilities. We conclude this study with a discussion of lessons-learned in Section {\hyperref[HDF5_format_performance:hdf5\string-test\string-discussion]{\emph{Discussion}}}.


\section{Test Platforms}
\label{HDF5_format_performance:hdf5-test-platforms}\label{HDF5_format_performance:test-platforms}
All tests were performed on two main compute systems: i) login node of \code{hopper.nersc.gov} (short \code{hopper}) and ii) \code{portal-auth.nersc.gov} (short \code{portal}). On \code{hopper} we utilized the LUSTRE-based \code{/scratch} file system, as well as the global GPFS-based \code{/project} file system. On \code{portal} we can only access the \code{/project} file system. We chose these systems because: i) \code{hopper} is our candidate system for performing large-scale parallel analysis of MSI data and ii) \code{portal} is our target system for providing web-based access to MSI data.


\subsection{\texttt{hopper.nersc.gov}}
\label{HDF5_format_performance:hopper-nersc-gov}
The \code{hopper} system has 12 login nodes with 4 quad-core AMD 2.4 GHz Opteron 8378 processors (16  cores total) each on 8 of the login nodes and 4 8-core AMD 2.0 GHz Opteron 6128 processors (32 cores total) each on 4 of the login nodes. Each login node has 128 GB of memory. The login nodes are external to the main Cray XE6 system. All tests were performed using \code{hopper} login nodes.

\textbf{Scratch:} There are two Lustre file systems on \code{hopper} ---mounted as \code{/scratch} and \code{/scratch2} (in the following we use \code{/scratch2})--- with the following setup:
\begin{itemize}
\item {} 
13 LSI 7900 disk controllers (Each disk controller is served by 2 I/O Object Storage Servers (OSSs))

\item {} 
Each OSS host 6 OSTs (Object Storage Target) (simplified speaking a software abstraction of a physical disk)

\item {} 
Fiber Channel 8 connectivity from OSSs to the LSI disk controllers

\item {} 
Infiniband connects the Lustre router nodes in the 3d torus through a QDR switch to the OSSs

\item {} 
In total each \code{/scratch} file system has 156 OSTs which is the lowest layer with which users need to interact.  When a file is created in \code{/scratch} it is by default ``striped'' or split across two different OSTs. Striping is a technique to increase I/O performance.  Instead of writing to a single disk, striping to two disks allows the user to potentially double read and write bandwidth. In the following experiments we use the default stripping settings but depending on file size, larger stripe settings may be advantageous. Using the \code{/scratch} file system for temporary storage of MSI data files can be advantageous when performing complex I/O intensive analysis.

\end{itemize}

\textbf{Global} \code{/project} \textbf{:} This is a large (1606 TB), permanent, medium-performance GPFS-based file system. We utilized the \code{/project} file system in the context of the OpenMSI project for permanent storage of MSI data.


\subsection{\texttt{portal-auth.nersc.gov}}
\label{HDF5_format_performance:portal-auth-nersc-gov}
The \code{portal} system is used at NERSC for any data services that require public access from the Internet (such as Science Gateways) and as such also hosts the OpenMSI webpage and science gateway. The system consists of 2 quad-core AMD Opteron 2378 processors (8 cores total) with 24GB of memory. This system has only access to the \code{/project} file system.


\section{Test Cases}
\label{HDF5_format_performance:test-cases}\label{HDF5_format_performance:hdf5-test-cases}
In order to evaluate the performance of different data layouts, we designed a set of test-cases modeling the most common data access patterns in the analysis of MSI data. One particular focus of this study is to optimize the performance of the file format for web-based access to the data required for OpenMSI's online data viewing, analysis and exploration functionality. In this context it is most important that we are able to quickly access select subsets of the data, in particular, image slices, spectra or subcubes of the data. These type of data access patterns, however, are very common also for a large range of data analyses, e.g., peak finding on individual spectra, data clustering and many others. In contrast to analysis performed with direct access to the compute system, the abilities for data caching are typically much more limited in a web-based setting due to the fact that: i) http accesses are stateless, i.e., a file is typically reopend for each incoming request and closed again afterwards and ii) access patterns to the data are much more irregular with multiple users working with different datasets and/or different subsets of the data at the same time. While the median performance for repeated data selection operations on the same open file is often very important for data analysis, in a web-based setting the maximum time for the first access to the data is often much more important. In the following we report for each selection test case the median time (indicating the sustained performance on an open file) and the maximum time (indicating the selection performance after the first opening of the file). We usually repeat each selection test case 50 times for each data layout using randomized selection parameters.


\subsection{Case 1: m/z Slice Selection}
\label{HDF5_format_performance:case-1-m-z-slice-selection}
This test case models the selection of a series of z-slices of the data (i.e., slices in a mass range), and extracts a set of consecutive, full images of the data. This type of operation is required in the OpenMSI viewer when updating channels in the image viewer itself. It is also a common operation in many other analyses, e.g, when analyzing the distribution for a particular peak across the image.
\begin{itemize}
\item {} 
\textbf{Randomized Selection Parameters:} \code{zmin}

\item {} 
\textbf{Dependent Selection Parameters:} \code{zmax = zmin+25}

\item {} 
\textbf{Extracted Dataset:} \(100 \times 100 \times 25 = 250,000 \text{ records} = 500,000 \text{ bytes} = 0.5 \text{MB}\)

\end{itemize}


\subsection{Case 2: Spectra Selection}
\label{HDF5_format_performance:case-2-spectra-selection}
This test case models the selection of a \(5 \times 5\) set of full spectra. In the OpenMSI viewer, access to single and multiple neighboring spectra is required when updating the spectrum plot's. This is also a typical operation for many analyses that operate on a per spectrum basis, e.g., peak finding for a single spectrum.
\begin{itemize}
\item {} 
\textbf{Randomized Selection Parameters:} \code{xmin} , \code{ymin}

\item {} 
\textbf{Dependent Selection Parameters:} \code{xmax = xmin+5} , \code{ymax = ymin+5}

\item {} 
\textbf{Extracted Dataset:} \(5 \times 5 \times 100,000 = 200,000 \text{ records} = 2,500,000 \text{ bytes} = 5 \text{MB}\)

\end{itemize}


\subsection{Case 3: 3D Subcube Selection}
\label{HDF5_format_performance:case-3-3d-subcube-selection}
This selection models the general access to consecutive sub-pieces of the data, e.g., when accessing data from a particular spatial region of the data related to a particular set of m/z data values. This type of operation is required, e.g., when analyzing the data of a cluster of pixels with a particular set of peaks of interest.
\begin{itemize}
\item {} 
\textbf{Randomized Selection Parameters:} \code{xmin} , \code{ymin}, \code{zmin}

\item {} 
\textbf{Dependent Selection Parameters:} \code{xmax = xmin+5} , \code{ymax = ymin+5}, \code{zmax = zmin+1000}

\item {} 
\textbf{Extracted Dataset:} \(5 \times 5 \times 1,000 = 25,000 \text{ records} = 50,000 \text{ bytes} = 0.05 \text{ MB}\)

\end{itemize}


\subsection{Case 4: Data Write}
\label{HDF5_format_performance:case-4-data-write}
As described above, the aim of this study is to optimize the performance of selective data read operations (termed hyperslap selections in HDF5). In contrast to the data read, data write is a one-time cost during the file conversion step and is, therefore, less critical to the operation of OpenMSI. A reduced write performance may, therefore, be acceptable in lieu of an increase in read performance as long as an acceptable write performance is maintained. During selection performance tests, the data write is repeated only 3 times for each data layout (i.e.,once for each of the three selection test cases). For selected cases (indicated in the plot titles) we ran dedicated data write tests with 10 repeats. We here typically report the average times for data write.


\subsection{Case 5: File Size}
\label{HDF5_format_performance:case-5-file-size}
The size of data files is important to this study as different file layouts may have different space requirements (e.g., due to padding and additional metadata). While reduction of the size of data files is not the main objective of this work, it is important to avoid unnecessary overheads in file size and, hence, storage cost.  The size of files reported in this study have been determined using the Python command \code{os.stat( filename ).st\_size}.


\subsection{Test Data}
\label{HDF5_format_performance:test-data}
For this study we use a \(100 \times 100 \times 100,000\) test dataset. The dataset is stored as a 3D array of UInt (16bit) data values using the OMSI HDF5 format described in Chapter {\hyperref[HDF5_format:data\string-format]{\emph{OMSI Data Format}}} . Data write and hyperslap performance are independent of the data values being written/read, so to test the baseline write-performance, we simply assign to each data element the index of the corresponding data chunk. For test cases that utilize data compression, we use a donor MSI data file to fill the file with realistic data. We may replicate data from the donor file in case that the testfile is larger than the donor file. In case that a donor file is used, we read the donor data into memory prior to writing of the test dataset. For each test case (i.e., data layout + selection case) we generate a new test data file to reduce/eliminate effects of data caching. The newly generated file is then opened and the current selection (i.e., hyperslap selection) is repeated 50 times using randomized selection parameters.

Raw data files used in this study are:
\begin{itemize}
\item {} 
\textbf{Dataset A:}  (default donor file)
\begin{itemize}
\item {} 
\textbf{Name:} 11042008\_NIMS.h5

\item {} 
\textbf{Dimensions:} \(227 \times 108 \times 63,378\)

\item {} 
\textbf{Raw Data Size:} \(3.2 \text{GB}\)

\item {} 
\textbf{File Size:} \(3.3 \text{GB}\) (including results from global peak finding and nmf)

\end{itemize}

\item {} 
\textbf{Dataset B:}
\begin{itemize}
\item {} 
\textbf{Name:} 2012\_0403\_KBL\_platename.h5 (DoubleV)

\item {} 
\textbf{Dimensions:} \(160 \times 250\times 116,152\)

\item {} 
\textbf{Raw Data Size:} \(9.3 \text{GB}\)

\item {} 
\textbf{File Size:} \(9.5 \text{GB}\) (including results from global peak finding and nmf)

\end{itemize}

\end{itemize}


\section{Dataset Layout}
\label{HDF5_format_performance:dataset-layout}\label{HDF5_format_performance:hdf5-test-data-layout}
A single (2D) MSI dataset defines a 3D data volume with the spatial coordinates \(x\), \(y\) and the \(m/z\) (mass) as third dimension (\(z\)). In raw block-of-uint format (e.g, in the IMG format) the data is often stored in a 1D linearized fashion: \({spectrum_{0,0}, \ spectrum_{0,1}, \ ... \ , \ spectrum_{l,m} }\). While such a layout is well-suited for accessing single full spectra, access to single image z-slices requires \(l*m\) seek operations and traversal of the complete dataset (with l, m being the number of pixel in x,y ,respectively). Selection of spectra and z-slices of the data are orthogonal selection operations, i.e., a 1D data layout can always just optimize one of the two access operations but not both. Similarly, a 2D data layout can be defined to enable easy access to full spectra as well as full z-slices, but does not easily support to optimize access to 3D subsets of the data. We, therefore, store MSI data as a 3D array in HDF5 to: i) be be able to optimize and find a good performance compromise for selection of spectra, z-slices as well as 3D subcubes of the data and ii) because the 3D array reflects the true dimensionally of the data.

HDF5 can represent array datasets with as many as 32 dimensions. However, in the file the data is linearized in order to store it as part of the 1-dimensional stream of data that is the low-level file. The data layout determines in which way the multidimensional dataset is mapped to the serial file. The simplest way to accomplish this is to flatten the dataset (similar to how arrays are stored in memory) and to store the entire dataset into a monolithic block on disk. We here use this, so-called, contiguous layout as baseline for our performance tests (see Section {\hyperref[HDF5_format_performance:hdf5\string-test\string-baseline]{\emph{Baseline Performance}}}).

Chunking provides an alternative to the contiguous layout. In contrast to storing the data in a single block in the HDF5 file, using chunking the data is split into multiple chunks. Each chunk of a dataset is allocated separately and stored at independent locations throughout the HDF5 file. The chunks of a dataset can then be read/written independently, enabling independent parallel I/O and potentially improving performance when operating on a subset of the dataset. Data chunks may be stored in arbitrary order and position within the HDF5 file. HDF5 uses a B-tree to map a chunks N-dimensional address to a physical file addresses. The size of the B-tree directly depends on the number of chunks allocated for a dataset. The more chunks are allocated for a dataset:  i) the larger overhead for traversal of the B-tree, ii) the higher the potential contention for the metadata cache, and iii) the larger the number of I/O operations. An introduction to data chunking in HDF5 is provided at \href{http://www.hdfgroup.org/HDF5/doc/Advanced/Chunking/}{http://www.hdfgroup.org/HDF5/doc/Advanced/Chunking/} . The performance of different chunking strategies for storing MSI data is evaluated in Section {\hyperref[HDF5_format_performance:hdf5\string-test\string-chunking]{\emph{Chunking: Part 1}}}.

Use of chunking also enables the use of HDF5 I/O filters. We here investigate the use of compression filters. I/O filters are applied in HDF5 to each chunk individually, and entire chunks are processed at once. I/O filters enabled for a dataset are executed every time a chunk is loaded or flushed to disk. Choosing proper settings for the chunking (and chunk cache) are, therefore, critical for the performance of filtered datasets. The potential use of \code{gzip} compression for improving file size and hyperslap selection of MSI datasets is evaluated in Section {\hyperref[HDF5_format_performance:hdf5\string-test\string-compress]{\emph{Compression}}}.

Chunking and HDF5 I/O filters (e.g., data compression) are implemented transparently in HDF5, i.e, the API functions for reading/writing chunked/compressed datasets are the same ones used to read/write datasets with a uncompressed, contiguous layout. The layout (i.e., chunking scheme and compression options) is defined via a single function call to set up the layout on a property list before the dataset is created.


\subsection{Baseline Performance}
\label{HDF5_format_performance:hdf5-test-baseline}\label{HDF5_format_performance:baseline-performance}
The goal of this section is to establish a baseline for the performance of the basic HDF5 contiguous data layout (i.e., without chunking). The baseline performance for the three selection test cases are shown in Figures i) {\hyperref[HDF5_format_performance:hdf5baselineslice\string-figure]{\emph{Baseline performance for the slice selection test case}}}, ii) {\hyperref[HDF5_format_performance:hdf5baselinespectra\string-figure]{\emph{Baseline performance for the spectra selection test case}}}, and iii) {\hyperref[HDF5_format_performance:hdf5baselinesubcube\string-figure]{\emph{Baseline performance for the subcube selection test}}}. The bar plots show the minimum (blue), median (blue+red), average (blue+red+green), and maximum (blue+red+green+lilac) times for retrieving the selected data. We observe that \code{hopper} using \code{/scratch} provides much better performance for selection of spectra and 3D subcubes of the data. For the z-slice selection we observe that \code{hopper} achieves good median and average selection performance, whereas the performance of the z-slice selection on \code{portal} is generally poor. In all cases, we observe poor worst-case (maximum) times for the z-slice selection case.

For serial data write performance we observe that \code{/project} provides better write performance. However, for parallel write operations, the LUSTRE-based \code{/scratch} file system is expected to outperform \code{/project}.
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Baseline_SliceQuery}.pdf}}
\caption{Baseline performance for the slice selection test case}\label{HDF5_format_performance:hdf5baselineslice-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Baseline_SpectraQuery}.pdf}}
\caption{Baseline performance for the spectra selection test case}\label{HDF5_format_performance:hdf5baselinespectra-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Baseline_SubcubeQuery}.pdf}}
\caption{Baseline performance for the subcube selection test}\label{HDF5_format_performance:hdf5baselinesubcube-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Baseline_Write}.pdf}}
\caption{Baseline performance for data write}\label{HDF5_format_performance:hdf5baselinewrite-figure}\end{figure}


\section{Chunking: Part 1}
\label{HDF5_format_performance:chunking-part-1}\label{HDF5_format_performance:hdf5-test-chunking}
Use of a chunked data layout has many potential advantages. In particular, use of chunking enables independent data I/O operations on individual chunks of the data so that chunking: i) can reduce the amount of data that needs to be read during hyperslab selections, ii) enables parallel independent I/O on a single file, and iii) enables the use of data compression (discussed later in Section {\hyperref[HDF5_format_performance:hdf5\string-test\string-compress]{\emph{Compression}}}). The goal of this section is to evaluate the use of chunking to improve I/O performance. Due to the amount of additional metadata and overhead associated with finding chunks, one should avoid the use of too small chunks. At the same time, use of too large chunks should be avoided, because the entire chunk must be read from disk (and decompressed) before performing any operations. When operating on small subsets of the data (and if the cache is too small to hold the chunk), the use of too large chunks can result in large performance penalties. In addition, if the chunk is too large to be held in memory, the operating system may have to page memory to disk, slowing down the entire system. \footnote[1]{
See also \href{http://www.hdfgroup.org/HDF5/doc/Advanced/Chunking/}{http://www.hdfgroup.org/HDF5/doc/Advanced/Chunking/}
}

Choosing a good chunking strategy for MSI data is complicated because: i) the data has a very unconventional shape, with the m/z dimension being three to four orders of magnitude larger than the spatial x/y dimensions and ii) orthogonal data access operations (access to spectra vs. z-slices) are required with good first-time-access performance.

To account for these properties we use odd chunk sizes of \(m \times m \times n\) with \(n >> m\). Finding a good compromise for choosing a good chunking is challenging. Larger chunk sizes \(m\) in x, y are expected to improve z-slice selections but also increase the overhead for spectra selections. Similarly, large chunk sizes \(n\) in z (m/z) are expected to improve spectra selections while increasing the overhead for z-slice selections. The goal of this first set of experiments is to find a chunking that provides a good compromise in performance for all three selection test cases.

In the following we compare the performance of a range of different chunking strategies of the form \(m \times m \times n\) with \(m \in \{1, 2, 4, 8 ,16, 32\}\) and \(n \in \{128, 256, 512, 1024, 2048, 4096, 8192\}\) using \code{hopper} using \code{/scratch}. We first evaluate the effects of the different data layouts on file size (Section {\hyperref[HDF5_format_performance:hdf5\string-test\string-chunking\string-filesize]{\emph{File Size}}}) and write performance (Section {\hyperref[HDF5_format_performance:hdf5\string-test\string-chunking\string-write]{\emph{Data Write}}}). We then compare the performance for performing the three selection test cases (Section {\hyperref[HDF5_format_performance:hdf5\string-test\string-chunking\string-select]{\emph{Selection Performance}}}). We conclude this chunked layout study with an evaluation of the overall performance of the different chunked data layouts to identify the best-performing data layouts (Section {\hyperref[HDF5_format_performance:hdf5\string-test\string-chunking\string-select]{\emph{Selection Performance}}})


\subsection{File Size}
\label{HDF5_format_performance:file-size}\label{HDF5_format_performance:hdf5-test-chunking-filesize}
The use of chunking effects the size of data files in two main ways. First, storing the additional metadata required for chunking ---such as the B-tree used for indexing of data chunks--- increases file size. Second, the use of chunking may result in allocation of additional empty data (padding) in case that the chunks do not align with the data. This can result in substantial data overheads. A simple example illustrates this problem. When storing a simple 1D dataset with 101 elements using a chunk size of 100, then we need to allocated two chunks, one chunk to store the first 100 elements and a second chunk to store the last element. In this case we allocated space for 200 elements in order to store 101 elements, nearly twice the amount of storage needed for the raw data. For multi-dimensional data arrays --here 3D-- the storage overheads due to padding can increase even faster. It is, therefore, important that we consider the potential storage overhead when evaluating the use of data chunking.
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Chunking_Filesizes}.pdf}}
\caption{File sizes using different chunking strategies}\label{HDF5_format_performance:hdf5filesize-figure}\end{figure}

Figure {\hyperref[HDF5_format_performance:hdf5filesize\string-figure]{\emph{File sizes using different chunking strategies}}} illustrates the effects of chunking on the size of data files. The baseline curve indicates the file size using a contiguous data layout. We observe that the file with a chunking of \(1 \times 1 \times 128\) is much larger than the other files with a \(1 \times 1 \times n\) chunked layout. No padding is applied in the spatial dimensions \(x\), \(y\). When using a \(z\) chunk size of 128, 782 chunks are required per spectrum, resulting in a total of 7,820,000 chunks. Due to padding in the \(z\) dimension, 96 \(100 \times 100\) slices remain empty. However, this accounts for only \(100*100*96*2 \text{Bytes} = 1,920,000 \text{Bytes} = 1.92 \text{MB}\). In comparison, the \(1 \times 1 \times 2048\) dataset is much smaller while requiring a much larger \(z\) padding of 352 slices (i.e, \(\approx 7.04 \text{MB}\)). The reason for the larger file size for the \(1 \times 1 \times 128\) chunking illustrates the large overhead for storing the metadata required for the large number of chunks.

We also observe that the file size increases significantly when using chunk sizes in x, y of \(8 \times 8 \times n\) or larger. This behavior is due to the padding required in the spatial dimensions. For example, when using a chunking of \(32 \times 32 \times n\) we requires 4 chunks in the \(x\) and \(y\) dimension (i.e., \(4*32=128\) elements). This means, in order to store the \(100 \times 100 \times 100,000\) test dataset, we allocate space for at least \(128 \times 128 \times 100,000\) records (additional padding may be required in the \(z\) dimension). This means that we allocate at least an additional amount of space of \((28*128*100,000) + (28*100*100,000) \text{ records} = 638,400,000 * 2 \text{ Bytes} = 1,276,800,000 \text{ Bytes} =  1276.8 \text{ MB}\). This example illustrates that a bad choice for the chunking can result in substantially larger data files. Since in the case of MSI  data, the \(x\), \(y\) dimensions of the data are much smaller than the \(z\) (\(mz\), mass) dimension, it is important that we keep the padding required in \(x\) and \(y\) as small as possible, whereas padding in the \(z\) dimension typically has a much smaller effect on the size of the data.


\subsection{Data Write}
\label{HDF5_format_performance:hdf5-test-chunking-write}\label{HDF5_format_performance:data-write}
Traditionally, MSI data is often written one-spectrum-at-a-time. Figure {\hyperref[HDF5_format_performance:hdf5write1\string-figure]{\emph{Write performance using one-spectrum-at-a-time I/O using different chunk sizes (hopper using /scratch)}}} illustrates the write performance for the different data layouts using a one-spectrum-at-a-time write strategy. It is not surprising that we observes a significant decrease in performance with increasing chunk sizes \(m\) in the x and y dimensions, as each data chunk is modified \(m*m\) times. For chunkings of \(m \times m \times 32\) with \(m \in \{1024, 2048, 4096, 8192\}\) the write performance improves possibly due to higher HDF5 chunk-cache hit rates. The write performance data points for data layouts with a chunking of \(128 \times 128 \times 32\) , \(256 \times 256 \times 32\) , and \(512 \times 512 \times 32\) are missing as we terminated the tests due to the very poor one-spectrum-at-a-time write performance in those cases.
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.750000}{\includegraphics{{HDF5_Write_Hopper_Scratch_OneAtATime}.pdf}}
\caption{Write performance using one-spectrum-at-a-time I/O using different chunk sizes (\code{hopper} using \code{/scratch})}\label{HDF5_format_performance:hdf5write1-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.650000}{\includegraphics{{HDF5_Write_Hopper_Project_Compare}.pdf}}
\caption{Write performance using different data write strategies and chunk sizes (\code{hopper} using \code{/project})}\label{HDF5_format_performance:hdf5write2-figure}\end{figure}

To achieve optimal data write performance, it is important that we reduce the number of times each chunk is modified. Figure {\hyperref[HDF5_format_performance:hdf5write2\string-figure]{\emph{Write performance using different data write strategies and chunk sizes (hopper using /project)}}} compares the write performance for \(m \times m \times 2048\) chunked data layout using a one-spectrum-at-a-time, \(m \times m\)-spectra-at-a-time, and chunk-at-a-time data write strategy. Using the latter two strategies ensures that each chunk is modified only once. We observe that the chunk-at-a-time write strategy quickly outperforms the other write strategies as the chunk size increases (and the total number of chunks decreases). It is not surprising that the contiguous baseline layout outperforms the chunked layouts in a serial setting. However, the chunked layouts efficiently support parallel data write operations. Using a chunk-at-a-time write strategy, independent parallel tasks can be utilized to write the different chunks.


\subsection{Selection Performance}
\label{HDF5_format_performance:hdf5-test-chunking-select}\label{HDF5_format_performance:selection-performance}
In this section we evaluate the selection performance of the different chunked data layouts for the three selection test cases: i) selection of a random set of 25 consecutive z-slices, ii) selection of a random \(5 \times 5\) set of full spectra, and iii) selection of a random \(5 \times 5 \times 1000\) subcube of the data. Figure {\hyperref[HDF5_format_performance:hdf5\string-chunking\string-slice\string-figure]{\emph{Performance results for z-slice selection using varying chunk sizes (hopper using /scratch)}}} \footnote[2]{
Bars shown transparently indicate that the bars exceed the maximum value shown in the plot. The real value for those bars are indicated via additional text labels.
}  shows the results for the z-slice hyperslap selection. We observe that data layouts with a chunking of \(m \times m \times n\) with \(m \in \{4, 8 ,16\}\) and \(n \in \{128, 256, 512, 1024, 2048, 4096\}\) show the best z-slice selection performance. For the mentioned chunking strategies we observe in general best performance for larger values in \(m\) and smaller values of \(n\). This behavior is likely due to the reduced amount of data and number of chunks that need to be loaded to fulfill the selection of complete slices in \(z\).
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Performance_Chunking_Hopper_SliceQuery}.pdf}}
\caption{Performance results for z-slice selection using varying chunk sizes (\code{hopper} using \code{/scratch})}\label{HDF5_format_performance:hdf5-chunking-slice-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Performance_Chunking_Hopper_SpectraQuery}.pdf}}
\caption{Performance results for spectra selection using varying chunk sizes (\code{hopper} using \code{/scratch})}\label{HDF5_format_performance:hdf5-chunking-spectra-figure}\end{figure}

For the spectra selections (see Figure {\hyperref[HDF5_format_performance:hdf5\string-chunking\string-spectra\string-figure]{\emph{Performance results for spectra selection using varying chunk sizes (hopper using /scratch)}}}) we observe in most cases a decrease in the median performance compared to the baseline contiguous data layout. This behavior is likely due to the fact that the data is flattened in a z-column order in the contiguous layout, so that a full spectrum can be read via a single seek and contiguous read operation. In contrast, using a chunked data layout requires for the test dataset, loading \(100,000 / n\) chunks. However, we observe that data layouts with a chunk size in z of 1024 and larger, still provide good performance for the selection of full spectra. In this case, small chunk sizes in x, y of 2 or 4, work well for the test case of loading a \(5 \times 5\) set of spectra, as the number of chunks that need to be loaded remains constant. For data layouts with a x,y chunking of \(8 \times 8\), the \(5 \times 5\) spectra selection can fit into a single x,y chunk, however, it is still likely that the \(5 \times 5\) selection crosses multiple chunk boarders, requiring the load of a large number of chunks. For x, y chunk sizes of 16 or 32, the \(5 \times 5\) spectra selection is more likely to fit in a single chunk in x,y, explaining the better performance of those data layouts.
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Performance_Chunking_Hopper_SubcubeQuery}.pdf}}
\caption{Performance results for 3D subcube selection using varying chunk sizes (\code{hopper} using \code{/scratch})}\label{HDF5_format_performance:hdf5-chunking-subcube-figure}\end{figure}

Figure {\hyperref[HDF5_format_performance:hdf5\string-chunking\string-subcube\string-figure]{\emph{Performance results for 3D subcube selection using varying chunk sizes (hopper using /scratch)}}} \footnotemark[2] summarizes the results for the selection of a \(5 \times 5 \times 1000\) data subcube. We observe that using chunking generally improves the performance of the selection. In particular, using chunking decreases the time for initial data access compared to the baseline contiguous data layout.

When comparing the selection performance plots, we observe that --- even though the amount of data that is retrieved is only 0.5MB in z-slice selection case compared to 5MB in the spectra selection case--- the performance for z-slice selection case is generally lower than for the spectra selection case. The reason for this behavior is that while the z-slice selection returns less data, the number of I/O (seek) operations required and the amount of data that needs to be loaded to fulfill the selection is larger. E.g, using a chunking of \(4 \times 4 \times 2048\) each chunk requires \(4*4*2048*2 \text{Byte} = 65536 \text{Byte} = 64 \text{kB}\). To retrieve a \(5 \times 5\) set of spectra, HDF5 needs to load \(2*2*49 \text{ Chunks} = 196*64 \text{ kB} = 12.25 \text{ MB}\), whereas in order retrieve 25 z-slices (without crossing a z-chunk boundary),  HDF5 needs to load \(25*25 \text{ Chunks} = 625 \text{ Chunks} =  39.0625 \text{ MB}\), i.e, more than three times the data (and that even though the \(4 \times 4\) x,y chunking does not align well with the \(5 \times 5\) spectra selection). Similary, in the contiguous data layout, we can load a single spectrum using a single seek and contiguous read operation, whereas in order to load complete a z-slice we requires \(m*m\) (\(=100*100=10,000\) for the test data) seek and load operations.


\subsection{Summary}
\label{HDF5_format_performance:hdf5-test-chunking-summary}\label{HDF5_format_performance:summary}
To illustrate the overall performance of the different dataset layouts and to identify the ``best'' layouts, we define the following set of minimum performance criteria a data layout should fulfill:
\begin{itemize}
\item {} 
The median time for the z-slice selection test case should be \code{\textless{}0.1 s}

\item {} 
The median time for the spectra selection test case should be \code{\textless{}0.05 s}

\item {} 
The median time for the 3D subcube selection test case should be  \code{\textless{}0.002 s}

\item {} 
The total file size should be \code{\textless{} 2100 MB} (limiting the overhead in the test case to a maximum of \(\approx 200 \text{MB}\))

\item {} 
(We do not take the write performance results shown in Figure {\hyperref[HDF5_format_performance:hdf5write1\string-figure]{\emph{Write performance using one-spectrum-at-a-time I/O using different chunk sizes (hopper using /scratch)}}} into account in the total score here as a chunk-at-a-time write strategy likely improve the write performance significantly)

\end{itemize}

Based on these criteria we can determine an overall performance score by evaluating how many of the criteria a particular data layout fulfills (with 4=best (passes all criteria) and 0=worst (does not pass any of the criteria)). We observe a cluster of 8 data layouts that satisfy the four performance conditions.
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Performance_Chunking_Hopper_PerfScore}.pdf}}
\caption{Summary performance score using various different chunk sizes (\code{hopper} using \code{/scratch})}\label{HDF5_format_performance:hdf5-chunking-perfscore-figure}\end{figure}

Figure {\hyperref[HDF5_format_performance:hdf5\string-chunking\string-perfscore\string-figure]{\emph{Summary performance score using various different chunk sizes (hopper using /scratch)}}} summarizes the performance scores for the different data layouts. Bars with the maximum score of 4 are plotted opaque whereas all other bars are plotted transparently. We observe a cluster of 8 layouts with a performance score of 4. While the overall performance score used here is simple in nature, it illustrates well which data layouts achieve overall the best performance. Overall, the performance experiments indicate that the largest z chunk size for which we observe good performance in our experiments across a large range of x/y chunk sizes is 2048. We, therefore, chose a z chunk size of 2048 for further experiments.

So far our experiments have focused on \code{hopper} using the \code{/scratch} file system. In order to evaluate the performance of the permanent data storage system \code{/project} and the web-hosting system \code{portal} we performed a series of follow-up tests using a fixed z-chunking of 2048 on \code{portal} as well as on \code{hopper} using \code{/project} (more details are provided in the next section). We generally observed that the \code{/project} file system provided better serial write performance while the overall performance for selection was not as good as for \code{/scratch. While the performance of {}`{}`hopper} using \code{/project} was still acceptable, the performance (and in particular the worst-case maximum times) were poor using \code{/portal} (see, e.g, Figure {\hyperref[HDF5_format_performance:hdf5compslice\string-figure]{\emph{Performance results for z-slice selection (portal using compression)}}} shown later). We, therefore, next extended our evaluation to also include data compression as an option to possibly improve data I/O performance and storage requirements.


\section{Chunking: Part 2}
\label{HDF5_format_performance:hdf5-test-chunking-part2}\label{HDF5_format_performance:chunking-part-2}
In part 1 of the chunking study we were interesting in finding chunked data layouts that provide a good compromise for all three selection use-cases. In part 2 we focus on chunked data layouts that are designed to optimize single selection operations.


\subsection{Image-aligned Chunking}
\label{HDF5_format_performance:image-aligned-chunking}
Figure {\hyperref[HDF5_format_performance:hdf5\string-imagealigned\string-cunking\string-figure]{\emph{Comparison of the performance of the default chunking with a chunked layout that is better-aligned with the ion-images to improve the performance the z-slice selection.}}} shows the performance of the z-slice selection in the OpenMSI client when optimizing the chunked data layout to align with the selection of m/z images. Using an image-aligned chunking of \(50 \times 80 \times 100\), only 10 chunks containing 100 image slice need to be read in order to retrieve a single image slice, wheras, using the default chunking of \(4 \times 4 \times 2048\), HDF5 needs to load 2,520 chunks containing 2048 image slices. The figure shows the performance we achieve in the OpenMSI client using the same data stored without compression using the two different chunked layouts. Using the default chunking it takes \(\approx 20s\) to compute the ion-images compared to just \(\approx 0.5s\) using the image-aligned chunking. However, not surprisingly, the performance of the orthogonal operation of selecting full spectra decreases significantly (here from 45ms to 8.1s) when optimizing the chunking to improve the selection of z-slices.

Further improvement in performance could be achieved by using a (m/z, x ,y) or (m/z, y, x) layout of the data rather than the commen (x, y, m/z). By transposing the image cube (making m/z the first dimension of the 3D cube) the data will be linearized on disk as \({ionimage_{0}. \ ionimage_{1}, \ ... \ , \ ionimage_{n}}\) rather than \({spectrum_{0,0}, \ spectrum_{0,1}, \ ... \ , \ spectrum_{l,m} }\). Linearizing the data in image order improves locality of data and reduces the number of seek operations required when loading ion-image. Currently, reordering of data dimensions is not yet supported by HDF5 as a transparent data layout optimization, but rather needs to be performed manually by the user. To remain ease of usability of the OpenMSI file format we, therefore, chose to use a consistent ordering of dimensions in all cases.
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{ImageAligned_Chunking_Example}.pdf}}
\caption{Comparison of the performance of the default chunking with a chunked layout that is better-aligned with the ion-images to improve the performance the z-slice selection.}\label{HDF5_format_performance:hdf5-imagealigned-cunking-figure}\end{figure}


\section{Compression}
\label{HDF5_format_performance:hdf5-test-compress}\label{HDF5_format_performance:compression}
The primary goal of data compression is to reduce the size of data by providing a more compact encoding of the data. In many cases, compression is used as means to reduce the size of data stored on disk. However, while additional compute time overheads are incurred due to the time required for compression/decompression of the data during write/read, compression may also improve the read and/or write performance, as less data needs to be transferred and/or written to disk. This is in particular the case in I/O bound systems (e.g., due to network bottlenecks etc.).

Use of data compression in HDF5 relies on the use of chunking and, hence, shares the same overheads and advantages and disadvantages. Compression is applied to each chunk of the data. The overall compression ratio achieved, therefore, inherently relies on the use of a good chunking strategy. Data compression is implemented via I/O filters in HDF5, which are applied transparently during data read and write operations, i.e., after enabling compression when generating the dataset, data read/write operations are performed using the same API calls whether the data is stored in raw or compressed form.

\code{HDF5/h5py} typically provides three main compression algorithms: i) \code{gzip}, standard \code{HDF5} deflate compression available with most HDF5 installations, ii) \code{szip}, third-party compression algorithm optionally available with HDF5 (i.e., it may not be available on all systems), iii) \code{LZF} is a stand-alone compression filter for HDF5 available via \code{h5py} but may not be available in many other standard (non-Python) installations of HDF5. In the context of OpenMSI it is important that we are able to transfer and use data at different institutes, compute systems and using a larger range of API's for accessing HDF5 data (e.g., matlab, HDF5 C API, h5py etc.). We, therefore, chose the standard \code{gzip} compression filter as it is typically available with most systems (in contrast to \code{LZF} and \code{szip}). The \code{gzip} filter provides and additional \code{aggression} parameter. The \code{aggression} parameter is a number between \([0,9]\) to indicate the trade-off between speed and compression ratio (zero is fastest, nine is best ratio). Unless indicated otherwise, we here generally set the \code{aggression} parameter to \(4\) for all tests to achieve a balance of compression ratio and speed.


\subsection{Compression Ratio}
\label{HDF5_format_performance:compression-ratio}
Using a chunking of \(4 \times 4 \times 2,048\), we achieve for dataset \(A\) a compression ratio of \(\approx 2.9\), reducing the data from 3.3GB (including \(\approx 100\) MB of data for nmf and global peak-finding) to 1.2GB (while only the MSI data is stored in compressed form). Using the same setup, we achieve for dataset \(B\) a compression ratio of \(\approx 6.3\), reducing the dataset from 9.5GB to 1.5GB (again with nmf and global peak-finding results included in the file and stored uncompressed in both cases). An overview of the file sizes using compression and compression ratios achieved using the \(100 \times 100 \times 100,000\) test dataset (using dataset \emph{A} as donor MSI dataset) are summarized in Figure  {\hyperref[HDF5_format_performance:hdf5compratio\string-figure]{\emph{Compression ratios using different chunk sizes}}}. The compression ratios we achieve are on the order of 2.9 to 3.8 in all cases (comparable to the compression ratio we have seen for the donor dataset \(A\)).
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.690000}{\includegraphics{{HDF5_Performance_Compression_Ratio}.pdf}}
\caption{Compression ratios using different chunk sizes}\label{HDF5_format_performance:hdf5compratio-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.650000}{\includegraphics{{HDF5_Compression_Dataset_Summary}.pdf}}
\caption{Compression performance on a select set of real MSI datasets.}\label{HDF5_format_performance:hdf5comprealdata-figure}\end{figure}


\subsection{Data Write}
\label{HDF5_format_performance:id4}
Figure {\hyperref[HDF5_format_performance:hdf5compwrite\string-figure]{\emph{Serial write performance using compression}}} compares the write performance results with and without using compression for data layouts with a chunking of \(m \times m \times 2048\) with \(m \in [1 , 10]\). As expected, we observe a general decrease in the write performance when using compression. As mentioned earlier, when using compression it is important that we use a chunk-aligned data write strategy as the compression filter needs to be executed each time a chunk is loaded and/or modified. We, therefore, use the chunk-at-a-time write strategy when writing HDF5 datasets with compression enabled.
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Performance_Compression_Write}.pdf}}
\caption{Serial write performance using compression}\label{HDF5_format_performance:hdf5compwrite-figure}\end{figure}


\subsection{Selection Performance}
\label{HDF5_format_performance:id5}
In this section we evaluate the selection performance of the different \(m \times m \times 2048\) chunked data layouts (with \(m \in [1 , 10]\)) for \code{portal} and \code{hopper} using \code{/project} and \code{/scratch}. For \code{portal} we observe that using compression can significantly improve the median selection time for the z-slice selection test case (see Figure {\hyperref[HDF5_format_performance:hdf5compslice\string-figure]{\emph{Performance results for z-slice selection (portal using compression)}}}). In particular, using compression significantly reduces and stabilizes the worst-case maximum time for selecting z-slices of the data \footnote[3]{
\textbf{Author comment:} Depending on when the test were run we have seen significant (approximately 1 order of magnitude) differences in the median selection times on \code{portal}, however, the maximum  appeared to not improve between different reruns of the experiments. Using compression, the results on \code{portal} have been much more stable and, in particular, the maximum times were much better. This indicates that: i) system load, on a highly utilized system like \code{portal}, has a significant impact on the performance and ii) compression can significantly improve performance the selection performance on I/O bound systems and stabilized the performance results.
} . This is especially important in the context of a web-based application, such as, OpenMSI's online data viewer. For the other two selection test cases we observe that we can achieve similar performance for the spectra and 3D subcube selection test cases on \code{portal} with and without compression (see Figures {\hyperref[HDF5_format_performance:hdf5compspectra\string-figure]{\emph{Performance results for spectra selection (portal using compression)}}}  and {\hyperref[HDF5_format_performance:hdf5compsubcube\string-figure]{\emph{Performance results for 3D subcube selection (portal using compression)}}})

The selection performance results for \code{hopper} using \code{/project} and \code{/scratch} and with and without using compression are shown in Figures: i) {\hyperref[HDF5_format_performance:hdf5comphopperslice\string-figure]{\emph{Performance results for z-slice selection (hopper using compression)}}} , ii) {\hyperref[HDF5_format_performance:hdf5comphopperspectra\string-figure]{\emph{Performance results for spectra selection (hopper using compression)}}}, and {\hyperref[HDF5_format_performance:hdf5comphoppersubcube\string-figure]{\emph{Performance results for subcube selection (hopper using compression)}}}. As baseline we use the performance of the contiguous data layout on \code{hopper} using \code{/project}. In contrast to \code{portal}, we observe on \code{hopper} a general decrease (of up to 1 order of magnitude) in the selection performance when using compression compared to when storing the data in raw, uncompressed form. Compared to the baseline contiguous data layout we, however, still observe an improvement in many cases even when using compression. Generally it appears that the use of compression may have stronger negative effect on the selection performance when operating on the \code{/scratch} filesystem then when using \code{/project} \footnote[4]{
\textbf{Author comment:} Note, \code{/scratch} is a parallel, LUSTRE-based file system, whereas \code{/project} is based on GPFS. Also \code{hopper} may have a higher bandwidth connection to the \code{/scratch} file system than \code{/project}. Overall, accesses to \code{/project} is likely to be more I/O bound than access to \code{/scratch}.
}.
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Performance_Compression_SliceQuery}.pdf}}
\caption{Performance results for z-slice selection (\code{portal} using compression)}\label{HDF5_format_performance:hdf5compslice-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Performance_Compression_SpectraQuery}.pdf}}
\caption{Performance results for spectra selection (\code{portal} using compression)}\label{HDF5_format_performance:hdf5compspectra-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Performance_Compression_SubcubeQuery}.pdf}}
\caption{Performance results for 3D subcube selection (\code{portal} using compression)}\label{HDF5_format_performance:hdf5compsubcube-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Performance_Compression_hopper_SliceQuery}.pdf}}
\caption{Performance results for z-slice selection (\code{hopper} using compression)}\label{HDF5_format_performance:hdf5comphopperslice-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Performance_Compression_hopper_SpectraQuery}.pdf}}
\caption{Performance results for spectra selection (\code{hopper} using compression)}\label{HDF5_format_performance:hdf5comphopperspectra-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Performance_Compression_hopper_SubcubeQuery}.pdf}}
\caption{Performance results for subcube selection (\code{hopper} using compression)}\label{HDF5_format_performance:hdf5comphoppersubcube-figure}\end{figure}


\subsection{Aggression Parameter Study}
\label{HDF5_format_performance:aggression-parameter-study}
So far we have focused on the performance using \code{gzip} with \(aggression=4\), assuming that a medium aggression value provides a good balance of compression ratio and speed. \footnote[5]{
The \(aggression\) parameter is a number between \([0,9]\) to indicate the tradeoff between speed and compression ratio (0=fastest, 9=best ratio).
} The goal of this section is to determine the influence of the \(aggression\) setting on the overall performance. Figure {\hyperref[HDF5_format_performance:hdf5compaggrsizewrite\string-figure]{\emph{File size and write performance using varying gzip aggression settings}}} shows that the data compression we achieve for the test \(100 \times 100 \times 100,000\) dataset (using dataset A as donor dataset) are comparable for all \(aggression \in [1,8]\) settings (we did not evaluate an aggression setting of 9 as the write performance was very poor). For the data write, we observe that the performance is acceptable for \(aggression \in [1,5]\) and decreases significantly for \(aggression >5\).

For the selection test cases, the performance results are consistent with the results from the previous tests. On \code{portal}, the performance of the z-slice selection improves significantly when using compression, while the spectra and subcube selection show comparable performance with and without compression (see Figure {\hyperref[HDF5_format_performance:hdf5compaggrselectportal\string-figure]{\emph{Selection performance results using varying gzip aggression settings (portal)}}}). For \code{hopper}, we again observe a general strong decrease in the selection performance when enabling compression (while, although much slower, the overall selection performance is still acceptable) (see Figures {\hyperref[HDF5_format_performance:hdf5compaggrselecthopperproj\string-figure]{\emph{Selection performance results using varying gzip aggression settings (hopper using /project)}}} and {\hyperref[HDF5_format_performance:hdf5compaggrselecthopperscratch\string-figure]{\emph{Selection performance results using varying gzip aggression settings (hopper using /scratch)}}} \footnote[6]{
Bars shown transparently indicate that the bars exceed the maximum value shown in the plot. The real value for those bars are indicated via additional text labels.
}).

Overall, we find that for the data layouts tested here, increasing the aggression parameter above 1 does not have a large impact on the compression ratio and selection performance, whereas high aggression values may significantly decrease the data write performance. In the context of MSI data, low aggression values of \(aggression \in [1,4]\) may, therefore, be preferable when using \code{gzip} compression.
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Compression_Aggression_FileSize_Write}.pdf}}
\caption{File size and write performance using varying \code{gzip} aggression settings}\label{HDF5_format_performance:hdf5compaggrsizewrite-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Compression_Aggression_Select_Portal}.pdf}}
\caption{Selection performance results using varying \code{gzip} aggression settings (\code{portal})}\label{HDF5_format_performance:hdf5compaggrselectportal-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Compression_Aggression_Select_hopper_project}.pdf}}
\caption{Selection performance results using varying \code{gzip} aggression settings (\code{hopper} using \code{/project})}\label{HDF5_format_performance:hdf5compaggrselecthopperproj-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.700000}{\includegraphics{{HDF5_Compression_Aggression_Select_hopper_scratch}.pdf}}
\caption{Selection performance results using varying \code{gzip} aggression settings (\code{hopper} using \code{/scratch})}\label{HDF5_format_performance:hdf5compaggrselecthopperscratch-figure}\end{figure}


\section{Local Scalability: Multi-processing}
\label{HDF5_format_performance:local-scalability-multi-processing}
Next we tested the local scalability using Python's multiprocessing capabilities (i.e, on a single \code{hopper} login node and \code{portal}, and not across multiple compute nodes). We again use a \(100 \times 100 \times 100,000\) test dataset (using \emph{A} as donor dataset) and we regenerate the dataset for each experiment (i.e., file layout + system). We repeat each computation 50 times on the same file and report the average times and standard deviations. For this test we select 20,000 z slices (i.e, 20\% of the data) and compute the variance of the data values across the slices, i.e.:
\begin{itemize}
\item {} 
\(numpy.var( data[:,:, zstart:(zstart+20001) ] )\) with \(zstart\) being selected randomly (\(zstart \in [0 , 79999]\))

\end{itemize}

We parallelize the computation across processes by dividing data along the x axis, i.e., each process computes for its portion of the data:
\begin{itemize}
\item {} 
\(numpy.var( data[xstart:xend ,:, zstart:(zstart+20001) ] )\)

\end{itemize}

while \(xstart\) and \(xend\) are determined based on the process id. The result is then stored in a shared array. The average performance (with error bars indicating the standard deviation) for performing this calculation on \code{hopper} using \code{project} are shown in Figure {\hyperref[HDF5_format_performance:hdf5scaling1\string-hopper\string-project\string-figure]{\emph{Scaling results for computing the variance for 20000 z-slices (hopper using /project)}}}. We compute the speed-up by using the time required using 1 process as reference (i.e., the time from the current experiment so that the speed-up using 1 processor is always equal to 1)(see Figure {\hyperref[HDF5_format_performance:hdf5speedup1\string-hopper\string-project\string-figure]{\emph{Speed-up results for computing the variance for 20000 z-slices (hopper using /project)}}}). We repeated the same tests also on \code{portal} (again using the \code{/project} file systems). The results for portal are shown in Figures: i) {\hyperref[HDF5_format_performance:hdf5scaling1\string-portal\string-figure]{\emph{Scaling results for computing the variance for 20000 z-slices (portal)}}} and ii) {\hyperref[HDF5_format_performance:hdf5speedup1\string-portal\string-figure]{\emph{Speed-up results for computing the variance for 20000 z-slices (portal)}}}.

The main bottleneck in this calculation is again the data selection/load. We observe that we can achieve good speed-up for larger numbers of processes using \code{hopper} compared to \code{portal}. This behavior is likely due to the better I/O (network) performance of \code{hopper} compared to \code{portal}. On \code{portal} we observe a stable speed-up for up to 5 processes (when using compression) and we achieve a \(\approx 3 \times\) speed-up. Using \code{hopper} we observe a linear speed-up for up to 8 processes. Afterwards, we still observe speed-up, however, at a lower and less stable rate. As before, we observe that using compression yields better performance on \code{portal} while reducing the performance when using \code{hopper}.

In the context of the OpenMSI web-based data viewer we typically need to extract smaller subsets of the data. We, therefore, next repeated the variance computation for 25 consecutive z slices (similar to the z slice selection use-case used in the previous sections). The timings and speed-up results on \code{portal} using default setup ---i.e., with \(4 \times 4 \times 2048\) chunking and \code{gzip} compression, aggression=4--- are shown in Figure {\hyperref[HDF5_format_performance:hdf5timingsspeedup2\string-portal\string-figure]{\emph{Timings and sppeed-up results for computing the variance for 25 z-slices (portal)}}}. We observe that even-though the amount of data retrieved is with 0.5MB comparably small ---note the data being loaded to fulfill the query is on the order of 39.0625MB---, we can still achieve good speed-ups until 4-7 processes, afterwards the performance degrades again.
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.650000}{\includegraphics{{HDF5_localScaling_var_20000slices_hopper_project}.pdf}}
\caption{Scaling results for computing the variance for 20000 z-slices (\code{hopper} using \code{/project})}\label{HDF5_format_performance:hdf5scaling1-hopper-project-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.650000}{\includegraphics{{HDF5_localScaling_speedup_var_20000slices_hopper_project}.pdf}}
\caption{Speed-up results for computing the variance for 20000 z-slices (\code{hopper} using \code{/project})}\label{HDF5_format_performance:hdf5speedup1-hopper-project-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.650000}{\includegraphics{{HDF5_localScaling_var_20000slices_portal}.pdf}}
\caption{Scaling results for computing the variance for 20000 z-slices (\code{portal})}\label{HDF5_format_performance:hdf5scaling1-portal-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.650000}{\includegraphics{{HDF5_localScaling_speedup_var_20000slices_portal}.pdf}}
\caption{Speed-up results for computing the variance for 20000 z-slices (\code{portal})}\label{HDF5_format_performance:hdf5speedup1-portal-figure}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.650000}{\includegraphics{{HDF5_localScaling_var_25slices_portal}.pdf}}
\caption{Timings and sppeed-up results for computing the variance for 25 z-slices (\code{portal})}\label{HDF5_format_performance:hdf5timingsspeedup2-portal-figure}\end{figure}


\section{Discussion}
\label{HDF5_format_performance:discussion}\label{HDF5_format_performance:hdf5-test-discussion}

\subsection{Data Layout}
\label{HDF5_format_performance:data-layout}
Use of chunking has many benefits but choosing the correct chunk size can be complicated. In the context of MSI data, the choice of a good data layout is complicated by: i) the large difference between the size of the spatial \(x\)/\(y\) and the \(z\) (\(mz\), mass) dimension and ii) the need for regularly performing orthogonal data selection operations (namely selection of spectra \code{{[}x,y,:{]}} and full slices in z \code{{[}:,:,z{]}}. Our experiments have shown that a chunking of \(4 \times 4 \times 2048\) may work well for most cases, i.e., it provides a good compromise in performance between the different selection operations while maintaining acceptable write performance and limiting the worst-case overhead in file size.

Our experiments have also shown that MSI data lends itself well to compression (we have seen reductions in file size on the order of \(3 \times\) to \(9 \times\) on real MSI datasets). We have also seen that the use of data compression (here \code{gzip}) may also improve the selection performance by reducing the amount of data that needs to be loaded from disk (see results from \code{portal}). This is particularly true for I/O (and or network) bound systems, such as \code{portal}. However, we have also seen (on \code{hopper}) that the use of compression can also decrease the selection performance due to the time required for decompression (see results \code{hopper}). Having direct access to uncompressed data may, hence, be advantageous for any analyses that require a large number of random accesses to the data from a high-performance compute systems (such as \code{hopper}) where the time required for decompression is larger than the time saved for data transfer. However, the reduced storage requirements and overall more stable selection performance results suggest that the use of compression may be advantageous.

Based on the results from this study we currently use a data layout of \(4 \times 4 \times 2048\) with \code{gzip} compression and \code{aggression=4} as default for storing MSI data using the OMSI HDF5 data format.


\subsection{System Performance}
\label{HDF5_format_performance:system-performance}
In a serial setting we observe that \code{hopper}`s \code{/scratch} filesystem generally provides better selective read performance than the \code{/project} file system. This is not unexpected and overall the performance of both file systems appears to be sufficient to perform most common MSI analysis tasks. However, based on the test results it appears that on \code{portal}: i) the selection performance is highly dependent on system load (which appeared to be high on many occasions) and ii) the selection performance is bound by the performance of the I/O system. Since the performance using \code{/project} is significantly higher on \code{hopper} login nodes than on \code{portal}, it appears that the bandwidth of the network connection of \code{portal} to the GPFS \code{/project} file system may be too low to ensure a reliably fast operation of web-applications that require repeated access to large datasets. This, however, is essential for production use of science gateways that aim to make advanced data viewing and analysis capabilities accessible to the application community (such as the OpenMSI science gateway for MSI data). While we were able to achieve usable I/O performance on \code{portal} through the use of chunking and compression, we have also seen that even from \code{/project} we can achieve significantly better performance on \code{hopper} when storing the data in a raw, uncompressed form (i.e., we should be able to get much better selective I/O performance on \code{portal} using \code{/project}). While \code{portal} provides a good platform for development of science gateways and web applications, the question remains whether \code{portal} is powerful enough ---with respect to both compute, I/O and network performance--- to provide a reliable, high-performance platform for hosting production science gateways.


\subsection{Future Work}
\label{HDF5_format_performance:future-work}
In future we plan to evaluate the performance of the different data layouts in a: i) local parallel (multi-processing) and ii) distribution parallel (MPI) environment.

While \code{gzip} is one of the most widely available compression algorithms in HDF5 it is not necessarily one with the best performance. In future we plan to evaluate the use of other compression algorithms ---such as, szip \footnote[7]{
\href{http://www.hdfgroup.org/doc\_resource/SZIP/}{http://www.hdfgroup.org/doc\_resource/SZIP/}
}, LZF \footnote[8]{
\href{http://h5py.alfven.org/lzf/}{http://h5py.alfven.org/lzf/}
}, HDF5 N-Bit Filter \footnote[9]{
\href{http://www.hdfgroup.org/HDF5/doc/RM/RM\_H5P.html\#Property-SetNbit}{http://www.hdfgroup.org/HDF5/doc/RM/RM\_H5P.html\#Property-SetNbit}
} , HDF5 Scale+Offset Filter \footnote[10]{
\href{http://www.hdfgroup.org/HDF5/doc/RM/RM\_H5P.html\#Property-SetScaleoffset}{http://www.hdfgroup.org/HDF5/doc/RM/RM\_H5P.html\#Property-SetScaleoffset}
} etc.--- to further improve the overall read performance and to reduce the larger overheads for compression we have seen on \code{hopper}. In addition to compression, HDF5 also provides a shuffle filter \footnote[11]{
\href{http://www.hdfgroup.org/HDF5/doc/RM/RM\_H5Z.html}{http://www.hdfgroup.org/HDF5/doc/RM/RM\_H5Z.html}
} which can potentially further improve the effectiveness of data compression \footnote[12]{
\href{http://www.hdfgroup.org/HDF5/doc\_resource/H5Shuffle\_Perf.pdf}{http://www.hdfgroup.org/HDF5/doc\_resource/H5Shuffle\_Perf.pdf} ,
} .


\chapter{omsi Package}
\label{omsi:omsi-package}\label{omsi::doc}

\section{Subpackages}
\label{omsi:subpackages}
The omsi package defines the main BASTet software stack used, e.g., by the OpenMSI project.
It contains a large range of functionality for interacting analyses, OpenMSI HDF5 data files,
analysis workflows and other related infrastructure. The following is a rough overview
of the various packages and modules
\begin{itemize}
\item {} 
\textbf{Analysis} {\hyperref[omsi.analysis:module\string-omsi.analysis]{\emph{\code{omsi.analysis}}}} Package containing the base classes that facilitate the integration of new analysis with the BASTet software stack (e.g, the file format) and collection of specific analysis functionality.

\end{itemize}

\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


{\hyperref[omsi.analysis:module\string-omsi.analysis]{\emph{\code{omsi.analysis}}}}
 & 
Package containing the base classes that facilitate the integration of new analysis with the BASTet software stack (e.g, the file format) and collection of specific analysis functionality.
\\
\hline
{\hyperref[omsi.analysis.compound_stats:module\string-omsi.analysis.compound_stats]{\emph{\code{omsi.analysis.compound\_stats}}}}
 & 
Package containing shared third-party code modules included here to reduce the need for external dependencies when only small parts of external code are used.
\\
\hline
{\hyperref[omsi.analysis.findpeaks:module\string-omsi.analysis.findpeaks]{\emph{\code{omsi.analysis.findpeaks}}}}
 & 
Package of peak-finding related analysis modules.
\\
\hline
{\hyperref[omsi.analysis.msi_filtering:module\string-omsi.analysis.msi_filtering]{\emph{\code{omsi.analysis.msi\_filtering}}}}
 & 
Module with third-party modules, functions, classes used by some of the analysis modules in the containing package.
\\
\hline
{\hyperref[omsi.analysis.multivariate_stats:module\string-omsi.analysis.multivariate_stats]{\emph{\code{omsi.analysis.multivariate\_stats}}}}
 & 
Multivariate statistics analysis
\\
\hline\end{longtable}

\begin{itemize}
\item {} 
\textbf{Data Format} \code{omsi.dataformat} Package for implementation and specification of file formats. In particular this package contains the base API for interacting with OpenMSI HDF5 datasets.

\end{itemize}

\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


\code{omsi.dataformat}
 & 
Package for implementation and specification of file formats.
\\
\hline
{\hyperref[omsi.dataformat.omsi_file:module\string-omsi.dataformat.omsi_file]{\emph{\code{omsi.dataformat.omsi\_file}}}}
 & 
Module for specification of the OpenMSI file API.
\\
\hline\end{longtable}

\begin{itemize}
\item {} 
\textbf{Workflow} {\hyperref[omsi.workflow:module\string-omsi.workflow]{\emph{\code{omsi.workflow}}}} Package with modules for specification and execution of analysis tasks and complex analysis workflows.

\end{itemize}

\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


{\hyperref[omsi.workflow:module\string-omsi.workflow]{\emph{\code{omsi.workflow}}}}
 & 
Package with modules for specification and execution of analysis tasks and complex analysis workflows.
\\
\hline
\code{omsi.worflow.dirver}
 & 

\\
\hline
{\hyperref[omsi.workflow.executor:module\string-omsi.workflow.executor]{\emph{\code{omsi.workflow.executor}}}}
 & 
Package with executors of analysis workflows.
\\
\hline\end{longtable}

\begin{itemize}
\item {} 
\textbf{Data Structures} \code{omsi.datastructure} Package with a collection of various data structures and related classes used throughout the software stack, e.g., for metadata, analysis parameter data, runtime information data etc.

\end{itemize}

\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


{\hyperref[omsi.datastructures:module\string-omsi.datastructures]{\emph{\code{omsi.datastructures}}}}
 & 
Package with a collection of various data structures and related classes used throughout the software stack, e.g., for metadata, analysis parameter data, runtime information data etc.
\\
\hline
{\hyperref[omsi.datastructures.metadata:module\string-omsi.datastructures.metadata]{\emph{\code{omsi.datastructures.metadata}}}}
 & 
Package with metadata datastructures
\\
\hline\end{longtable}

\begin{itemize}
\item {} 
\textbf{Shared} \code{omsi.shared} Package used to implement shared functionality and helper functions.

\end{itemize}

\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


\code{omsi.shared}
 & 
Package used to implement shared functionality and helper functions.
\\
\hline
\code{omsi.shared.thirdparty}
 & 

\\
\hline\end{longtable}

\begin{itemize}
\item {} 
\textbf{Tools} \code{omsi.tools} Package for collecting tools (e.g,. command-line programs) to help with particular tasks. This includes, e.g, tools for data conversion, document generation, etc.

\end{itemize}

\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


\code{omsi.tools}
 & 
Package for collecting tools (e.g,.
\\
\hline
{\hyperref[omsi.tools.misc:module\string-omsi.tools.misc]{\emph{\code{omsi.tools.misc}}}}
 & 
Collection of miscellaneous tools.
\\
\hline\end{longtable}

\begin{itemize}
\item {} 
\textbf{Templates} {\hyperref[omsi.templates:module\string-omsi.templates]{\emph{\code{omsi.templates}}}} This package provides a collection of code templates to ease the development of additional components, e.g., analysis modules. As such, this package is NOT intended for direct usage but is rather just a library of code templates.

\end{itemize}

\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


{\hyperref[omsi.templates:module\string-omsi.templates]{\emph{\code{omsi.templates}}}}
 & 
This package provides a collection of code templates to ease the development of additional components, e.g., analysis modules.
\\
\hline\end{longtable}

\begin{itemize}
\item {} 
\textbf{Examples} \code{omsi.examples} Package with a collection of various misc. example scripts.

\end{itemize}

\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


\code{omsi.examples}
 & 
Package with a collection of various misc.
\\
\hline\end{longtable}



\subsection{analysis Package}
\label{omsi.analysis:analysis-package}\label{omsi.analysis::doc}
\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


{\hyperref[omsi.analysis:module\string-omsi.analysis]{\emph{\code{omsi.analysis}}}}
 & 
Package containing the base classes that facilitate the integration of new analysis with the BASTet software stack (e.g, the file format) and collection of specific analysis functionality.
\\
\hline
{\hyperref[omsi.analysis:module\string-omsi.analysis.base]{\emph{\code{omsi.analysis.base}}}}
 & 
Module specifying the base analysis API for integrating new analysis with the toolkit and the OpenMSI science gateway.
\\
\hline
{\hyperref[omsi.analysis:module\string-omsi.analysis.generic]{\emph{\code{omsi.analysis.generic}}}}
 & 
Generic analysis class used to represent analyses of unknown type, e.g., when loading a custom user-defined analysis from file for which the indicate class may not be available with the local installation.
\\
\hline
{\hyperref[omsi.analysis:module\string-omsi.analysis.analysis_views]{\emph{\code{omsi.analysis.analysis\_views}}}}
 & 
Helper module with functions and classes for interfacing with different analysis algorithms.
\\
\hline
{\hyperref[omsi.analysis.compound_stats:module\string-omsi.analysis.compound_stats]{\emph{\code{omsi.analysis.compound\_stats}}}}
 & 
Package containing shared third-party code modules included here to reduce the need for external dependencies when only small parts of external code are used.
\\
\hline
\code{omsi.analysis.compound\_stats.omsi\_score\_compounds}
 & 

\\
\hline
{\hyperref[omsi.analysis.findpeaks:module\string-omsi.analysis.findpeaks]{\emph{\code{omsi.analysis.findpeaks}}}}
 & 
Package of peak-finding related analysis modules.
\\
\hline
{\hyperref[omsi.analysis.findpeaks:module\string-omsi.analysis.findpeaks.omsi_findpeaks_global]{\emph{\code{omsi.analysis.findpeaks.omsi\_findpeaks\_global}}}}({[}...{]})
 & 
Basic global peak detection analysis.
\\
\hline
{\hyperref[omsi.analysis.findpeaks:module\string-omsi.analysis.findpeaks.omsi_findpeaks_local]{\emph{\code{omsi.analysis.findpeaks.omsi\_findpeaks\_local}}}}({[}...{]})
 & 
Class defining a basic gloabl peak finding.
\\
\hline
{\hyperref[omsi.analysis.msi_filtering:module\string-omsi.analysis.msi_filtering]{\emph{\code{omsi.analysis.msi\_filtering}}}}
 & 
Module with third-party modules, functions, classes used by some of the analysis modules in the containing package.
\\
\hline
{\hyperref[omsi.analysis.msi_filtering:module\string-omsi.analysis.msi_filtering.omsi_tic_norm]{\emph{\code{omsi.analysis.msi\_filtering.omsi\_tic\_norm}}}}({[}...{]})
 & 
TIC Normalization analysis.
\\
\hline
{\hyperref[omsi.analysis.multivariate_stats:module\string-omsi.analysis.multivariate_stats]{\emph{\code{omsi.analysis.multivariate\_stats}}}}
 & 
Multivariate statistics analysis
\\
\hline
{\hyperref[omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_cx]{\emph{\code{omsi.analysis.multivariate\_stats.omsi\_cx}}}}({[}...{]})
 & 
Class used to implement CX factorization on MSI data.
\\
\hline
{\hyperref[omsi.analysis.multivariate_stats:module\string-omsi.analysis.multivariate_stats.omsi_nmf]{\emph{\code{omsi.analysis.multivariate\_stats.omsi\_nmf}}}}({[}...{]})
 & 
Class defining a basic nmf analysis.
\\
\hline\end{longtable}



\subsubsection{\texttt{analysis} Package}
\label{omsi.analysis:id1}\phantomsection\label{omsi.analysis:module-omsi.analysis}\index{omsi.analysis (module)}
Package containing the base classes that facilitate the integration of new analysis with the BASTet software
stack (e.g, the file format) and collection of specific analysis functionality.
\index{analysis\_data (class in omsi.analysis)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_data}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.}\bfcode{analysis\_data}}{\emph{name='undefined'}, \emph{data=None}, \emph{dtype='float32'}}{}
Bases: \code{dict}

Define an output dataset for the analysis that should be written to the omsi HDF5 file

The class can be used like a dictionary but restricts the set of keys that can be used
to the following required keys which should be provided during initalization.

\textbf{Required Keyword Arguments}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- The name for the dataset in the HDF5 format

\item {} 
\textbf{\texttt{data}} -- The numpy array to be written to HDF5. The data write function
omsi\_file\_experiment.create\_analysis used for writing of the data to file can
in principal also handel other primitive data types by explicitly converting them
to numpy. However, in this case the dtype is determined based on the numpy conversion
and correct behavior is not guaranteed. I.e., even single scalars should be stored as
a 1D numpy array here. Default value is None which is mapped to np.empty( shape=(0) , dtype=dtype)
in \_\_init\_\_

\item {} 
\textbf{\texttt{dtype}} -- 
The data type to be used during writing. For standard numpy data types this is just
the dtype  of the dataset, i.e., {[}'data'{]}.dtype. Other allowed datatypes are:
\begin{itemize}
\item {} 
For string:  omsi\_format.str\_type (omsi\_format is located in omsi.dataformat.omsi\_file )

\item {} 
To generate data links: ana\_hdf5link   (analysis\_data)

\end{itemize}


\end{itemize}

\end{description}\end{quote}
\index{ana\_hdf5link (omsi.analysis.analysis\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_data.ana_hdf5link}\pysigline{\bfcode{ana\_hdf5link}\strong{ = -1}}
\end{fulllineitems}


\end{fulllineitems}

\index{analysis\_base (class in omsi.analysis)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base}\pysigline{\strong{class }\code{omsi.analysis.}\bfcode{analysis\_base}}
Bases: {\hyperref[omsi.datastructures:omsi.datastructures.analysis_data.parameter_manager]{\emph{\code{omsi.datastructures.analysis\_data.parameter\_manager}}}}

Base class for omsi analysis functionality. The class provides a large set of functionality designed
to facilitate storage of analysis data in the omsi HDF5 file format. The class also provides a set
of functions to enable easy intergration of new analysis with the OpenMSI web-based viewer (see
Viewer functions below for details).

\textbf{Slicing:}

This class supports basic slicing to access data stored in the main member variables. By
default the data is retrieved from \_\_data\_list and the \_\_getitem\_\_(key) function. which implements
the {[}..{]} operator, returns \_\_data\_list{[}key{]}{[}'data'{]}. The key is a string indicating the name of
the parameter to be retrieved. If the key is not found in the \_\_data\_list then the function will
try to retrieve the data from self.parameters list instead. By adding ``parameter/key'' or ``dependency/key''
one may also explicitly retrieve values from the parameters.

\textbf{Instance Variables:}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_analysis.analysis_identifier]{\emph{\textbf{\texttt{analysis\_identifier}}}}} -- Define the name for the analysis used as key in search operations

\item {} 
\textbf{\texttt{\_\_data\_list}} -- List of analysis\_data to be written to the HDF5 file. Derived classes
need to add all data that should be saved for the analysis in the omsi HDF5 file to this dictionary.
See omsi.analysis.analysis\_data for details.

\item {} 
\textbf{\texttt{parameters}} -- List of parameter\_data objects of all  analysis parameters
(including those that may have dependencies).

\item {} 
\textbf{\texttt{data\_names}} -- List of strings of all names of analysis output datasets. These are the
target keys for \_\_data\_list.

\item {} 
\textbf{\texttt{profile\_time\_and\_usage}} -- Boolean indicating whether we should profile the execute\_analysis(...) function
when called as part of the execute(...) function. The default value is false. Use the
enable\_time\_and\_usage\_profiling(..) function to determine which profiling should be performed. The time\_and
\_usage profile uses pythons cProfile (or Profile) to monitor how often and for how long particular parts
of the analysis code executed.

\item {} 
\textbf{\texttt{profile\_memory}} -- Boolean indicating whether we should monitor memory usage (line-by-line) when
executing the execute\_analysis(...) function. The default value is false. Use the
enable\_time\_and\_usage\_profiling(..) function to determine which profiling should be performed.

\item {} 
\textbf{\texttt{omsi\_analysis\_storage}} -- List of omsi\_file\_analysis object where the analysis is stored. The list may be empty.

\item {} 
\textbf{\texttt{mpi\_comm}} -- In case we are running with MPI, this is the MPI communicator used for runnign the analysis.
Default is MPI.Comm\_world/

\item {} 
\textbf{\texttt{mpi\_root}} -- In case we are running with MPI, this is the root rank where data is collected to (e.g., runtime
data and analysis results)

\item {} 
\textbf{\texttt{update\_analysis}} -- If the value is True, then we should execute the analysis before using the outputs.
If False, then the analysis has been executed with the current parameter settings.

\item {} 
{\hyperref[omsi.workflow.driver:module\string-omsi.workflow.driver]{\emph{\textbf{\texttt{driver}}}}} -- Workflow driver to be used when executing multiple analyses, e.g., via execute\_recursive or
execute\_all. Default value is None in which case a new default driver will be used each time we
execute a workflow.

\end{itemize}

\end{description}\end{quote}

\textbf{Execution Functions:}
\begin{itemize}
\item {} 
\code{execute} : Then main function the user needs to call in order to execute the analysis

\item {} 
{\color{red}\bfseries{}{}`{}`}execute\_analysis: This function needs to be implemented by child classes of \emph{analysis\_base}         to implement the specifics of executing the analysis.

\end{itemize}

\textbf{I/O functions:}

These functions can be optionally overwritten to control how the analysis data should be written/read
from the omsi HDF5 file. Default implementations are provided here, which should be sufficient for most cases.
\begin{itemize}
\item {} 
\code{add\_custom\_data\_to\_omsi\_file}: The default implementation is empty as the default data write is  managed by     the \emph{omsi\_file\_experiment.create\_analysis()} function.  Overwrite this function, in case that the analysis needs     to write data to the HDF5 omsi file beyond what the defualt omsi data API does.

\item {} 
\code{read\_from\_omsi\_file}: The default implementation tries to reconstruct the original data as far as possible,     however, in particular in case that a custom add\_custom\_data\_to\_omsi\_file function has been implemented, the     default implementation may not be sufficien. The default implementation reconstructs: i) analysis\_identifier     and reads all custom data into ii)\_\_data\_list. Note, an error will be raised in case that the analysis type     specified in the HDF5 file does not match the analysis type specified by get\_analysis\_type(). This function     can be optionally overwritten to implement a custom data read.

\end{itemize}

\textbf{Viewer functions:}

Several convenient functions are used to allow the OpenMSI online viewer to interact with the analysis     and to visualize it. The default implementations provided here simply indicate that the analysis does not     support the data access operations required by the online viewer. Overwrite these functions in the derived     analysis classes in order to interface them with the viewer. All viewer-related functions start with \code{v\textbackslash{}\_...} .

NOTE: the default implementation of the viewer functions defined in \code{analysis\_base} are     designed to take care of the common requirement for providing viewer access to data from all dependencies     of an analysis. In many cases, the default implementation is often sill called at the end of custom     viewer functions.

NOTE: The viewer functions typically support a viewer\_option parameter. viewer\_option=0 is expected to      refer to the analysis itself.
\begin{itemize}
\item {} 
\code{v\_qslice}: Retrieve/compute data slices as requested via qslice URL requests. The corresponding view     of the DJANGO data access server already translates all input parameters and takes care of generating images/plots     if needed. This function is only responsible for retrieving the data.

\item {} 
\code{v\_qspectrum}: Retrieve/compute spectra as requested via qspectrum URL requests. The corresponding view of     the DJANGO data access server already translates all input parameters and takes care of generating images/plots     if needed. This function is only responsible for retrieving the data.

\item {} 
\code{v\_qmz}: Define the m/z axes for image slices and spectra as requested by qspectrum URL requests.

\item {} 
\code{v\_qspectrum\_viewer\_options}: Define a list of strings, describing the different viewer options available     for the analysis for qspectrum requests (i.e., \code{v\_qspectrum}). This feature allows the analysis developer     to define multiple different visualization modes for the analysis. For example, when performing a data reduction     (e.g., PCA or NMF) one may want to show the raw spectra or the loadings vector of the projection in the spectrum     view (v\_qspectrum). By providing different viewer options we allow the user to decide which option they are     most interested in.

\item {} 
\code{v\_qslice\_viewer\_options}: Define a list of strings, describing the different viewer options available for     the analysis for qslice requests (i.e., \code{v\_qslice}). This feature allows the analysis developer to define     multiple different visualization modes for the analysis. For example, when performing a data reduction     (e.g., PCA or NMF) one may want to show the raw spectra or the loadings vector of the projection in the spectrum     view (v\_qspectrum). By providing different viewer options we allow the user to decide which option they     are most interested in.

\end{itemize}

Initialize the basic data members
\index{add\_custom\_data\_to\_omsi\_file() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.add_custom_data_to_omsi_file}\pysiglinewithargsret{\bfcode{add\_custom\_data\_to\_omsi\_file}}{\emph{analysis\_group}}{}
This function can be optionally overwritten to implement a custom data write
function for the analysis to be used by the omsi\_file API.

Note, this function should be used only to add additional data to the analysis
group. The data that is written by default is still written by
the \emph{omsi\_file\_experiment.create\_analysis()} function, i.e., the following data is
written by default: i) analysis\_identifier ,ii) get\_analysis\_type, iii)\_\_data\_list,
iv) parameters, v) runinfo . Since the \emph{omsi\_file.experiment.create\_analysis()}
functions takes care of setting up the basic structure of the analysis storage
(included the subgroubs for storing parameters and data dependencies) this setup can generally
be assumed to exist before this function is called. This function is called
automatically at the end omsi\_file.experiment.create\_analysis() (i.e, actually
\emph{omsi\_file\_analysis.\_\_populate\_analysis\_\_(..)} so that this function typically does not need to
be called explicitly.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_group}} -- The h5py.Group object where the analysis is stored.

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_parameter() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.add_parameter}\pysiglinewithargsret{\bfcode{add\_parameter}}{\emph{name}, \emph{help}, \emph{dtype=\textless{}type `unicode'\textgreater{}}, \emph{required=False}, \emph{default=None}, \emph{choices=None}, \emph{data=None}, \emph{group=None}}{}
Add a new parameter for the analysis. This function is typically used in the constructor
of a derived analysis to specify the parameters of the analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- The name of the parameter

\item {} 
\textbf{\texttt{help}} -- Help string describing the parameter

\item {} 
\textbf{\texttt{type}} -- Optional type. Default is string.

\item {} 
\textbf{\texttt{required}} -- Boolean indicating whether the parameter is required (True) or optional (False). Default False.

\item {} 
\textbf{\texttt{default}} -- Optional default value for the parameter. Default None.

\item {} 
\textbf{\texttt{choices}} -- Optional list of choices with allowed data values. Default None, indicating no choices set.

\item {} 
\textbf{\texttt{data}} -- The data assigned to the parameter. None by default.

\item {} 
\textbf{\texttt{group}} -- Optional group string used to organize parameters. Default None, indicating that
parameters are automatically organized by driver class (e.g. in required and optional parameters)

\end{itemize}

\item[{Raises}] \leavevmode
ValueError is raised if the parameter with the given name already exists.

\end{description}\end{quote}

\end{fulllineitems}

\index{analysis\_identifier\_defined() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.analysis_identifier_defined}\pysiglinewithargsret{\bfcode{analysis\_identifier\_defined}}{}{}
Check whether the analysis identifier is defined by the user, i.e., set to value different than undefined
:return: bool

\end{fulllineitems}

\index{check\_ready\_to\_execute() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.check_ready_to_execute}\pysiglinewithargsret{\bfcode{check\_ready\_to\_execute}}{}{}
Check if all inputs are ready to determine if the analysis is ready to run.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of omsi\_analysis\_parameter objects that are not ready. If the
returned list is empty, then the analysis is ready to run.

\end{description}\end{quote}

\end{fulllineitems}

\index{clear\_analysis() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.clear_analysis}\pysiglinewithargsret{\bfcode{clear\_analysis}}{}{}
Clear all analysis data---i.e., parameter, dependency data, output results, runtime data

\end{fulllineitems}

\index{clear\_analysis\_data() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.clear_analysis_data}\pysiglinewithargsret{\bfcode{clear\_analysis\_data}}{}{}
Clear the list of analysis data

\end{fulllineitems}

\index{clear\_and\_restore() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.clear_and_restore}\pysiglinewithargsret{\bfcode{clear\_and\_restore}}{\emph{analysis\_manager=None}, \emph{resave=False}}{}
Clear all analysis data and restore the results from file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_manager}} -- Instance of omsi\_analysis\_manager (e.g., an omsi\_file\_experiment) where the
analysis should be saved.

\item {} 
\textbf{\texttt{resave}} -- Boolean indicating whether the analysis should be saved again, even if it has been
saved before. This parameter only has effect if analysis\_manager is given.

\end{itemize}

\item[{Returns}] \leavevmode
self, i.e., the updated analysis object with all data replaced with HDF5 references

\end{description}\end{quote}

\end{fulllineitems}

\index{clear\_parameter\_data() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.clear_parameter_data}\pysiglinewithargsret{\bfcode{clear\_parameter\_data}}{}{}
Clear the list of parameter data

\end{fulllineitems}

\index{clear\_run\_info\_data() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.clear_run_info_data}\pysiglinewithargsret{\bfcode{clear\_run\_info\_data}}{}{}
Clear the runtime information data

\end{fulllineitems}

\index{define\_missing\_parameters() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.define_missing_parameters}\pysiglinewithargsret{\bfcode{define\_missing\_parameters}}{}{}
Called by the execute function before self.update\_analysis\_parameters
to set any required parameters that have not been defined to their respective default values.

This function may be overwritten in child classes to customize
the definition of default parameter values and to apply any
modifications (or checks) of parameters before the analysis is executed.
Any changes applied here will be recorded in the parameter of the analysis.

\end{fulllineitems}

\index{enable\_memory\_profiling() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.enable_memory_profiling}\pysiglinewithargsret{\bfcode{enable\_memory\_profiling}}{\emph{enable=True}}{}
Enable or disable line-by-line profiling of memory usage of execute\_analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{enable\_memory}} (\emph{\texttt{bool}}) -- Enable (True) or disable (False) line-by-line profiling of memory usage

\item[{Raises}] \leavevmode
ImportError is raised if a required package for profiling is not available.

\end{description}\end{quote}

\end{fulllineitems}

\index{enable\_time\_and\_usage\_profiling() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.enable_time_and_usage_profiling}\pysiglinewithargsret{\bfcode{enable\_time\_and\_usage\_profiling}}{\emph{enable=True}}{}
Enable or disable profiling of time and usage of code parts of execute\_analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{enable}} (\emph{\texttt{bool}}) -- Enable (True) or disable (False) profiling

\item[{Raises}] \leavevmode
ImportError is raised if a required package for profiling is not available.

\end{description}\end{quote}

\end{fulllineitems}

\index{execute() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.execute}\pysiglinewithargsret{\bfcode{execute}}{\emph{**kwargs}}{}
Use this function to run the analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{kwargs}} -- Parameters to be used for the analysis. Parameters may also be set using
the \_\_setitem\_\_ mechanism or as batches using the set\_parameter\_values function.

\item[{Returns}] \leavevmode
This function returns the output of the execute analysis function.

\item[{Raises}] \leavevmode
AnalysisReadyError in case that the analysis is not ready to be executed. This may be
the case, e.g, when a dependent input parameter is not ready to be used.

\end{description}\end{quote}

\end{fulllineitems}

\index{execute\_all() (omsi.analysis.analysis\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.execute_all}\pysiglinewithargsret{\strong{classmethod }\bfcode{execute\_all}}{\emph{force\_update=False}, \emph{executor=None}}{}
Execute all analysis instances that are currently defined.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{force\_update}} -- Boolean indicating whether we should force that all analyses are
executed again, even if they have already been run with the same settings before.
False by default.

\item {} 
\textbf{\texttt{executor}} -- Optional workflow executor to be used for the execution of all analyses.
The executor will be cleared and then all analyses will be added to executor. Default
value is None, in which case the function creates a default executor to be used.

\end{itemize}

\item[{Returns}] \leavevmode
The workflow executor used

\end{description}\end{quote}

\end{fulllineitems}

\index{execute\_analysis() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
Implement this function to implement the execution of the actual analysis.

This function may not require any input parameters. All input parameters are
recorded in the parameters and dependencies lists and should be retrieved
from there, e.g, using basic slicing self{[} paramName {]}

Input parameters may be added for internal use ONLY. E.g, we may add parameters that
are used internally to help with parallelization of the execute\_analysis function.
Such parameters are not recorded and must be strictly optional so that analysis\_base.execute(...)
can call the function.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This function may return any developer-defined data. Note, all
output that should be recorded must be put into the data list.

\end{description}\end{quote}

\end{fulllineitems}

\index{execute\_recursive() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.execute_recursive}\pysiglinewithargsret{\bfcode{execute\_recursive}}{\emph{**kwargs}}{}
Recursively execute this analysis and all its dependencies if necessary

We use a workflow driver to control the execution. To define the workflow driver we can set
the self.driver variable. If no workflow driver is given (i.e, self.driver==None), then the
default driver will be created. To change the default driver,
see \emph{omsi.workflow.base.workflow\_executor\_base.DEFAULT\_EXECUTOR\_CLASS}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{kwargs}} -- Parameters to be used for the analysis. Parameters may also be set using
the \_\_setitem\_\_ mechanism or as batches using the set\_parameter\_values function.

\item[{Returns}] \leavevmode
Same as execute

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_analysis\_data() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_all_analysis_data}\pysiglinewithargsret{\bfcode{get\_all\_analysis\_data}}{}{}
Get the complete list of all analysis datasets to be written to the HDF5 file

\end{fulllineitems}

\index{get\_all\_dependency\_data() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_all_dependency_data}\pysiglinewithargsret{\bfcode{get\_all\_dependency\_data}}{}{}
Get the complete list of all direct dependencies to be written to the HDF5 file

NOTE: These are only the direct dependencies as specified by the analysis itself.
Use  get\_all\_dependency\_data\_recursive(..) to also get the indirect dependencies of
the analysis due to dependencies of the dependencies themselves.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of parameter\_data objects that define dependencies.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_parameter\_data() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_all_parameter_data}\pysiglinewithargsret{\bfcode{get\_all\_parameter\_data}}{\emph{exclude\_dependencies=False}}{}
Get the complete list of all parameter datasets to be written to the HDF5 file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{exclude\_dependencies}} -- Boolean indicating whether we should exclude parameters
that define dependencies from the list

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_run\_info() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_all_run_info}\pysiglinewithargsret{\bfcode{get\_all\_run\_info}}{}{}
Get the dict with the complete info about the last run of the analysis

\end{fulllineitems}

\index{get\_analysis\_data() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_analysis_data}\pysiglinewithargsret{\bfcode{get\_analysis\_data}}{\emph{index}}{}
Given the index return the associated dataset to be written to the HDF5 file

:param index : Retrun the index entry of the private member \_\_data\_list.

\end{fulllineitems}

\index{get\_analysis\_data\_by\_name() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_analysis_data_by_name}\pysiglinewithargsret{\bfcode{get\_analysis\_data\_by\_name}}{\emph{dataname}}{}
Given the key name of the data return the associated analysis\_data object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{dataname}} -- Name of the analysis data requested from the private \_\_data\_list member.

\item[{Returns}] \leavevmode
The analysis\_data object or None if not found.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_analysis\_data\_names() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_analysis_data_names}\pysiglinewithargsret{\bfcode{get\_analysis\_data\_names}}{}{}
Get a list of all analysis dataset names.

\end{fulllineitems}

\index{get\_analysis\_identifier() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_analysis_identifier}\pysiglinewithargsret{\bfcode{get\_analysis\_identifier}}{}{}
Return the name of the analysis used as key when searching for a particular analysis

\end{fulllineitems}

\index{get\_analysis\_instances() (omsi.analysis.analysis\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_analysis_instances}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_analysis\_instances}}{}{}
Generator function used to iterate through all instances of analysis\_base.
The function creates references for all weak references stored in cls.\_analysis\_instances
and returns the references if it exists and cleans up the any invalid references after the
iteration is complete.
:return: References to analysis\_base objects

\end{fulllineitems}

\index{get\_analysis\_type() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_analysis_type}\pysiglinewithargsret{\bfcode{get\_analysis\_type}}{}{}
Return a string indicating the type of analysis performed

\end{fulllineitems}

\index{get\_default\_dtypes() (omsi.analysis.analysis\_base static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_default_dtypes}\pysiglinewithargsret{\strong{static }\bfcode{get\_default\_dtypes}}{}{}
Get a list of available default dtypes used for analyses.
Same as \emph{data\_dtypes.get\_dtypes()}.

\end{fulllineitems}

\index{get\_default\_parameter\_groups() (omsi.analysis.analysis\_base static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_default_parameter_groups}\pysiglinewithargsret{\strong{static }\bfcode{get\_default\_parameter\_groups}}{}{}
Get a list of commonly used parameter groups and associated descriptions.

Use of default groups provides consistency and allows other system to
design custom behavior around the semantic of parameter groups
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Dictionary where the keys are the short names of the groups and the
values are dicts with following keys:value pairs: `name' , `description'.
Use the `name' to define the group to be used.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_help\_string() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_help_string}\pysiglinewithargsret{\bfcode{get\_help\_string}}{}{}
Get a string describing the analysis.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Help string describing the analysis and its parameters

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_memory\_profile\_info() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_memory_profile_info}\pysiglinewithargsret{\bfcode{get\_memory\_profile\_info}}{}{}
Based on the memory profile of the execute\_analysis(..) function get
the string describing the line-by-line memory usage.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
String describing the memory usage profile. None is returned in case that
no memory profiling data is available.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_num\_analysis\_data() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_num_analysis_data}\pysiglinewithargsret{\bfcode{get\_num\_analysis\_data}}{}{}
Retrun the number of analysis datasets to be wirtten to the HDF5 file

\end{fulllineitems}

\index{get\_num\_dependency\_data() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_num_dependency_data}\pysiglinewithargsret{\bfcode{get\_num\_dependency\_data}}{}{}
Return the number of dependencies to be wirtten to the HDF5 file

\end{fulllineitems}

\index{get\_num\_parameter\_data() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_num_parameter_data}\pysiglinewithargsret{\bfcode{get\_num\_parameter\_data}}{}{}
Return the number of parameter datasets to be wirtten to the HDF5 file

\end{fulllineitems}

\index{get\_omsi\_analysis\_storage() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_omsi_analysis_storage}\pysiglinewithargsret{\bfcode{get\_omsi\_analysis\_storage}}{}{}
Get a list of known locations where this analysis has been saved.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of \emph{omsi.dataformat.omsi\_file.analysis. omsi\_file\_analysis} objects where the analysis is saved.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_parameter\_data() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_parameter_data}\pysiglinewithargsret{\bfcode{get\_parameter\_data}}{\emph{index}}{}
Given the index return the associated dataset to be written to the HDF5 file

:param index : Return the index entry of the private member parameters.

\end{fulllineitems}

\index{get\_parameter\_data\_by\_name() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_parameter_data_by_name}\pysiglinewithargsret{\bfcode{get\_parameter\_data\_by\_name}}{\emph{dataname}}{}
Given the key name of the data return the associated parameter\_data object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{dataname}} -- Name of the parameter requested from the parameters member.

\item[{Returns}] \leavevmode
The parameter\_data object or None if not found

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_parameter\_names() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_parameter_names}\pysiglinewithargsret{\bfcode{get\_parameter\_names}}{}{}
Get a list of all parameter dataset names (including those that may define
dependencies.

\end{fulllineitems}

\index{get\_profile\_stats\_object() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.get_profile_stats_object}\pysiglinewithargsret{\bfcode{get\_profile\_stats\_object}}{\emph{consolidate=True}, \emph{stream=None}}{}
Based on the execution profile of the execute\_analysis(..) function get
\code{pstats.Stats} object to help with the interpretation of the data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{consolidate}} -- Boolean flag indicating whether multiple stats (e.g., from multiple cores)
should be consolidated into a single stats object. Default is True.

\item {} 
\textbf{\texttt{stream}} -- The optional stream parameter to be used fo the pstats.Stats object.

\end{itemize}

\item[{Returns}] \leavevmode
A single pstats.Stats object if consolidate is True. Otherwise the function
returns a list of pstats.Stats objects, one per recorded statistic. None is returned
in case that the stats objects cannot be created or no profiling data is available.

\end{description}\end{quote}

\end{fulllineitems}

\index{has\_omsi\_analysis\_storage() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.has_omsi_analysis_storage}\pysiglinewithargsret{\bfcode{has\_omsi\_analysis\_storage}}{}{}
Check whether a storage location is known where the anlaysis has been saved.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Boolean indicating whether self.omsi\_analysis\_storage is not empty

\end{description}\end{quote}

\end{fulllineitems}

\index{keys() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.keys}\pysiglinewithargsret{\bfcode{keys}}{}{}
Get a list of all valid keys, i.e., a combination of all input parameter and output names.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of strings with all input parameter and output names.

\end{description}\end{quote}

\end{fulllineitems}

\index{locate\_analysis() (omsi.analysis.analysis\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.locate_analysis}\pysiglinewithargsret{\strong{classmethod }\bfcode{locate\_analysis}}{\emph{data\_object}, \emph{include\_parameters=False}}{}
Given a data\_object try to locate the analysis that creates the object as an
output of its execution (and optionally analyses that have the object as an input).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data\_object}} -- The data object of interest.

\item {} 
\textbf{\texttt{include\_parameters}} -- Boolean indicating whether also input parameters should be considered
in the search in addition to the outputs of an analysis

\end{itemize}

\item[{Returns}] \leavevmode
dependency\_dict pointing to the relevant object or None in case the
object was not found.

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_from\_omsi\_file() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.read_from_omsi_file}\pysiglinewithargsret{\bfcode{read\_from\_omsi\_file}}{\emph{analysis\_object}, \emph{load\_data=True}, \emph{load\_parameters=True}, \emph{load\_runtime\_data=True}, \emph{dependencies\_omsi\_format=True}, \emph{ignore\_type\_conflict=False}}{}
This function can be optionally overwritten to implement a custom data read.

The default implementation tries to reconstruct the original data as far
as possible, however, in particular in case that a custom add\_custom\_data\_to\_omsi\_file
function has been implemented, the default implementation may not be sufficient.
The default implementation reconstructs: i) analysis\_identifier and reads all
custom data into iii)\_\_data\_list. Note, an error will be raised in case that
the analysis type specified in the HDF5 file does not match the analysis type
specified by get\_analysis\_type()
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object associated with the hdf5 data group with             the analysis data\_list

\item {} 
\textbf{\texttt{load\_data}} -- Should the analysis data be loaded from file (default) or just stored as h5py data objects

\item {} 
\textbf{\texttt{load\_parameters}} -- Should parameters be loaded from file (default) or just stored as h5py data objects.

\item {} 
\textbf{\texttt{load\_runtime\_data}} -- Should runtime data be loaded from file (default) or just stored as h5py data objects

\item {} 
\textbf{\texttt{dependencies\_omsi\_format}} -- Should dependencies be loaded as omsi\_file API objects (default)
or just as h5py objects.

\item {} 
\textbf{\texttt{ignore\_type\_conflict}} -- Set to True to allow the analysis to be loaded into the
current analysis object even if the type indicated in the file does not match the
class. Default value is False. This behavior can be useful when different analysis
have compatible data structures or when we want to load the data in to a generic
analysis container, e.g, analysis\_generic.

\end{itemize}

\item[{Returns bool}] \leavevmode
Boolean indicating whether the data was read successfully

\item[{Raise}] \leavevmode
TypeError : A type error will be raised in case that the analysis type specified         by the file does not match the analysis type provided by self.get\_analysis\_type()

\end{description}\end{quote}

\end{fulllineitems}

\index{record\_execute\_analysis\_outputs() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.record_execute_analysis_outputs}\pysiglinewithargsret{\bfcode{record\_execute\_analysis\_outputs}}{\emph{analysis\_output}}{}
Function used internally by execute to record the output
of the custom execute\_analysis(...) function to the \_\_data\_list.

This function may be overwritten in child classes in order to
customize the behavior for recording data outputs. Eg., for some
analyses one may only want to record a particular set of outputs,
rather than all outputs generated by the analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_output}} -- The output of the execute\_analysis(...) function to be recorded

\end{description}\end{quote}

\end{fulllineitems}

\index{results\_ready() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.results_ready}\pysiglinewithargsret{\bfcode{results\_ready}}{}{}
Check whether the results of the analysis are ready to be used
:return: Boolean

\end{fulllineitems}

\index{set\_analysis\_identifier() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.set_analysis_identifier}\pysiglinewithargsret{\bfcode{set\_analysis\_identifier}}{\emph{identifier}}{}
Set the name of the analysis to identifer

Side Effects: This function modifies self.analysis\_identifier
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{identifier}} (\emph{\texttt{str}}) -- The new analysis identifier string to be used (should be unique)

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_parameter\_values() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.set_parameter_values}\pysiglinewithargsret{\bfcode{set\_parameter\_values}}{\emph{**kwargs}}{}
Set all parameters given as input to the function. The inputs
are placed in the self.parameters list. If the parameter refers
to an existing h5py.Dataset, h5py.Group,  managed h5py object,
or is an instance of an existing omis\_analysi\_base object, then
a dependency\_dict will be created and stored as value instead.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{kwargs}} -- Dictionary of keyword arguments. All keys are
expected to be strings. All values are expected to be
either i) numpy arrays, ii) int, float, str or unicode
variables, iii) h5py.Dataset or  h5py.Group, iv) or any
the omsi\_file API class objects. For iii) and iv) one
may provide a tuple consisting of the dataobject t{[}0{]} and
an additional selection string t{[}1{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_analysis\_parameters() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.update_analysis_parameters}\pysiglinewithargsret{\bfcode{update\_analysis\_parameters}}{\emph{**kwargs}}{}
Record the analysis parameters passed to the execute() function.

The default implementation simply calls the set\_parameter\_values(...) function.
This function may be overwritten to customize the behavior of how parameters
are recorded by the execute function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{kwargs}} -- Dictionary of keyword arguments with the parameters passed to the execute(..) function

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.analysis\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Get the mz axes for the analysis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{qslice\_viewer\_option}} -- If multiple default viewer behaviors are available for a given
analysis then this option is used to switch between them for the qslice URL pattern.

\item {} 
\textbf{\texttt{qspectrum\_viewer\_option}} -- If multiple default viewer behaviors are available for a
given analysis then this option is used to switch between them for the qspectrum URL pattern.

\end{itemize}

\item[{Returns}] \leavevmode

The following four arrays are returned by the analysis:
\begin{itemize}
\item {} 
mzSpectra : Array with the static mz values for the spectra.

\item {} 
labelSpectra : Label for the spectral mz axis

\item {} 
mzSlice : Array of the static mz values for the slices or None if identical to the mzSpectra.

\item {} 
labelSlice : Label for the slice mz axis or None if identical to labelSpectra.

\item {} 
values\_x: The values for the x axis of the image (or None)

\item {} 
label\_x: Label for the x axis of the image

\item {} 
values\_y: The values for the y axis of the image (or None)

\item {} 
label\_y: Label for the y axis of the image

\item {} 
values\_z: The values for the z axis of the image (or None)

\item {} 
label\_z: Label for the z axis of the image

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.analysis\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Get 3D analysis dataset for which z-slices should be extracted for presentation in the OMSI viewer
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{z}} -- Selection string indicting which z values should be selected.

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis
then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode
numpy array with the data to be displayed in the image slice viewer. Slicing will be
performed typically like {[}:,:,zmin:zmax{]}.

\item[{Raises}] \leavevmode
NotImplementedError in case that v\_qslice is not supported by the analysis.

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.analysis\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qslice.
The default implementation tries to take care of handling the spectra retrieval for all the dependencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.  For most cases
this is not needed here as the support for slice operations is usually a static decission based on
the class type, however, in some cases additional checks may be needed (e.g., ensure that the required
data is available).

\item[{Returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be empty
if the analysis does not support qslice requests (i.e., v\_qslice(...) is not available).

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.analysis\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Get from which 3D analysis spectra in x/y should be extracted for presentation in the OMSI viewer

\textbf{Developer Note:} h5py currently supports only a single index list. If the user provides an index-list
for both x and y, then we need to construct the proper merged list and load the data manually, or if
the data is small enough, one can load the full data into a numpy array which supports
multiple lists in the selection.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{x}} -- x selection string

\item {} 
\textbf{\texttt{y}} -- y selection string

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given
analysis then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode

The following two elements are expected to be returned by this function :
\begin{enumerate}
\item {} 
1D, 2D or 3D numpy array of the requested spectra. NOTE: The mass (m/z) axis must be                 the last axis. For index selection x=1,y=1 a 1D array is usually expected. For indexList                 selections x={[}0{]}\&y={[}1{]} usually a 2D array is expected. For ragne selections x=0:1\&y=1:2 we                 one usually expects a 3D array.

\item {} 
None in case that the spectra axis returned by v\_qmz are valid for the returned spectrum.                 Otherwise, return a 1D numpy array with the m/z values for the spectrum (i.e., if custom m/z                 values are needed for interpretation of the returned spectrum).This may be needed, e.g., in                 cases where a per-spectrum peak analysis is performed and the peaks for each spectrum appear                 at different m/z values.

\end{enumerate}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.analysis\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qspectrum.
The default implementation tries to take care of handling the spectra retrieval for all the dependencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.
For most cases this is not needed here as the support for slice operations is usually a static decision
based on the class type, however, in some cases additional checks may be needed (e.g., ensure that the
required data is available).

\item[{Returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be empty if
the analysis does not support qspectrum requests (i.e., v\_qspectrum(...) is not available).

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_analysis\_data() (omsi.analysis.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_base.write_analysis_data}\pysiglinewithargsret{\bfcode{write\_analysis\_data}}{\emph{analysis\_group=None}}{}
This function is used to write the actual analysis data to file. If not implemented, then the
omsi\_file\_analysis API's default behavior is used instead.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_group}} -- The h5py.Group object where the analysis is stored. May be None on cores that
do not perform any writing but which need to participate in communication, e.g., to collect data
for writing.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{AnalysisReadyError}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.AnalysisReadyError}\pysiglinewithargsret{\strong{exception }\code{omsi.analysis.}\bfcode{AnalysisReadyError}}{\emph{value}, \emph{params=None}}{}
Bases: \code{exceptions.Exception}

Custom exception used to indicate that an analysis is not ready to execute.

Initialize the AnalysisReadyError
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{value}} -- Error message string

\item {} 
\textbf{\texttt{params}} -- Optional list of dependent parameters that are not ready to be used.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{analysis\_generic (class in omsi.analysis)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_generic}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.}\bfcode{analysis\_generic}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

This analysis class is used if the specific anlaysis type is unknown, e.g., when loading
custom user-defined analysis data that may have not be available in the standard
omsi package used.

Initialize the basic data members
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{name\_key}} -- The name for the analysis

\end{description}\end{quote}
\index{DEFAULT\_OUTPUT\_PREFIX (omsi.analysis.analysis\_generic attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_generic.DEFAULT_OUTPUT_PREFIX}\pysigline{\bfcode{DEFAULT\_OUTPUT\_PREFIX}\strong{ = `output\_'}}
\end{fulllineitems}

\index{execute() (omsi.analysis.analysis\_generic method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_generic.execute}\pysiglinewithargsret{\bfcode{execute}}{\emph{**kwargs}}{}
Overwrite the default implementation of execute to update parameter specifications/types
when wrapping functions where the types are not known a priori.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{kwargs}} -- Custom analysis parameters

\item[{Returns}] \leavevmode
The result of execute\_analysis()

\end{description}\end{quote}

\end{fulllineitems}

\index{execute\_analysis() (omsi.analysis.analysis\_generic method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_generic.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
Nothing to do here.

\end{fulllineitems}

\index{from\_function() (omsi.analysis.analysis\_generic class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_generic.from_function}\pysiglinewithargsret{\strong{classmethod }\bfcode{from\_function}}{\emph{analysis\_function}, \emph{output\_names=None}, \emph{parameter\_specs=None}, \emph{name\_key='undefined'}}{}
Create a generic analysis class for a given analysis function.

This functionality is useful to ease quick scripting on analyses but should not be used in production.

NOTE: \_\_analysis\_function is a reserved parameter name used to store the analysis function and may
not be used as an input parameter for the analysis function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_function}} -- The analysis function to be wrapped for provenance tracking and storage

\item {} 
\textbf{\texttt{output\_names}} -- Optionally, define a list of the names of the outputs

\item {} 
\textbf{\texttt{parameter\_specs}} -- Optional list of omsi.datastructures.analysis\_data.parameter\_data with
additional information about the parameters of the function.

\item {} 
\textbf{\texttt{name\_key}} -- The name for the analysis, i.e., the analysis  identifier

\end{itemize}

\item[{Returns}] \leavevmode
A new generic analysis class

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_analysis\_type() (omsi.analysis.analysis\_generic class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_generic.get_analysis_type}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_analysis\_type}}{}{}
Return a string indicating the type of analysis performed

\end{fulllineitems}

\index{get\_real\_analysis\_type() (omsi.analysis.analysis\_generic method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_generic.get_real_analysis_type}\pysiglinewithargsret{\bfcode{get\_real\_analysis\_type}}{}{}
This class is designed to handle generic (including unkown) types of analysis.
In cases, e.g., were this class is used to store analysis data from an HDF5
file we may have an actual analysis type available even if we do not have
a special analysis class may not be available in the current installation

\end{fulllineitems}

\index{read\_from\_omsi\_file() (omsi.analysis.analysis\_generic method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_generic.read_from_omsi_file}\pysiglinewithargsret{\bfcode{read\_from\_omsi\_file}}{\emph{analysis\_object}, \emph{load\_data=True}, \emph{load\_parameters=True}, \emph{load\_runtime\_data=True}, \emph{dependencies\_omsi\_format=True}, \emph{ignore\_type\_conflict=False}}{}
See \emph{omsi.analysis.analysis\_base.read\_from\_omsi\_file(...)} for details.
The function is overwritten here mainly to initialize the self.real\_analysis\_type
instance variable but otherwise uses the default behavior.

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.analysis\_generic class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_generic.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Implement support for qmz URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.analysis\_generic class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_generic.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Implement support for qslice URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.analysis\_generic class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_generic.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.analysis\_generic class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_generic.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Implement support for qspectrum URL requests for the viewer

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.analysis\_generic class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_generic.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{write\_analysis\_data() (omsi.analysis.analysis\_generic method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_generic.write_analysis_data}\pysiglinewithargsret{\bfcode{write\_analysis\_data}}{\emph{analysis\_group=None}}{}
This function is used to write the actual analysis data to file. If not implemented, then the
omsi\_file\_analysis API's default behavior is used instead.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_group}} -- The h5py.Group object where the analysis is stored. May be None on cores that
do not perform any writing but which need to participate in communication, e.g., to collect data
for writing.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_findpeaks\_global (class in omsi.analysis)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_findpeaks_global}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.}\bfcode{omsi\_findpeaks\_global}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Basic global peak detection analysis. The default implementation
computes the peaks on the average spectrum and then computes the peak-cube data,
i.e., the values for the detected peaks at each pixel.

TODO: The current version assumes 2D data

Initialize the basic data members
\index{execute\_analysis() (omsi.analysis.omsi\_findpeaks\_global method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_findpeaks_global.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
Execute the global peak finding for the given msidata and mzdata.

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.omsi\_findpeaks\_global class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_findpeaks_global.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Implement support for qmz URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.omsi\_findpeaks\_global class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_findpeaks_global.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Implement support for qslice URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.omsi\_findpeaks\_global class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_findpeaks_global.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.omsi\_findpeaks\_global class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_findpeaks_global.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Implement support for qspectrum URL requests for the viewer

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.omsi\_findpeaks\_global class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_findpeaks_global.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_findpeaks\_local (class in omsi.analysis)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_findpeaks_local}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.}\bfcode{omsi\_findpeaks\_local}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Class defining a basic gloabl peak finding. The default implementation computes the peaks on the average
spectrum and then computes the peak-cube data, i.e., the values for the detected peaks at each pixel.

TODO: The current version assumes 2D data

Initialize the basic data members
\index{execute\_analysis() (omsi.analysis.omsi\_findpeaks\_local method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_findpeaks_local.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{\emph{msidata\_subblock=None}}{}
Execute the local peak finder for the given msidata.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{msidata\_subblock}} -- Optional input parameter used for parallel execution of the
analysis only. If msidata\_subblock is set, then the given subblock will be processed
in SERIAL instead of processing self{[}'msidata'{]} in PARALLEL (if available). This
parameter is strictly optional and intended for internal use only.

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.omsi\_findpeaks\_local class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_findpeaks_local.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Implement support for qmz URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.omsi\_findpeaks\_local class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_findpeaks_local.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Implement support for qslice URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.omsi\_findpeaks\_local class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_findpeaks_local.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.omsi\_findpeaks\_local class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_findpeaks_local.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Implement support for qspectrum URL requests for the viewer

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.omsi\_findpeaks\_local class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_findpeaks_local.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{write\_analysis\_data() (omsi.analysis.omsi\_findpeaks\_local method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_findpeaks_local.write_analysis_data}\pysiglinewithargsret{\bfcode{write\_analysis\_data}}{\emph{analysis\_group=None}}{}
This function is used to write the actual analysis data to file. If not implemented, then the
omsi\_file\_analysis API's default behavior is used instead.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_group}} -- The h5py.Group object where the analysis is stored.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_nmf (class in omsi.analysis)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_nmf}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.}\bfcode{omsi\_nmf}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Class defining a basic nmf analysis.

The function has primarily been tested we MSI datasets but should support
arbitrary n-D arrays (n\textgreater{}=2). The last dimension of the input array must be the
spectrum dimnensions.

Initalize the basic data members
\index{execute\_analysis() (omsi.analysis.omsi\_nmf method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_nmf.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
Execute the nmf for the given msidata

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.omsi\_nmf class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_nmf.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Implement support for qmz URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.omsi\_nmf class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_nmf.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Implement support for qslice URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.omsi\_nmf class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_nmf.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.omsi\_nmf class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_nmf.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Implement support for qspectrum URL requests for the viewer

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.omsi\_nmf class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_nmf.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_cx (class in omsi.analysis)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_cx}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.}\bfcode{omsi\_cx}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Class used to implement CX factorization on MSI data.

Initalize the basic data members
\index{comp\_lev\_exact() (omsi.analysis.omsi\_cx class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_cx.comp_lev_exact}\pysiglinewithargsret{\strong{classmethod }\bfcode{comp\_lev\_exact}}{\emph{A}, \emph{k}, \emph{axis}}{}
This function computes the column or row leverage scores of the input matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{A}} -- n-by-d matrix

\item {} 
\textbf{\texttt{k}} -- rank parameter, k \textless{}= min(n,d)

\item {} 
\textbf{\texttt{axis}} -- 0: compute row leverage scores; 1: compute column leverage scores.

\end{itemize}

\item[{Returns}] \leavevmode
1D array of leverage scores. If axis = 0, the length of lev is n.  otherwise, the length of lev is d.

\end{description}\end{quote}

\end{fulllineitems}

\index{dimension\_index (omsi.analysis.omsi\_cx attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_cx.dimension_index}\pysigline{\bfcode{dimension\_index}\strong{ = \{`pixelDim': 1, `imageDim': 0\}}}
\end{fulllineitems}

\index{execute\_analysis() (omsi.analysis.omsi\_cx method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_cx.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
EDIT\_ME:

Replace this text with the appropriate documentation for the analysis.
Describe what your analysis does and how a user can use it. Note, a user will
call the function execute(...) which takes care of storing parameters, collecting
execution data etc., so that you only need to implement your analysis, the rest
is taken care of by analysis\_base. omsi uses Sphynx syntax for the
documentation.

Keyword Arguments:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{mydata}} -- 
...


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.omsi\_cx class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_cx.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Get the mz axes for the analysis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{qslice\_viewer\_option}} -- If multiple default viewer behaviors are available for a given
analysis then this option is used to switch between them for the qslice URL pattern.

\item {} 
\textbf{\texttt{qspectrum\_viewer\_option}} -- If multiple default viewer behaviors are available for a
given analysis then this option is used to switch between them for the qspectrum URL pattern.

\end{itemize}

\item[{Returns}] \leavevmode

The following four arrays are returned by the analysis:
\begin{itemize}
\item {} 
mz\_spectra : Array with the static mz values for the spectra.

\item {} 
label\_spectra : Lable for the spectral mz axis

\item {} 
mz\_slice : Array of the static mz values for the slices or None if identical to the mz\_spectra.

\item {} 
label\_slice : Lable for the slice mz axis or None if identical to label\_spectra.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.omsi\_cx class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_cx.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Get 3D analysis dataset for which z-slices should be extracted for presentation in the OMSI viewer
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{z}} -- Selection string indicting which z values should be selected.

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis
then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode
numpy array with the data to be displayed in the image slice viewer. Slicing will
be performed typically like {[}:,:,zmin:zmax{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.omsi\_cx class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_cx.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qslice.
The default implementation tries to take care of handling the spectra retrieval for all the depencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.  For
most cases this is not needed here as the support for slice operations is usually a static decision
based on the class type, however, in some cases additional checks may be needed (e.g., ensure that
the required data is available).

\item[{Returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be empty
if the analysis does not support qslice requests (i.e., v\_qslice(...) is not available).

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.omsi\_cx class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_cx.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Get from which 3D analysis spectra in x/y should be extracted for presentation in the OMSI viewer
\begin{description}
\item[{Developer Note: h5py currently supports only a single index list. If the user provides an index-list for both}] \leavevmode
x and y, then we need to construct the proper merged list and load the data manually, or if
the data is small enough, one can load the full data into a numpy array which supports
mulitple lists in the selection.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{x}} -- x selection string

\item {} 
\textbf{\texttt{y}} -- y selection string

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis then
this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode

The following two elemnts are expected to be returned by this function :
\begin{enumerate}
\item {} 
1D, 2D or 3D numpy array of the requested spectra. NOTE: The mass (m/z) axis must be the last                 axis. For index selection x=1,y=1 a 1D array is usually expected. For indexList selections x={[}0{]}\&y={[}1{]}                 usually a 2D array is expected. For ragne selections x=0:1\&y=1:2 we one usually expects a 3D array.

\item {} 
None in case that the spectra axis returned by v\_qmz are valid for the returned spectrum. Otherwise,                 return a 1D numpy array with the m/z values for the spectrum (i.e., if custom m/z values are needed                 for interpretation of the returned spectrum).This may be needed, e.g., in cases where a per-spectrum                 peak analysis is performed and the peaks for each spectrum appear at different m/z values.

\end{enumerate}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.omsi\_cx class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_cx.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qspectrum.
The default implementation tries to take care of handling the spectra retrieval for all the depencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.  For most cases
this is not needed here as the support for slice operations is usually a static decission based on the
class type, however, in some cases additional checks may be needed (e.g., ensure that the
required data is available).

\item[{Returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be empty
if the analysis does not support qspectrum requests (i.e., v\_qspectrum(...) is not available).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_kmeans (class in omsi.analysis)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_kmeans}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.}\bfcode{omsi\_kmeans}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Class defining a basic nmf analysis for a 2D MSI data file or slice of the data

Initalize the basic data members
\index{execute\_analysis() (omsi.analysis.omsi\_kmeans method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_kmeans.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
Execute the kmeans clustering for the given msidata

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_tic\_norm (class in omsi.analysis)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_tic_norm}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.}\bfcode{omsi\_tic\_norm}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

TIC Normalization analysis.

Initalize the basic data members
\index{execute\_analysis() (omsi.analysis.omsi\_tic\_norm method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_tic_norm.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
Normalize the data based on the total intensity of a spectrum or the
intensities of a select set of ions.

Calculations are performed using a memory map approach to avoid loading
all data into memory. TIC normalization can as such be performed even
on large files (assuming sufficient disk space).

Keyword Arguments:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{msidata}} (\emph{\texttt{h5py.dataset or numpu array (3D)}}) -- The input MSI dataset

\item {} 
\textbf{\texttt{mzdata}} -- The mz axsis do the dataset

\item {} 
\textbf{\texttt{maxCount}} -- 
...


\item {} 
\textbf{\texttt{mzTol}} -- 
...


\item {} 
\textbf{\texttt{infIons}} -- List of informative ions

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{record\_execute\_analysis\_outputs() (omsi.analysis.omsi\_tic\_norm method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_tic_norm.record_execute_analysis_outputs}\pysiglinewithargsret{\bfcode{record\_execute\_analysis\_outputs}}{\emph{analysis\_output}}{}
We are not returning any outputs here, but we are going to record them manually.
:param analysis\_output: The output of the execute\_analysis(...) function.

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.omsi\_tic\_norm class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_tic_norm.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Get the mz axes for the analysis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{qslice\_viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis then
this option is used to switch between them for the qslice URL pattern.

\item {} 
\textbf{\texttt{qspectrum\_viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis
then this option is used to switch between them for the qspectrum URL pattern.

\end{itemize}

\item[{Returns}] \leavevmode

The following four arrays are returned by the analysis:
\begin{itemize}
\item {} 
mz\_spectra : Array with the static mz values for the spectra.

\item {} 
label\_spectra : Lable for the spectral mz axis

\item {} 
mz\_slice : Array of the static mz values for the slices or None if identical to the mz\_spectra.

\item {} 
label\_slice : Lable for the slice mz axis or None if identical to label\_spectra.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.omsi\_tic\_norm class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_tic_norm.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Get 3D analysis dataset for which z-slices should be extracted for presentation in the OMSI viewer
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{z}} -- Selection string indicting which z values should be selected.

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis
then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode
numpy array with the data to be displayed in the image slice viewer. Slicing will
be performed typically like {[}:,:,zmin:zmax{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.omsi\_tic\_norm class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_tic_norm.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qslice.
The default implementation tries to take care of handling the spectra retrieval for all the depencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.  For
most cases this is not needed here as the support for slice operations is usually a static
decision based on the class type, however, in some cases additional checks may be needed (e.g.,
ensure that the required data is available).

\item[{Returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be empty if
the analysis does not support qslice requests (i.e., v\_qslice(...) is not available).

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.omsi\_tic\_norm class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_tic_norm.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Get from which 3D analysis spectra in x/y should be extracted for presentation in the OMSI viewer
\begin{description}
\item[{Developer Note: h5py currently supports only a single index list. If the user provides an index-list for both}] \leavevmode
x and y, then we need to construct the proper merged list and load the data manually, or if
the data is small enough, one can load the full data into a numpy array which supports
multiple lists in the selection.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{x}} -- x selection string

\item {} 
\textbf{\texttt{y}} -- y selection string

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis then
this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode

The following two elements are expected to be returned by this function :
\begin{enumerate}
\item {} 
1D, 2D or 3D numpy array of the requested spectra. NOTE: The mass (m/z) axis must be the last                   axis. For index selection x=1,y=1 a 1D array is usually expected. For indexList selections                   x={[}0{]}\&y={[}1{]} usually a 2D array is expected. For ragne selections x=0:1\&y=1:2 we one usually                  expects a 3D array/

\item {} 
None in case that the spectra axis returned by v\_qmz are valid for the returned spectrum.                  Otherwise, return a 1D numpy array with the m/z values for the spectrum (i.e., if custom m/z                  values are needed for interpretation of the returned spectrum).This may be needed, e.g., in                  cases where a per-spectrum peak analysis is performed and the peaks for each spectrum appear                  at different m/z values.

\end{enumerate}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.omsi\_tic\_norm class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.omsi_tic_norm.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qspectrum.
The default implementation tries to take care of handling the spectra retrieval for all the depencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}
\begin{quote}\begin{description}
\item[{param analysis\_object}] \leavevmode
The omsi\_file\_analysis object for which slicing should be performed.  For most cases
this is not needed here as the support for slice operations is usually a static decission based
on the class type, however, in some cases additional checks may be needed (e.g., ensure that
the required data is available).

\item[{returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be empty
if the analysis does not support qspectrum requests (i.e., v\_qspectrum(...) is not available).

\end{description}\end{quote}
\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{\texttt{base} Module}
\label{omsi.analysis:base-module}\label{omsi.analysis:module-omsi.analysis.base}\index{omsi.analysis.base (module)}
Module specifying the base analysis API for integrating new analysis with the toolkit and the
OpenMSI science gateway.
\index{AnalysisReadyError}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.AnalysisReadyError}\pysiglinewithargsret{\strong{exception }\code{omsi.analysis.base.}\bfcode{AnalysisReadyError}}{\emph{value}, \emph{params=None}}{}
Bases: \code{exceptions.Exception}

Custom exception used to indicate that an analysis is not ready to execute.

Initialize the AnalysisReadyError
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{value}} -- Error message string

\item {} 
\textbf{\texttt{params}} -- Optional list of dependent parameters that are not ready to be used.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{analysis\_base (class in omsi.analysis.base)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base}\pysigline{\strong{class }\code{omsi.analysis.base.}\bfcode{analysis\_base}}
Bases: {\hyperref[omsi.datastructures:omsi.datastructures.analysis_data.parameter_manager]{\emph{\code{omsi.datastructures.analysis\_data.parameter\_manager}}}}

Base class for omsi analysis functionality. The class provides a large set of functionality designed
to facilitate storage of analysis data in the omsi HDF5 file format. The class also provides a set
of functions to enable easy intergration of new analysis with the OpenMSI web-based viewer (see
Viewer functions below for details).

\textbf{Slicing:}

This class supports basic slicing to access data stored in the main member variables. By
default the data is retrieved from \_\_data\_list and the \_\_getitem\_\_(key) function. which implements
the {[}..{]} operator, returns \_\_data\_list{[}key{]}{[}'data'{]}. The key is a string indicating the name of
the parameter to be retrieved. If the key is not found in the \_\_data\_list then the function will
try to retrieve the data from self.parameters list instead. By adding ``parameter/key'' or ``dependency/key''
one may also explicitly retrieve values from the parameters.

\textbf{Instance Variables:}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_analysis.analysis_identifier]{\emph{\textbf{\texttt{analysis\_identifier}}}}} -- Define the name for the analysis used as key in search operations

\item {} 
\textbf{\texttt{\_\_data\_list}} -- List of analysis\_data to be written to the HDF5 file. Derived classes
need to add all data that should be saved for the analysis in the omsi HDF5 file to this dictionary.
See omsi.analysis.analysis\_data for details.

\item {} 
\textbf{\texttt{parameters}} -- List of parameter\_data objects of all  analysis parameters
(including those that may have dependencies).

\item {} 
\textbf{\texttt{data\_names}} -- List of strings of all names of analysis output datasets. These are the
target keys for \_\_data\_list.

\item {} 
\textbf{\texttt{profile\_time\_and\_usage}} -- Boolean indicating whether we should profile the execute\_analysis(...) function
when called as part of the execute(...) function. The default value is false. Use the
enable\_time\_and\_usage\_profiling(..) function to determine which profiling should be performed. The time\_and
\_usage profile uses pythons cProfile (or Profile) to monitor how often and for how long particular parts
of the analysis code executed.

\item {} 
\textbf{\texttt{profile\_memory}} -- Boolean indicating whether we should monitor memory usage (line-by-line) when
executing the execute\_analysis(...) function. The default value is false. Use the
enable\_time\_and\_usage\_profiling(..) function to determine which profiling should be performed.

\item {} 
\textbf{\texttt{omsi\_analysis\_storage}} -- List of omsi\_file\_analysis object where the analysis is stored. The list may be empty.

\item {} 
\textbf{\texttt{mpi\_comm}} -- In case we are running with MPI, this is the MPI communicator used for runnign the analysis.
Default is MPI.Comm\_world/

\item {} 
\textbf{\texttt{mpi\_root}} -- In case we are running with MPI, this is the root rank where data is collected to (e.g., runtime
data and analysis results)

\item {} 
\textbf{\texttt{update\_analysis}} -- If the value is True, then we should execute the analysis before using the outputs.
If False, then the analysis has been executed with the current parameter settings.

\item {} 
{\hyperref[omsi.workflow.driver:module\string-omsi.workflow.driver]{\emph{\textbf{\texttt{driver}}}}} -- Workflow driver to be used when executing multiple analyses, e.g., via execute\_recursive or
execute\_all. Default value is None in which case a new default driver will be used each time we
execute a workflow.

\end{itemize}

\end{description}\end{quote}

\textbf{Execution Functions:}
\begin{itemize}
\item {} 
\code{execute} : Then main function the user needs to call in order to execute the analysis

\item {} 
{\color{red}\bfseries{}{}`{}`}execute\_analysis: This function needs to be implemented by child classes of \emph{analysis\_base}         to implement the specifics of executing the analysis.

\end{itemize}

\textbf{I/O functions:}

These functions can be optionally overwritten to control how the analysis data should be written/read
from the omsi HDF5 file. Default implementations are provided here, which should be sufficient for most cases.
\begin{itemize}
\item {} 
\code{add\_custom\_data\_to\_omsi\_file}: The default implementation is empty as the default data write is  managed by     the \emph{omsi\_file\_experiment.create\_analysis()} function.  Overwrite this function, in case that the analysis needs     to write data to the HDF5 omsi file beyond what the defualt omsi data API does.

\item {} 
\code{read\_from\_omsi\_file}: The default implementation tries to reconstruct the original data as far as possible,     however, in particular in case that a custom add\_custom\_data\_to\_omsi\_file function has been implemented, the     default implementation may not be sufficien. The default implementation reconstructs: i) analysis\_identifier     and reads all custom data into ii)\_\_data\_list. Note, an error will be raised in case that the analysis type     specified in the HDF5 file does not match the analysis type specified by get\_analysis\_type(). This function     can be optionally overwritten to implement a custom data read.

\end{itemize}

\textbf{Viewer functions:}

Several convenient functions are used to allow the OpenMSI online viewer to interact with the analysis     and to visualize it. The default implementations provided here simply indicate that the analysis does not     support the data access operations required by the online viewer. Overwrite these functions in the derived     analysis classes in order to interface them with the viewer. All viewer-related functions start with \code{v\textbackslash{}\_...} .

NOTE: the default implementation of the viewer functions defined in \code{analysis\_base} are     designed to take care of the common requirement for providing viewer access to data from all dependencies     of an analysis. In many cases, the default implementation is often sill called at the end of custom     viewer functions.

NOTE: The viewer functions typically support a viewer\_option parameter. viewer\_option=0 is expected to      refer to the analysis itself.
\begin{itemize}
\item {} 
\code{v\_qslice}: Retrieve/compute data slices as requested via qslice URL requests. The corresponding view     of the DJANGO data access server already translates all input parameters and takes care of generating images/plots     if needed. This function is only responsible for retrieving the data.

\item {} 
\code{v\_qspectrum}: Retrieve/compute spectra as requested via qspectrum URL requests. The corresponding view of     the DJANGO data access server already translates all input parameters and takes care of generating images/plots     if needed. This function is only responsible for retrieving the data.

\item {} 
\code{v\_qmz}: Define the m/z axes for image slices and spectra as requested by qspectrum URL requests.

\item {} 
\code{v\_qspectrum\_viewer\_options}: Define a list of strings, describing the different viewer options available     for the analysis for qspectrum requests (i.e., \code{v\_qspectrum}). This feature allows the analysis developer     to define multiple different visualization modes for the analysis. For example, when performing a data reduction     (e.g., PCA or NMF) one may want to show the raw spectra or the loadings vector of the projection in the spectrum     view (v\_qspectrum). By providing different viewer options we allow the user to decide which option they are     most interested in.

\item {} 
\code{v\_qslice\_viewer\_options}: Define a list of strings, describing the different viewer options available for     the analysis for qslice requests (i.e., \code{v\_qslice}). This feature allows the analysis developer to define     multiple different visualization modes for the analysis. For example, when performing a data reduction     (e.g., PCA or NMF) one may want to show the raw spectra or the loadings vector of the projection in the spectrum     view (v\_qspectrum). By providing different viewer options we allow the user to decide which option they     are most interested in.

\end{itemize}

Initialize the basic data members
\index{add\_custom\_data\_to\_omsi\_file() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.add_custom_data_to_omsi_file}\pysiglinewithargsret{\bfcode{add\_custom\_data\_to\_omsi\_file}}{\emph{analysis\_group}}{}
This function can be optionally overwritten to implement a custom data write
function for the analysis to be used by the omsi\_file API.

Note, this function should be used only to add additional data to the analysis
group. The data that is written by default is still written by
the \emph{omsi\_file\_experiment.create\_analysis()} function, i.e., the following data is
written by default: i) analysis\_identifier ,ii) get\_analysis\_type, iii)\_\_data\_list,
iv) parameters, v) runinfo . Since the \emph{omsi\_file.experiment.create\_analysis()}
functions takes care of setting up the basic structure of the analysis storage
(included the subgroubs for storing parameters and data dependencies) this setup can generally
be assumed to exist before this function is called. This function is called
automatically at the end omsi\_file.experiment.create\_analysis() (i.e, actually
\emph{omsi\_file\_analysis.\_\_populate\_analysis\_\_(..)} so that this function typically does not need to
be called explicitly.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_group}} -- The h5py.Group object where the analysis is stored.

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_parameter() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.add_parameter}\pysiglinewithargsret{\bfcode{add\_parameter}}{\emph{name}, \emph{help}, \emph{dtype=\textless{}type `unicode'\textgreater{}}, \emph{required=False}, \emph{default=None}, \emph{choices=None}, \emph{data=None}, \emph{group=None}}{}
Add a new parameter for the analysis. This function is typically used in the constructor
of a derived analysis to specify the parameters of the analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- The name of the parameter

\item {} 
\textbf{\texttt{help}} -- Help string describing the parameter

\item {} 
\textbf{\texttt{type}} -- Optional type. Default is string.

\item {} 
\textbf{\texttt{required}} -- Boolean indicating whether the parameter is required (True) or optional (False). Default False.

\item {} 
\textbf{\texttt{default}} -- Optional default value for the parameter. Default None.

\item {} 
\textbf{\texttt{choices}} -- Optional list of choices with allowed data values. Default None, indicating no choices set.

\item {} 
\textbf{\texttt{data}} -- The data assigned to the parameter. None by default.

\item {} 
\textbf{\texttt{group}} -- Optional group string used to organize parameters. Default None, indicating that
parameters are automatically organized by driver class (e.g. in required and optional parameters)

\end{itemize}

\item[{Raises}] \leavevmode
ValueError is raised if the parameter with the given name already exists.

\end{description}\end{quote}

\end{fulllineitems}

\index{analysis\_identifier\_defined() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.analysis_identifier_defined}\pysiglinewithargsret{\bfcode{analysis\_identifier\_defined}}{}{}
Check whether the analysis identifier is defined by the user, i.e., set to value different than undefined
:return: bool

\end{fulllineitems}

\index{check\_ready\_to\_execute() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.check_ready_to_execute}\pysiglinewithargsret{\bfcode{check\_ready\_to\_execute}}{}{}
Check if all inputs are ready to determine if the analysis is ready to run.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of omsi\_analysis\_parameter objects that are not ready. If the
returned list is empty, then the analysis is ready to run.

\end{description}\end{quote}

\end{fulllineitems}

\index{clear\_analysis() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.clear_analysis}\pysiglinewithargsret{\bfcode{clear\_analysis}}{}{}
Clear all analysis data---i.e., parameter, dependency data, output results, runtime data

\end{fulllineitems}

\index{clear\_analysis\_data() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.clear_analysis_data}\pysiglinewithargsret{\bfcode{clear\_analysis\_data}}{}{}
Clear the list of analysis data

\end{fulllineitems}

\index{clear\_and\_restore() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.clear_and_restore}\pysiglinewithargsret{\bfcode{clear\_and\_restore}}{\emph{analysis\_manager=None}, \emph{resave=False}}{}
Clear all analysis data and restore the results from file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_manager}} -- Instance of omsi\_analysis\_manager (e.g., an omsi\_file\_experiment) where the
analysis should be saved.

\item {} 
\textbf{\texttt{resave}} -- Boolean indicating whether the analysis should be saved again, even if it has been
saved before. This parameter only has effect if analysis\_manager is given.

\end{itemize}

\item[{Returns}] \leavevmode
self, i.e., the updated analysis object with all data replaced with HDF5 references

\end{description}\end{quote}

\end{fulllineitems}

\index{clear\_parameter\_data() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.clear_parameter_data}\pysiglinewithargsret{\bfcode{clear\_parameter\_data}}{}{}
Clear the list of parameter data

\end{fulllineitems}

\index{clear\_run\_info\_data() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.clear_run_info_data}\pysiglinewithargsret{\bfcode{clear\_run\_info\_data}}{}{}
Clear the runtime information data

\end{fulllineitems}

\index{define\_missing\_parameters() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.define_missing_parameters}\pysiglinewithargsret{\bfcode{define\_missing\_parameters}}{}{}
Called by the execute function before self.update\_analysis\_parameters
to set any required parameters that have not been defined to their respective default values.

This function may be overwritten in child classes to customize
the definition of default parameter values and to apply any
modifications (or checks) of parameters before the analysis is executed.
Any changes applied here will be recorded in the parameter of the analysis.

\end{fulllineitems}

\index{enable\_memory\_profiling() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.enable_memory_profiling}\pysiglinewithargsret{\bfcode{enable\_memory\_profiling}}{\emph{enable=True}}{}
Enable or disable line-by-line profiling of memory usage of execute\_analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{enable\_memory}} (\emph{\texttt{bool}}) -- Enable (True) or disable (False) line-by-line profiling of memory usage

\item[{Raises}] \leavevmode
ImportError is raised if a required package for profiling is not available.

\end{description}\end{quote}

\end{fulllineitems}

\index{enable\_time\_and\_usage\_profiling() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.enable_time_and_usage_profiling}\pysiglinewithargsret{\bfcode{enable\_time\_and\_usage\_profiling}}{\emph{enable=True}}{}
Enable or disable profiling of time and usage of code parts of execute\_analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{enable}} (\emph{\texttt{bool}}) -- Enable (True) or disable (False) profiling

\item[{Raises}] \leavevmode
ImportError is raised if a required package for profiling is not available.

\end{description}\end{quote}

\end{fulllineitems}

\index{execute() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.execute}\pysiglinewithargsret{\bfcode{execute}}{\emph{**kwargs}}{}
Use this function to run the analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{kwargs}} -- Parameters to be used for the analysis. Parameters may also be set using
the \_\_setitem\_\_ mechanism or as batches using the set\_parameter\_values function.

\item[{Returns}] \leavevmode
This function returns the output of the execute analysis function.

\item[{Raises}] \leavevmode
AnalysisReadyError in case that the analysis is not ready to be executed. This may be
the case, e.g, when a dependent input parameter is not ready to be used.

\end{description}\end{quote}

\end{fulllineitems}

\index{execute\_all() (omsi.analysis.base.analysis\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.execute_all}\pysiglinewithargsret{\strong{classmethod }\bfcode{execute\_all}}{\emph{force\_update=False}, \emph{executor=None}}{}
Execute all analysis instances that are currently defined.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{force\_update}} -- Boolean indicating whether we should force that all analyses are
executed again, even if they have already been run with the same settings before.
False by default.

\item {} 
\textbf{\texttt{executor}} -- Optional workflow executor to be used for the execution of all analyses.
The executor will be cleared and then all analyses will be added to executor. Default
value is None, in which case the function creates a default executor to be used.

\end{itemize}

\item[{Returns}] \leavevmode
The workflow executor used

\end{description}\end{quote}

\end{fulllineitems}

\index{execute\_analysis() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
Implement this function to implement the execution of the actual analysis.

This function may not require any input parameters. All input parameters are
recorded in the parameters and dependencies lists and should be retrieved
from there, e.g, using basic slicing self{[} paramName {]}

Input parameters may be added for internal use ONLY. E.g, we may add parameters that
are used internally to help with parallelization of the execute\_analysis function.
Such parameters are not recorded and must be strictly optional so that analysis\_base.execute(...)
can call the function.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
This function may return any developer-defined data. Note, all
output that should be recorded must be put into the data list.

\end{description}\end{quote}

\end{fulllineitems}

\index{execute\_recursive() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.execute_recursive}\pysiglinewithargsret{\bfcode{execute\_recursive}}{\emph{**kwargs}}{}
Recursively execute this analysis and all its dependencies if necessary

We use a workflow driver to control the execution. To define the workflow driver we can set
the self.driver variable. If no workflow driver is given (i.e, self.driver==None), then the
default driver will be created. To change the default driver,
see \emph{omsi.workflow.base.workflow\_executor\_base.DEFAULT\_EXECUTOR\_CLASS}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{kwargs}} -- Parameters to be used for the analysis. Parameters may also be set using
the \_\_setitem\_\_ mechanism or as batches using the set\_parameter\_values function.

\item[{Returns}] \leavevmode
Same as execute

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_analysis\_data() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_all_analysis_data}\pysiglinewithargsret{\bfcode{get\_all\_analysis\_data}}{}{}
Get the complete list of all analysis datasets to be written to the HDF5 file

\end{fulllineitems}

\index{get\_all\_dependency\_data() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_all_dependency_data}\pysiglinewithargsret{\bfcode{get\_all\_dependency\_data}}{}{}
Get the complete list of all direct dependencies to be written to the HDF5 file

NOTE: These are only the direct dependencies as specified by the analysis itself.
Use  get\_all\_dependency\_data\_recursive(..) to also get the indirect dependencies of
the analysis due to dependencies of the dependencies themselves.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of parameter\_data objects that define dependencies.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_parameter\_data() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_all_parameter_data}\pysiglinewithargsret{\bfcode{get\_all\_parameter\_data}}{\emph{exclude\_dependencies=False}}{}
Get the complete list of all parameter datasets to be written to the HDF5 file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{exclude\_dependencies}} -- Boolean indicating whether we should exclude parameters
that define dependencies from the list

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_run\_info() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_all_run_info}\pysiglinewithargsret{\bfcode{get\_all\_run\_info}}{}{}
Get the dict with the complete info about the last run of the analysis

\end{fulllineitems}

\index{get\_analysis\_data() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_analysis_data}\pysiglinewithargsret{\bfcode{get\_analysis\_data}}{\emph{index}}{}
Given the index return the associated dataset to be written to the HDF5 file

:param index : Retrun the index entry of the private member \_\_data\_list.

\end{fulllineitems}

\index{get\_analysis\_data\_by\_name() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_analysis_data_by_name}\pysiglinewithargsret{\bfcode{get\_analysis\_data\_by\_name}}{\emph{dataname}}{}
Given the key name of the data return the associated analysis\_data object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{dataname}} -- Name of the analysis data requested from the private \_\_data\_list member.

\item[{Returns}] \leavevmode
The analysis\_data object or None if not found.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_analysis\_data\_names() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_analysis_data_names}\pysiglinewithargsret{\bfcode{get\_analysis\_data\_names}}{}{}
Get a list of all analysis dataset names.

\end{fulllineitems}

\index{get\_analysis\_identifier() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_analysis_identifier}\pysiglinewithargsret{\bfcode{get\_analysis\_identifier}}{}{}
Return the name of the analysis used as key when searching for a particular analysis

\end{fulllineitems}

\index{get\_analysis\_instances() (omsi.analysis.base.analysis\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_analysis_instances}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_analysis\_instances}}{}{}
Generator function used to iterate through all instances of analysis\_base.
The function creates references for all weak references stored in cls.\_analysis\_instances
and returns the references if it exists and cleans up the any invalid references after the
iteration is complete.
:return: References to analysis\_base objects

\end{fulllineitems}

\index{get\_analysis\_type() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_analysis_type}\pysiglinewithargsret{\bfcode{get\_analysis\_type}}{}{}
Return a string indicating the type of analysis performed

\end{fulllineitems}

\index{get\_default\_dtypes() (omsi.analysis.base.analysis\_base static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_default_dtypes}\pysiglinewithargsret{\strong{static }\bfcode{get\_default\_dtypes}}{}{}
Get a list of available default dtypes used for analyses.
Same as \emph{data\_dtypes.get\_dtypes()}.

\end{fulllineitems}

\index{get\_default\_parameter\_groups() (omsi.analysis.base.analysis\_base static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_default_parameter_groups}\pysiglinewithargsret{\strong{static }\bfcode{get\_default\_parameter\_groups}}{}{}
Get a list of commonly used parameter groups and associated descriptions.

Use of default groups provides consistency and allows other system to
design custom behavior around the semantic of parameter groups
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Dictionary where the keys are the short names of the groups and the
values are dicts with following keys:value pairs: `name' , `description'.
Use the `name' to define the group to be used.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_help\_string() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_help_string}\pysiglinewithargsret{\bfcode{get\_help\_string}}{}{}
Get a string describing the analysis.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Help string describing the analysis and its parameters

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_memory\_profile\_info() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_memory_profile_info}\pysiglinewithargsret{\bfcode{get\_memory\_profile\_info}}{}{}
Based on the memory profile of the execute\_analysis(..) function get
the string describing the line-by-line memory usage.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
String describing the memory usage profile. None is returned in case that
no memory profiling data is available.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_num\_analysis\_data() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_num_analysis_data}\pysiglinewithargsret{\bfcode{get\_num\_analysis\_data}}{}{}
Retrun the number of analysis datasets to be wirtten to the HDF5 file

\end{fulllineitems}

\index{get\_num\_dependency\_data() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_num_dependency_data}\pysiglinewithargsret{\bfcode{get\_num\_dependency\_data}}{}{}
Return the number of dependencies to be wirtten to the HDF5 file

\end{fulllineitems}

\index{get\_num\_parameter\_data() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_num_parameter_data}\pysiglinewithargsret{\bfcode{get\_num\_parameter\_data}}{}{}
Return the number of parameter datasets to be wirtten to the HDF5 file

\end{fulllineitems}

\index{get\_omsi\_analysis\_storage() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_omsi_analysis_storage}\pysiglinewithargsret{\bfcode{get\_omsi\_analysis\_storage}}{}{}
Get a list of known locations where this analysis has been saved.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of \emph{omsi.dataformat.omsi\_file.analysis. omsi\_file\_analysis} objects where the analysis is saved.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_parameter\_data() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_parameter_data}\pysiglinewithargsret{\bfcode{get\_parameter\_data}}{\emph{index}}{}
Given the index return the associated dataset to be written to the HDF5 file

:param index : Return the index entry of the private member parameters.

\end{fulllineitems}

\index{get\_parameter\_data\_by\_name() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_parameter_data_by_name}\pysiglinewithargsret{\bfcode{get\_parameter\_data\_by\_name}}{\emph{dataname}}{}
Given the key name of the data return the associated parameter\_data object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{dataname}} -- Name of the parameter requested from the parameters member.

\item[{Returns}] \leavevmode
The parameter\_data object or None if not found

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_parameter\_names() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_parameter_names}\pysiglinewithargsret{\bfcode{get\_parameter\_names}}{}{}
Get a list of all parameter dataset names (including those that may define
dependencies.

\end{fulllineitems}

\index{get\_profile\_stats\_object() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.get_profile_stats_object}\pysiglinewithargsret{\bfcode{get\_profile\_stats\_object}}{\emph{consolidate=True}, \emph{stream=None}}{}
Based on the execution profile of the execute\_analysis(..) function get
\code{pstats.Stats} object to help with the interpretation of the data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{consolidate}} -- Boolean flag indicating whether multiple stats (e.g., from multiple cores)
should be consolidated into a single stats object. Default is True.

\item {} 
\textbf{\texttt{stream}} -- The optional stream parameter to be used fo the pstats.Stats object.

\end{itemize}

\item[{Returns}] \leavevmode
A single pstats.Stats object if consolidate is True. Otherwise the function
returns a list of pstats.Stats objects, one per recorded statistic. None is returned
in case that the stats objects cannot be created or no profiling data is available.

\end{description}\end{quote}

\end{fulllineitems}

\index{has\_omsi\_analysis\_storage() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.has_omsi_analysis_storage}\pysiglinewithargsret{\bfcode{has\_omsi\_analysis\_storage}}{}{}
Check whether a storage location is known where the anlaysis has been saved.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Boolean indicating whether self.omsi\_analysis\_storage is not empty

\end{description}\end{quote}

\end{fulllineitems}

\index{keys() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.keys}\pysiglinewithargsret{\bfcode{keys}}{}{}
Get a list of all valid keys, i.e., a combination of all input parameter and output names.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of strings with all input parameter and output names.

\end{description}\end{quote}

\end{fulllineitems}

\index{locate\_analysis() (omsi.analysis.base.analysis\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.locate_analysis}\pysiglinewithargsret{\strong{classmethod }\bfcode{locate\_analysis}}{\emph{data\_object}, \emph{include\_parameters=False}}{}
Given a data\_object try to locate the analysis that creates the object as an
output of its execution (and optionally analyses that have the object as an input).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data\_object}} -- The data object of interest.

\item {} 
\textbf{\texttt{include\_parameters}} -- Boolean indicating whether also input parameters should be considered
in the search in addition to the outputs of an analysis

\end{itemize}

\item[{Returns}] \leavevmode
dependency\_dict pointing to the relevant object or None in case the
object was not found.

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_from\_omsi\_file() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.read_from_omsi_file}\pysiglinewithargsret{\bfcode{read\_from\_omsi\_file}}{\emph{analysis\_object}, \emph{load\_data=True}, \emph{load\_parameters=True}, \emph{load\_runtime\_data=True}, \emph{dependencies\_omsi\_format=True}, \emph{ignore\_type\_conflict=False}}{}
This function can be optionally overwritten to implement a custom data read.

The default implementation tries to reconstruct the original data as far
as possible, however, in particular in case that a custom add\_custom\_data\_to\_omsi\_file
function has been implemented, the default implementation may not be sufficient.
The default implementation reconstructs: i) analysis\_identifier and reads all
custom data into iii)\_\_data\_list. Note, an error will be raised in case that
the analysis type specified in the HDF5 file does not match the analysis type
specified by get\_analysis\_type()
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object associated with the hdf5 data group with             the analysis data\_list

\item {} 
\textbf{\texttt{load\_data}} -- Should the analysis data be loaded from file (default) or just stored as h5py data objects

\item {} 
\textbf{\texttt{load\_parameters}} -- Should parameters be loaded from file (default) or just stored as h5py data objects.

\item {} 
\textbf{\texttt{load\_runtime\_data}} -- Should runtime data be loaded from file (default) or just stored as h5py data objects

\item {} 
\textbf{\texttt{dependencies\_omsi\_format}} -- Should dependencies be loaded as omsi\_file API objects (default)
or just as h5py objects.

\item {} 
\textbf{\texttt{ignore\_type\_conflict}} -- Set to True to allow the analysis to be loaded into the
current analysis object even if the type indicated in the file does not match the
class. Default value is False. This behavior can be useful when different analysis
have compatible data structures or when we want to load the data in to a generic
analysis container, e.g, analysis\_generic.

\end{itemize}

\item[{Returns bool}] \leavevmode
Boolean indicating whether the data was read successfully

\item[{Raise}] \leavevmode
TypeError : A type error will be raised in case that the analysis type specified         by the file does not match the analysis type provided by self.get\_analysis\_type()

\end{description}\end{quote}

\end{fulllineitems}

\index{record\_execute\_analysis\_outputs() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.record_execute_analysis_outputs}\pysiglinewithargsret{\bfcode{record\_execute\_analysis\_outputs}}{\emph{analysis\_output}}{}
Function used internally by execute to record the output
of the custom execute\_analysis(...) function to the \_\_data\_list.

This function may be overwritten in child classes in order to
customize the behavior for recording data outputs. Eg., for some
analyses one may only want to record a particular set of outputs,
rather than all outputs generated by the analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_output}} -- The output of the execute\_analysis(...) function to be recorded

\end{description}\end{quote}

\end{fulllineitems}

\index{results\_ready() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.results_ready}\pysiglinewithargsret{\bfcode{results\_ready}}{}{}
Check whether the results of the analysis are ready to be used
:return: Boolean

\end{fulllineitems}

\index{set\_analysis\_identifier() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.set_analysis_identifier}\pysiglinewithargsret{\bfcode{set\_analysis\_identifier}}{\emph{identifier}}{}
Set the name of the analysis to identifer

Side Effects: This function modifies self.analysis\_identifier
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{identifier}} (\emph{\texttt{str}}) -- The new analysis identifier string to be used (should be unique)

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_parameter\_values() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.set_parameter_values}\pysiglinewithargsret{\bfcode{set\_parameter\_values}}{\emph{**kwargs}}{}
Set all parameters given as input to the function. The inputs
are placed in the self.parameters list. If the parameter refers
to an existing h5py.Dataset, h5py.Group,  managed h5py object,
or is an instance of an existing omis\_analysi\_base object, then
a dependency\_dict will be created and stored as value instead.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{kwargs}} -- Dictionary of keyword arguments. All keys are
expected to be strings. All values are expected to be
either i) numpy arrays, ii) int, float, str or unicode
variables, iii) h5py.Dataset or  h5py.Group, iv) or any
the omsi\_file API class objects. For iii) and iv) one
may provide a tuple consisting of the dataobject t{[}0{]} and
an additional selection string t{[}1{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_analysis\_parameters() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.update_analysis_parameters}\pysiglinewithargsret{\bfcode{update\_analysis\_parameters}}{\emph{**kwargs}}{}
Record the analysis parameters passed to the execute() function.

The default implementation simply calls the set\_parameter\_values(...) function.
This function may be overwritten to customize the behavior of how parameters
are recorded by the execute function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{kwargs}} -- Dictionary of keyword arguments with the parameters passed to the execute(..) function

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.base.analysis\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Get the mz axes for the analysis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{qslice\_viewer\_option}} -- If multiple default viewer behaviors are available for a given
analysis then this option is used to switch between them for the qslice URL pattern.

\item {} 
\textbf{\texttt{qspectrum\_viewer\_option}} -- If multiple default viewer behaviors are available for a
given analysis then this option is used to switch between them for the qspectrum URL pattern.

\end{itemize}

\item[{Returns}] \leavevmode

The following four arrays are returned by the analysis:
\begin{itemize}
\item {} 
mzSpectra : Array with the static mz values for the spectra.

\item {} 
labelSpectra : Label for the spectral mz axis

\item {} 
mzSlice : Array of the static mz values for the slices or None if identical to the mzSpectra.

\item {} 
labelSlice : Label for the slice mz axis or None if identical to labelSpectra.

\item {} 
values\_x: The values for the x axis of the image (or None)

\item {} 
label\_x: Label for the x axis of the image

\item {} 
values\_y: The values for the y axis of the image (or None)

\item {} 
label\_y: Label for the y axis of the image

\item {} 
values\_z: The values for the z axis of the image (or None)

\item {} 
label\_z: Label for the z axis of the image

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.base.analysis\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Get 3D analysis dataset for which z-slices should be extracted for presentation in the OMSI viewer
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{z}} -- Selection string indicting which z values should be selected.

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis
then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode
numpy array with the data to be displayed in the image slice viewer. Slicing will be
performed typically like {[}:,:,zmin:zmax{]}.

\item[{Raises}] \leavevmode
NotImplementedError in case that v\_qslice is not supported by the analysis.

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.base.analysis\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qslice.
The default implementation tries to take care of handling the spectra retrieval for all the dependencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.  For most cases
this is not needed here as the support for slice operations is usually a static decission based on
the class type, however, in some cases additional checks may be needed (e.g., ensure that the required
data is available).

\item[{Returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be empty
if the analysis does not support qslice requests (i.e., v\_qslice(...) is not available).

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.base.analysis\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Get from which 3D analysis spectra in x/y should be extracted for presentation in the OMSI viewer

\textbf{Developer Note:} h5py currently supports only a single index list. If the user provides an index-list
for both x and y, then we need to construct the proper merged list and load the data manually, or if
the data is small enough, one can load the full data into a numpy array which supports
multiple lists in the selection.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{x}} -- x selection string

\item {} 
\textbf{\texttt{y}} -- y selection string

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given
analysis then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode

The following two elements are expected to be returned by this function :
\begin{enumerate}
\item {} 
1D, 2D or 3D numpy array of the requested spectra. NOTE: The mass (m/z) axis must be                 the last axis. For index selection x=1,y=1 a 1D array is usually expected. For indexList                 selections x={[}0{]}\&y={[}1{]} usually a 2D array is expected. For ragne selections x=0:1\&y=1:2 we                 one usually expects a 3D array.

\item {} 
None in case that the spectra axis returned by v\_qmz are valid for the returned spectrum.                 Otherwise, return a 1D numpy array with the m/z values for the spectrum (i.e., if custom m/z                 values are needed for interpretation of the returned spectrum).This may be needed, e.g., in                 cases where a per-spectrum peak analysis is performed and the peaks for each spectrum appear                 at different m/z values.

\end{enumerate}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.base.analysis\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qspectrum.
The default implementation tries to take care of handling the spectra retrieval for all the dependencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.
For most cases this is not needed here as the support for slice operations is usually a static decision
based on the class type, however, in some cases additional checks may be needed (e.g., ensure that the
required data is available).

\item[{Returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be empty if
the analysis does not support qspectrum requests (i.e., v\_qspectrum(...) is not available).

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_analysis\_data() (omsi.analysis.base.analysis\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.base.analysis_base.write_analysis_data}\pysiglinewithargsret{\bfcode{write\_analysis\_data}}{\emph{analysis\_group=None}}{}
This function is used to write the actual analysis data to file. If not implemented, then the
omsi\_file\_analysis API's default behavior is used instead.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_group}} -- The h5py.Group object where the analysis is stored. May be None on cores that
do not perform any writing but which need to participate in communication, e.g., to collect data
for writing.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{\texttt{generic} Module}
\label{omsi.analysis:generic-module}\label{omsi.analysis:module-omsi.analysis.generic}\index{omsi.analysis.generic (module)}
Generic analysis class used to represent analyses of unknown type, e.g., when loading
a custom user-defined analysis from file for which the indicate class may not be
available with the local installation. In this case we want to at least be able
to load and investigate the data.
\index{analysis\_generic (class in omsi.analysis.generic)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.generic.analysis_generic}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.generic.}\bfcode{analysis\_generic}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

This analysis class is used if the specific anlaysis type is unknown, e.g., when loading
custom user-defined analysis data that may have not be available in the standard
omsi package used.

Initialize the basic data members
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{name\_key}} -- The name for the analysis

\end{description}\end{quote}
\index{DEFAULT\_OUTPUT\_PREFIX (omsi.analysis.generic.analysis\_generic attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.generic.analysis_generic.DEFAULT_OUTPUT_PREFIX}\pysigline{\bfcode{DEFAULT\_OUTPUT\_PREFIX}\strong{ = `output\_'}}
\end{fulllineitems}

\index{execute() (omsi.analysis.generic.analysis\_generic method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.generic.analysis_generic.execute}\pysiglinewithargsret{\bfcode{execute}}{\emph{**kwargs}}{}
Overwrite the default implementation of execute to update parameter specifications/types
when wrapping functions where the types are not known a priori.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{kwargs}} -- Custom analysis parameters

\item[{Returns}] \leavevmode
The result of execute\_analysis()

\end{description}\end{quote}

\end{fulllineitems}

\index{execute\_analysis() (omsi.analysis.generic.analysis\_generic method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.generic.analysis_generic.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
Nothing to do here.

\end{fulllineitems}

\index{from\_function() (omsi.analysis.generic.analysis\_generic class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.generic.analysis_generic.from_function}\pysiglinewithargsret{\strong{classmethod }\bfcode{from\_function}}{\emph{analysis\_function}, \emph{output\_names=None}, \emph{parameter\_specs=None}, \emph{name\_key='undefined'}}{}
Create a generic analysis class for a given analysis function.

This functionality is useful to ease quick scripting on analyses but should not be used in production.

NOTE: \_\_analysis\_function is a reserved parameter name used to store the analysis function and may
not be used as an input parameter for the analysis function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_function}} -- The analysis function to be wrapped for provenance tracking and storage

\item {} 
\textbf{\texttt{output\_names}} -- Optionally, define a list of the names of the outputs

\item {} 
\textbf{\texttt{parameter\_specs}} -- Optional list of omsi.datastructures.analysis\_data.parameter\_data with
additional information about the parameters of the function.

\item {} 
\textbf{\texttt{name\_key}} -- The name for the analysis, i.e., the analysis  identifier

\end{itemize}

\item[{Returns}] \leavevmode
A new generic analysis class

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_analysis\_type() (omsi.analysis.generic.analysis\_generic class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.generic.analysis_generic.get_analysis_type}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_analysis\_type}}{}{}
Return a string indicating the type of analysis performed

\end{fulllineitems}

\index{get\_real\_analysis\_type() (omsi.analysis.generic.analysis\_generic method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.generic.analysis_generic.get_real_analysis_type}\pysiglinewithargsret{\bfcode{get\_real\_analysis\_type}}{}{}
This class is designed to handle generic (including unkown) types of analysis.
In cases, e.g., were this class is used to store analysis data from an HDF5
file we may have an actual analysis type available even if we do not have
a special analysis class may not be available in the current installation

\end{fulllineitems}

\index{read\_from\_omsi\_file() (omsi.analysis.generic.analysis\_generic method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.generic.analysis_generic.read_from_omsi_file}\pysiglinewithargsret{\bfcode{read\_from\_omsi\_file}}{\emph{analysis\_object}, \emph{load\_data=True}, \emph{load\_parameters=True}, \emph{load\_runtime\_data=True}, \emph{dependencies\_omsi\_format=True}, \emph{ignore\_type\_conflict=False}}{}
See \emph{omsi.analysis.analysis\_base.read\_from\_omsi\_file(...)} for details.
The function is overwritten here mainly to initialize the self.real\_analysis\_type
instance variable but otherwise uses the default behavior.

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.generic.analysis\_generic class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.generic.analysis_generic.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Implement support for qmz URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.generic.analysis\_generic class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.generic.analysis_generic.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Implement support for qslice URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.generic.analysis\_generic class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.generic.analysis_generic.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.generic.analysis\_generic class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.generic.analysis_generic.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Implement support for qspectrum URL requests for the viewer

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.generic.analysis\_generic class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.generic.analysis_generic.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{write\_analysis\_data() (omsi.analysis.generic.analysis\_generic method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.generic.analysis_generic.write_analysis_data}\pysiglinewithargsret{\bfcode{write\_analysis\_data}}{\emph{analysis\_group=None}}{}
This function is used to write the actual analysis data to file. If not implemented, then the
omsi\_file\_analysis API's default behavior is used instead.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_group}} -- The h5py.Group object where the analysis is stored. May be None on cores that
do not perform any writing but which need to participate in communication, e.g., to collect data
for writing.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{bastet\_analysis() (in module omsi.analysis.generic)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.generic.bastet_analysis}\pysiglinewithargsret{\code{omsi.analysis.generic.}\bfcode{bastet\_analysis}}{\emph{output\_names=None}, \emph{parameter\_specs=None}, \emph{name\_key='undefined'}}{}
Decorator used to wrap a function and replace it with an analysis\_generic object
that behaves like a function but adds the ability for saving the
analysis to file and tracking provenance

This is essentially the same as analysis\_generic.from\_function(....).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{func}} -- The function to be wrapped

\item {} 
\textbf{\texttt{output\_names}} -- Optional list of strings with the names of the outputs

\item {} 
\textbf{\texttt{parameter\_specs}} -- Optional list of omsi.datastructures.analysis\_data.parameter\_data with
additional information about the parameters of the function.

\item {} 
\textbf{\texttt{name\_key}} -- Optional name for the analysis, i.e., the analysis identifier

\end{itemize}

\item[{Returns}] \leavevmode
analysis\_generic instance for the wrapped function

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{\texttt{analysis\_views} Module}
\label{omsi.analysis:module-omsi.analysis.analysis_views}\label{omsi.analysis:analysis-views-module}\index{omsi.analysis.analysis\_views (module)}
Helper module with functions and classes for interfacing with different
analysis algorithms. Many of these functions are used to ease interaction
with the analysis module in a generic fashion, without having to explicitly
know about all the different available modules, e.g., we can just look
up modules by name and interact with them directly.
\index{analysis\_views (class in omsi.analysis.analysis\_views)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_views.analysis_views}\pysigline{\strong{class }\code{omsi.analysis.analysis\_views.}\bfcode{analysis\_views}}
Bases: \code{object}

Helper class for interfacing different analysis algorithms with the web-based viewer

Nothing to do here.
\index{analysis\_name\_to\_class() (omsi.analysis.analysis\_views.analysis\_views class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_views.analysis_views.analysis_name_to_class}\pysiglinewithargsret{\strong{classmethod }\bfcode{analysis\_name\_to\_class}}{\emph{class\_name}}{}
Convert the given string indicating the class to a python class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{class\_name}} -- Name of the analysis class. This may be a fully qualified
name, e.g., \emph{omsi.analysis.multivariate\_stat.omsi\_nmf} or a name
relative to the omis.analysis module, e.g, \emph{multivariate\_stat.omsi\_nmf}.

\item[{Raises}] \leavevmode
Attribute error in case that the class cannot be restored.

\end{description}\end{quote}

\end{fulllineitems}

\index{available\_analysis() (omsi.analysis.analysis\_views.analysis\_views class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_views.analysis_views.available_analysis}\pysiglinewithargsret{\strong{classmethod }\bfcode{available\_analysis}}{}{}
Get all available analysis, i.e., all analysis that are subclasses of
analysis\_base.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Dictionary where the dict-keys are the full qualified name of the
module and the values are the analysis class corresponding to that
module.

\end{description}\end{quote}

\end{fulllineitems}

\index{available\_analysis\_descriptions() (omsi.analysis.analysis\_views.analysis\_views class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_views.analysis_views.available_analysis_descriptions}\pysiglinewithargsret{\strong{classmethod }\bfcode{available\_analysis\_descriptions}}{}{}
Get all available analysis, i.e., all analysis that are subclasses of
analysis\_base. For each analysis compile the list of input parameters,
outputs, the corresponding class etc.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Dictionary where the dict-keys are the full qualified name of the
module and the values are dicts with class, list of analysis paremeter names,
list of analysis outputs.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_axes() (omsi.analysis.analysis\_views.analysis\_views class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_views.analysis_views.get_axes}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_axes}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Get the mz axes for the analysis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{qslice\_viewer\_option}} -- If multiple default viewer behaviors are available for
a given analysis then this option is used to switch between them for the qslice URL pattern.

\item {} 
\textbf{\texttt{qspectrum\_viewer\_option}} -- If multiple default viewer behaviors are available
for a given analysis then this option is used to switch between them for the
qspectrum URL pattern.

\end{itemize}

\item[{Returns}] \leavevmode

The following four arrays are returned by the analysis:
\begin{itemize}
\item {} 
mz\_spectra : Array with the static mz values for the spectra.

\item {} 
label\_spectra : Lable for the spectral mz axis

\item {} 
mz\_slice : Array of the static mz values for the slices or None if identical to the mz\_spectra.

\item {} 
label\_slice : Lable for the slice mz axis or None if identical to label\_spectra.

\item {} 
values\_x: The values for the x axis of the image (or None)

\item {} 
label\_x: Label for the x axis of the image

\item {} 
values\_y: The values for the y axis of the image (or None)

\item {} 
label\_y: Label for the y axis of the image

\item {} 
values\_z: The values for the z axis of the image (or None)

\item {} 
label\_z: Label for the z axis of the image

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_qslice\_viewer\_options() (omsi.analysis.analysis\_views.analysis\_views class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_views.analysis_views.get_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for qslice.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.

\item[{Returns}] \leavevmode
Array of strings indicating the different available viewer options.
The array may be empty if now viewer\_options are available, i.e., get\_slice
and get\_spectrum are undefined for the given analysis.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_qspectrum\_viewer\_options() (omsi.analysis.analysis\_views.analysis\_views class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_views.analysis_views.get_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for qspectrum.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.

\item[{Returns}] \leavevmode
Array of strings indicating the different available viewer options.
The array may be empty if now viewer\_options are available, i.e., get\_slice
and get\_spectrum are undefined for the given analysis.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_slice() (omsi.analysis.analysis\_views.analysis\_views class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_views.analysis_views.get_slice}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_slice}}{\emph{analysis\_object}, \emph{z}, \emph{operations=None}, \emph{viewer\_option=0}}{}
Get 3D analysis dataset for which z-slices should be extracted for presentation
in the OMSI viewer
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{z}} -- Selection string indicting which z values should be selected.

\item {} 
\textbf{\texttt{operations}} -- JSON string with list of dictionaries or a python
list of dictionaries. Each dict specifies a single data
transformation or data reduction that are applied in order.
See omsi.shared.omsi\_data\_selection.transform\_and\_reduce\_data(...)
for details.

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given
analysis then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode
numpy array with the data to be displayed in the image slice viewer. Slicing
will be performed typically like {[}:,:,zmin:zmax{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_spectra() (omsi.analysis.analysis\_views.analysis\_views class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_views.analysis_views.get_spectra}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_spectra}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{operations=None}, \emph{viewer\_option=0}}{}
Get from which 3D analysis spectra in x/y should be extracted for presentation in the OMSI viewer

\textbf{Developer Note:}
h5py currently supports only a single index list. If the user provides an index-list for both
x and y, then we need to construct the proper merged list and load the data manually, or if
the data is small enough, one can load the full data into a numpy array which supports
multiple lists in the selection.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{x}} -- x selection string

\item {} 
\textbf{\texttt{y}} -- y selection string

\item {} 
\textbf{\texttt{operations}} -- JSON string with list of dictionaries or a python
list of dictionaries. Each dict specifies a single data
transformation or data reduction that are applied in order.
See omsi.shared.omsi\_data\_selection.transform\_and\_reduce\_data(...)
for details.

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given
analysis then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode
2D or 3D numpy array of the requested spectra. The mass (m/z) axis must be the last axis.

\end{description}\end{quote}

\end{fulllineitems}

\index{supports\_slice() (omsi.analysis.analysis\_views.analysis\_views class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_views.analysis_views.supports_slice}\pysiglinewithargsret{\strong{classmethod }\bfcode{supports\_slice}}{\emph{analysis\_object}}{}
Get whether a default slice selection behavior is defined for the analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item[{Returns}] \leavevmode
Boolean indicating whether get\_slice(...) is defined for the analysis object.

\end{description}\end{quote}

\end{fulllineitems}

\index{supports\_spectra() (omsi.analysis.analysis\_views.analysis\_views class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis:omsi.analysis.analysis_views.analysis_views.supports_spectra}\pysiglinewithargsret{\strong{classmethod }\bfcode{supports\_spectra}}{\emph{analysis\_object}}{}
Get wheter a default spectra selection behavior is defined for the analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.

\item[{Returns}] \leavevmode
Boolean indicating whether get\_spectra(...) is defined for the analysis object.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Subpackages}
\label{omsi.analysis:subpackages}

\paragraph{findpeaks Package}
\label{omsi.analysis.findpeaks:findpeaks-package}\label{omsi.analysis.findpeaks::doc}

\subparagraph{\texttt{findpeaks} Package}
\label{omsi.analysis.findpeaks:id1}\phantomsection\label{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks}\index{omsi.analysis.findpeaks (module)}
Package of peak-finding related analysis modules.
\index{omsi\_findpeaks\_global (class in omsi.analysis.findpeaks)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_global}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.findpeaks.}\bfcode{omsi\_findpeaks\_global}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Basic global peak detection analysis. The default implementation
computes the peaks on the average spectrum and then computes the peak-cube data,
i.e., the values for the detected peaks at each pixel.

TODO: The current version assumes 2D data

Initialize the basic data members
\index{execute\_analysis() (omsi.analysis.findpeaks.omsi\_findpeaks\_global method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_global.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
Execute the global peak finding for the given msidata and mzdata.

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.findpeaks.omsi\_findpeaks\_global class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_global.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Implement support for qmz URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.findpeaks.omsi\_findpeaks\_global class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_global.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Implement support for qslice URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.findpeaks.omsi\_findpeaks\_global class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_global.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.findpeaks.omsi\_findpeaks\_global class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_global.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Implement support for qspectrum URL requests for the viewer

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.findpeaks.omsi\_findpeaks\_global class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_global.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_findpeaks\_local (class in omsi.analysis.findpeaks)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_local}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.findpeaks.}\bfcode{omsi\_findpeaks\_local}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Class defining a basic gloabl peak finding. The default implementation computes the peaks on the average
spectrum and then computes the peak-cube data, i.e., the values for the detected peaks at each pixel.

TODO: The current version assumes 2D data

Initialize the basic data members
\index{execute\_analysis() (omsi.analysis.findpeaks.omsi\_findpeaks\_local method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_local.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{\emph{msidata\_subblock=None}}{}
Execute the local peak finder for the given msidata.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{msidata\_subblock}} -- Optional input parameter used for parallel execution of the
analysis only. If msidata\_subblock is set, then the given subblock will be processed
in SERIAL instead of processing self{[}'msidata'{]} in PARALLEL (if available). This
parameter is strictly optional and intended for internal use only.

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.findpeaks.omsi\_findpeaks\_local class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_local.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Implement support for qmz URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.findpeaks.omsi\_findpeaks\_local class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_local.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Implement support for qslice URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.findpeaks.omsi\_findpeaks\_local class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_local.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.findpeaks.omsi\_findpeaks\_local class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_local.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Implement support for qspectrum URL requests for the viewer

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.findpeaks.omsi\_findpeaks\_local class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_local.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{write\_analysis\_data() (omsi.analysis.findpeaks.omsi\_findpeaks\_local method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_local.write_analysis_data}\pysiglinewithargsret{\bfcode{write\_analysis\_data}}{\emph{analysis\_group=None}}{}
This function is used to write the actual analysis data to file. If not implemented, then the
omsi\_file\_analysis API's default behavior is used instead.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_group}} -- The h5py.Group object where the analysis is stored.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{\texttt{omsi\_findpeaks\_global} Module}
\label{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.omsi_findpeaks_global}\label{omsi.analysis.findpeaks:omsi-findpeaks-global-module}\index{omsi.analysis.findpeaks.omsi\_findpeaks\_global (module)}
Global peak finder computing peaks and associated ion-images
for the full MSI data.
\index{omsi\_findpeaks\_global (class in omsi.analysis.findpeaks.omsi\_findpeaks\_global)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_global.omsi_findpeaks_global}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.findpeaks.omsi\_findpeaks\_global.}\bfcode{omsi\_findpeaks\_global}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Basic global peak detection analysis. The default implementation
computes the peaks on the average spectrum and then computes the peak-cube data,
i.e., the values for the detected peaks at each pixel.

TODO: The current version assumes 2D data

Initialize the basic data members
\index{execute\_analysis() (omsi.analysis.findpeaks.omsi\_findpeaks\_global.omsi\_findpeaks\_global method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_global.omsi_findpeaks_global.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
Execute the global peak finding for the given msidata and mzdata.

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.findpeaks.omsi\_findpeaks\_global.omsi\_findpeaks\_global class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_global.omsi_findpeaks_global.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Implement support for qmz URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.findpeaks.omsi\_findpeaks\_global.omsi\_findpeaks\_global class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_global.omsi_findpeaks_global.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Implement support for qslice URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.findpeaks.omsi\_findpeaks\_global.omsi\_findpeaks\_global class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_global.omsi_findpeaks_global.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.findpeaks.omsi\_findpeaks\_global.omsi\_findpeaks\_global class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_global.omsi_findpeaks_global.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Implement support for qspectrum URL requests for the viewer

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.findpeaks.omsi\_findpeaks\_global.omsi\_findpeaks\_global class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_global.omsi_findpeaks_global.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{\texttt{omsi\_findpeaks\_local} Module}
\label{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.omsi_findpeaks_local}\label{omsi.analysis.findpeaks:omsi-findpeaks-local-module}\index{omsi.analysis.findpeaks.omsi\_findpeaks\_local (module)}
Local peak finding analysis module.
\index{omsi\_findpeaks\_local (class in omsi.analysis.findpeaks.omsi\_findpeaks\_local)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_local.omsi_findpeaks_local}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.findpeaks.omsi\_findpeaks\_local.}\bfcode{omsi\_findpeaks\_local}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Class defining a basic gloabl peak finding. The default implementation computes the peaks on the average
spectrum and then computes the peak-cube data, i.e., the values for the detected peaks at each pixel.

TODO: The current version assumes 2D data

Initialize the basic data members
\index{execute\_analysis() (omsi.analysis.findpeaks.omsi\_findpeaks\_local.omsi\_findpeaks\_local method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_local.omsi_findpeaks_local.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{\emph{msidata\_subblock=None}}{}
Execute the local peak finder for the given msidata.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{msidata\_subblock}} -- Optional input parameter used for parallel execution of the
analysis only. If msidata\_subblock is set, then the given subblock will be processed
in SERIAL instead of processing self{[}'msidata'{]} in PARALLEL (if available). This
parameter is strictly optional and intended for internal use only.

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.findpeaks.omsi\_findpeaks\_local.omsi\_findpeaks\_local class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_local.omsi_findpeaks_local.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Implement support for qmz URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.findpeaks.omsi\_findpeaks\_local.omsi\_findpeaks\_local class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_local.omsi_findpeaks_local.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Implement support for qslice URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.findpeaks.omsi\_findpeaks\_local.omsi\_findpeaks\_local class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_local.omsi_findpeaks_local.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.findpeaks.omsi\_findpeaks\_local.omsi\_findpeaks\_local class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_local.omsi_findpeaks_local.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Implement support for qspectrum URL requests for the viewer

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.findpeaks.omsi\_findpeaks\_local.omsi\_findpeaks\_local class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_local.omsi_findpeaks_local.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{write\_analysis\_data() (omsi.analysis.findpeaks.omsi\_findpeaks\_local.omsi\_findpeaks\_local method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.omsi_findpeaks_local.omsi_findpeaks_local.write_analysis_data}\pysiglinewithargsret{\bfcode{write\_analysis\_data}}{\emph{analysis\_group=None}}{}
This function is used to write the actual analysis data to file. If not implemented, then the
omsi\_file\_analysis API's default behavior is used instead.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_group}} -- The h5py.Group object where the analysis is stored.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{findpeaks.third\_party Package}
\label{omsi.analysis.findpeaks:findpeaks-third-party-package}

\subparagraph{\texttt{findpeaks.third\_party} Package}
\label{omsi.analysis.findpeaks:id2}\phantomsection\label{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.third_party}\index{omsi.analysis.findpeaks.third\_party (module)}
Package containing shared third-party code modules included here to reduce the need for external
dependencies when only small parts of external code are used.


\subparagraph{\texttt{findpeaks} Module}
\label{omsi.analysis.findpeaks:findpeaks-module}\label{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.third_party.findpeaks}\index{omsi.analysis.findpeaks.third\_party.findpeaks (module)}\index{findpeaks (class in omsi.analysis.findpeaks.third\_party.findpeaks)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.third_party.findpeaks.findpeaks}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.findpeaks.third\_party.findpeaks.}\bfcode{findpeaks}}{\emph{x}, \emph{y}, \emph{sizesmooth}, \emph{slwindow}, \emph{peakheight}}{}~\index{Name (omsi.analysis.findpeaks.third\_party.findpeaks.findpeaks attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.third_party.findpeaks.findpeaks.Name}\pysigline{\bfcode{Name}\strong{ = `findpeaks'}}
\end{fulllineitems}

\index{display() (omsi.analysis.findpeaks.third\_party.findpeaks.findpeaks method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.third_party.findpeaks.findpeaks.display}\pysiglinewithargsret{\bfcode{display}}{}{}
\end{fulllineitems}

\index{peakdet() (omsi.analysis.findpeaks.third\_party.findpeaks.findpeaks method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.third_party.findpeaks.findpeaks.peakdet}\pysiglinewithargsret{\bfcode{peakdet}}{}{}
Converted from MATLAB script at \href{http://billauer.co.il/peakdet.html}{http://billauer.co.il/peakdet.html}

Currently returns two lists of tuples, but maybe arrays would be better

function {[}maxtab, mintab{]}=peakdet(v, delta, x)
\%PEAKDET Detect peaks in a vector
\%        {[}MAXTAB, MINTAB{]} = PEAKDET(V, DELTA) finds the local
\%        maxima and minima (``peaks'') in the vector V.
\%        MAXTAB and MINTAB consists of two columns. Column 1
\%        contains indices in V, and column 2 the found values.
\%      
\%        With {[}MAXTAB, MINTAB{]} = PEAKDET(V, DELTA, X) the indices
\%        in MAXTAB and MINTAB are replaced with the corresponding
\%        X-values.
\%
\%        A point is considered a maximum peak if it has the maximal
\%        value, and was preceded (to the left) by a value lower by
\%        DELTA.

\% Eli Billauer, 3.4.05 (Explicitly not copyrighted).
\% This function is released to the public domain; Any use is allowed.

\end{fulllineitems}

\index{sliding\_window\_minimum() (omsi.analysis.findpeaks.third\_party.findpeaks.findpeaks method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.third_party.findpeaks.findpeaks.sliding_window_minimum}\pysiglinewithargsret{\bfcode{sliding\_window\_minimum}}{}{}
A iterator which takes the size of the window, \emph{k}, and an iterable,
\emph{li}. Then returns an iterator such that the ith element yielded is equal
to min(list(li){[}max(i - k + 1, 0):i+1{]}).

Each yield takes amortized O(1) time, and overall the generator takes O(k)
space.

\end{fulllineitems}

\index{smoothListGaussian() (omsi.analysis.findpeaks.third\_party.findpeaks.findpeaks method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.third_party.findpeaks.findpeaks.smoothListGaussian}\pysiglinewithargsret{\bfcode{smoothListGaussian}}{}{}
\end{fulllineitems}


\end{fulllineitems}



\paragraph{findpeaks.experimental Package}
\label{omsi.analysis.findpeaks:findpeaks-experimental-package}

\subparagraph{\texttt{findpeaks.experimental} Package}
\label{omsi.analysis.findpeaks:id3}\phantomsection\label{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.experimental}\index{omsi.analysis.findpeaks.experimental (module)}
Module with experimental analysis code, i.e., code that is
not (yet) used in production but is under development.
Often this is code that is used in a specific research.


\subparagraph{\texttt{omsi\_peakcube} Module}
\label{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.experimental.omsi_peakcube}\label{omsi.analysis.findpeaks:omsi-peakcube-module}\index{omsi.analysis.findpeaks.experimental.omsi\_peakcube (module)}\index{main() (in module omsi.analysis.findpeaks.experimental.omsi\_peakcube)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_peakcube.main}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.omsi\_peakcube.}\bfcode{main}}{\emph{argv=None}}{}
\end{fulllineitems}

\index{omsi\_peakcube (class in omsi.analysis.findpeaks.experimental.omsi\_peakcube)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_peakcube.omsi_peakcube}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.findpeaks.experimental.omsi\_peakcube.}\bfcode{omsi\_peakcube}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Initalize the basic data members
\index{execute\_analysis() (omsi.analysis.findpeaks.experimental.omsi\_peakcube.omsi\_peakcube method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_peakcube.omsi_peakcube.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
\end{fulllineitems}

\index{getGlobalMz() (omsi.analysis.findpeaks.experimental.omsi\_peakcube.omsi\_peakcube method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_peakcube.omsi_peakcube.getGlobalMz}\pysiglinewithargsret{\bfcode{getGlobalMz}}{\emph{peaksBins}, \emph{peaksMZdata}, \emph{HCpeaksLabels}, \emph{HCLabelsList}}{}
\end{fulllineitems}

\index{getPeakCube() (omsi.analysis.findpeaks.experimental.omsi\_peakcube.omsi\_peakcube method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_peakcube.omsi_peakcube.getPeakCube}\pysiglinewithargsret{\bfcode{getPeakCube}}{\emph{peaksIntensities}, \emph{peaksArrayIndex}, \emph{HCpeaksLabels}, \emph{HCLabelsList}}{}
\end{fulllineitems}

\index{record\_execute\_analysis\_outputs() (omsi.analysis.findpeaks.experimental.omsi\_peakcube.omsi\_peakcube method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_peakcube.omsi_peakcube.record_execute_analysis_outputs}\pysiglinewithargsret{\bfcode{record\_execute\_analysis\_outputs}}{\emph{analysis\_output}}{}
We are recording our outputs manually as part of the execute function

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.findpeaks.experimental.omsi\_peakcube.omsi\_peakcube class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_peakcube.omsi_peakcube.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Implement support for qmz URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.findpeaks.experimental.omsi\_peakcube.omsi\_peakcube class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_peakcube.omsi_peakcube.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Implement support for qslice URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.findpeaks.experimental.omsi\_peakcube.omsi\_peakcube class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_peakcube.omsi_peakcube.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.findpeaks.experimental.omsi\_peakcube.omsi\_peakcube class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_peakcube.omsi_peakcube.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Implement support for qspectrum URL requests for the viewer

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.findpeaks.experimental.omsi\_peakcube.omsi\_peakcube class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_peakcube.omsi_peakcube.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}


\end{fulllineitems}

\index{stop() (in module omsi.analysis.findpeaks.experimental.omsi\_peakcube)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_peakcube.stop}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.omsi\_peakcube.}\bfcode{stop}}{}{}
\end{fulllineitems}



\subparagraph{\texttt{pfrun} Module}
\label{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.experimental.pfrun}\label{omsi.analysis.findpeaks:pfrun-module}\index{omsi.analysis.findpeaks.experimental.pfrun (module)}\index{generateScript() (in module omsi.analysis.findpeaks.experimental.pfrun)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.pfrun.generateScript}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.pfrun.}\bfcode{generateScript}}{\emph{scriptfile}, \emph{PFcontent=None}, \emph{repo=None}}{}
\end{fulllineitems}

\index{main() (in module omsi.analysis.findpeaks.experimental.pfrun)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.pfrun.main}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.pfrun.}\bfcode{main}}{\emph{argv}}{}
\end{fulllineitems}

\index{printHelp() (in module omsi.analysis.findpeaks.experimental.pfrun)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.pfrun.printHelp}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.pfrun.}\bfcode{printHelp}}{\emph{thisfilename}}{}
\end{fulllineitems}

\index{queuePCjob() (in module omsi.analysis.findpeaks.experimental.pfrun)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.pfrun.queuePCjob}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.pfrun.}\bfcode{queuePCjob}}{\emph{pcstring}, \emph{therepo=None}}{}
\end{fulllineitems}

\index{run\_lpf() (in module omsi.analysis.findpeaks.experimental.pfrun)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.pfrun.run_lpf}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.pfrun.}\bfcode{run\_lpf}}{\emph{omsiInFile}, \emph{expIndex}, \emph{dataIndex}, \emph{ph}, \emph{slw}, \emph{smw}}{}
\end{fulllineitems}

\index{run\_npg() (in module omsi.analysis.findpeaks.experimental.pfrun)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.pfrun.run_npg}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.pfrun.}\bfcode{run\_npg}}{\emph{omsiInFile}, \emph{expIndex}, \emph{dataIndex}, \emph{LPFIndex}, \emph{mzth}, \emph{tcut}}{}
\end{fulllineitems}

\index{run\_peakcube() (in module omsi.analysis.findpeaks.experimental.pfrun)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.pfrun.run_peakcube}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.pfrun.}\bfcode{run\_peakcube}}{\emph{omsiInFile}, \emph{expIndex}, \emph{dataIndex}, \emph{LPFIndex}, \emph{NPGIndex}}{}
\end{fulllineitems}

\index{stop() (in module omsi.analysis.findpeaks.experimental.pfrun)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.pfrun.stop}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.pfrun.}\bfcode{stop}}{}{}
\end{fulllineitems}



\subparagraph{\texttt{omsi\_lpf} Module}
\label{omsi.analysis.findpeaks:omsi-lpf-module}\label{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.experimental.omsi_lpf}\index{omsi.analysis.findpeaks.experimental.omsi\_lpf (module)}\index{cl\_peakfind() (in module omsi.analysis.findpeaks.experimental.omsi\_lpf)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_lpf.cl_peakfind}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.omsi\_lpf.}\bfcode{cl\_peakfind}}{\emph{self}, \emph{msidt}, \emph{smoothsize}, \emph{slwindow}, \emph{peakheight}}{}
\end{fulllineitems}

\index{execute\_analysis() (in module omsi.analysis.findpeaks.experimental.omsi\_lpf)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_lpf.execute_analysis}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.omsi\_lpf.}\bfcode{execute\_analysis}}{\emph{self}}{}
\end{fulllineitems}

\index{main() (in module omsi.analysis.findpeaks.experimental.omsi\_lpf)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_lpf.main}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.omsi\_lpf.}\bfcode{main}}{\emph{argv=None}}{}
Then main function

\end{fulllineitems}

\index{omsi\_lpf (class in omsi.analysis.findpeaks.experimental.omsi\_lpf)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_lpf.omsi_lpf}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.findpeaks.experimental.omsi\_lpf.}\bfcode{omsi\_lpf}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

\end{fulllineitems}

\index{v\_qmz (in module omsi.analysis.findpeaks.experimental.omsi\_lpf)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_lpf.v_qmz}\pysigline{\code{omsi.analysis.findpeaks.experimental.omsi\_lpf.}\bfcode{v\_qmz}}
classmethod(function) -\textgreater{} method

Convert a function to be a class method.

A class method receives the class as implicit first argument,
just like an instance method receives the instance.
To declare a class method, use this idiom:
\begin{quote}
\begin{description}
\item[{class C:}] \leavevmode
def f(cls, arg1, arg2, ...): ...
f = classmethod(f)

\end{description}
\end{quote}

It can be called either on the class (e.g. C.f()) or on an instance
(e.g. C().f()).  The instance is ignored except for its class.
If a class method is called for a derived class, the derived class
object is passed as the implied first argument.

Class methods are different than C++ or Java static methods.
If you want those, see the staticmethod builtin.

\end{fulllineitems}

\index{v\_qslice (in module omsi.analysis.findpeaks.experimental.omsi\_lpf)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_lpf.v_qslice}\pysigline{\code{omsi.analysis.findpeaks.experimental.omsi\_lpf.}\bfcode{v\_qslice}}
classmethod(function) -\textgreater{} method

Convert a function to be a class method.

A class method receives the class as implicit first argument,
just like an instance method receives the instance.
To declare a class method, use this idiom:
\begin{quote}
\begin{description}
\item[{class C:}] \leavevmode
def f(cls, arg1, arg2, ...): ...
f = classmethod(f)

\end{description}
\end{quote}

It can be called either on the class (e.g. C.f()) or on an instance
(e.g. C().f()).  The instance is ignored except for its class.
If a class method is called for a derived class, the derived class
object is passed as the implied first argument.

Class methods are different than C++ or Java static methods.
If you want those, see the staticmethod builtin.

\end{fulllineitems}

\index{v\_qslice\_viewer\_options (in module omsi.analysis.findpeaks.experimental.omsi\_lpf)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_lpf.v_qslice_viewer_options}\pysigline{\code{omsi.analysis.findpeaks.experimental.omsi\_lpf.}\bfcode{v\_qslice\_viewer\_options}}
classmethod(function) -\textgreater{} method

Convert a function to be a class method.

A class method receives the class as implicit first argument,
just like an instance method receives the instance.
To declare a class method, use this idiom:
\begin{quote}
\begin{description}
\item[{class C:}] \leavevmode
def f(cls, arg1, arg2, ...): ...
f = classmethod(f)

\end{description}
\end{quote}

It can be called either on the class (e.g. C.f()) or on an instance
(e.g. C().f()).  The instance is ignored except for its class.
If a class method is called for a derived class, the derived class
object is passed as the implied first argument.

Class methods are different than C++ or Java static methods.
If you want those, see the staticmethod builtin.

\end{fulllineitems}

\index{v\_qspectrum (in module omsi.analysis.findpeaks.experimental.omsi\_lpf)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_lpf.v_qspectrum}\pysigline{\code{omsi.analysis.findpeaks.experimental.omsi\_lpf.}\bfcode{v\_qspectrum}}
classmethod(function) -\textgreater{} method

Convert a function to be a class method.

A class method receives the class as implicit first argument,
just like an instance method receives the instance.
To declare a class method, use this idiom:
\begin{quote}
\begin{description}
\item[{class C:}] \leavevmode
def f(cls, arg1, arg2, ...): ...
f = classmethod(f)

\end{description}
\end{quote}

It can be called either on the class (e.g. C.f()) or on an instance
(e.g. C().f()).  The instance is ignored except for its class.
If a class method is called for a derived class, the derived class
object is passed as the implied first argument.

Class methods are different than C++ or Java static methods.
If you want those, see the staticmethod builtin.

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options (in module omsi.analysis.findpeaks.experimental.omsi\_lpf)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_lpf.v_qspectrum_viewer_options}\pysigline{\code{omsi.analysis.findpeaks.experimental.omsi\_lpf.}\bfcode{v\_qspectrum\_viewer\_options}}
classmethod(function) -\textgreater{} method

Convert a function to be a class method.

A class method receives the class as implicit first argument,
just like an instance method receives the instance.
To declare a class method, use this idiom:
\begin{quote}
\begin{description}
\item[{class C:}] \leavevmode
def f(cls, arg1, arg2, ...): ...
f = classmethod(f)

\end{description}
\end{quote}

It can be called either on the class (e.g. C.f()) or on an instance
(e.g. C().f()).  The instance is ignored except for its class.
If a class method is called for a derived class, the derived class
object is passed as the implied first argument.

Class methods are different than C++ or Java static methods.
If you want those, see the staticmethod builtin.

\end{fulllineitems}



\subparagraph{\texttt{omsi\_npg} Module}
\label{omsi.analysis.findpeaks:omsi-npg-module}\label{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.experimental.omsi_npg}\index{omsi.analysis.findpeaks.experimental.omsi\_npg (module)}\index{Node (class in omsi.analysis.findpeaks.experimental.omsi\_npg)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.Node}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.findpeaks.experimental.omsi\_npg.}\bfcode{Node}}{\emph{label}}{}
\end{fulllineitems}

\index{main() (in module omsi.analysis.findpeaks.experimental.omsi\_npg)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.main}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.omsi\_npg.}\bfcode{main}}{\emph{argv=None}}{}
\end{fulllineitems}

\index{omsi\_npg (class in omsi.analysis.findpeaks.experimental.omsi\_npg)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.findpeaks.experimental.omsi\_npg.}\bfcode{omsi\_npg}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Initalize the basic data members
\index{Find() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.Find}\pysiglinewithargsret{\bfcode{Find}}{\emph{x}}{}
\end{fulllineitems}

\index{MakeSet() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.MakeSet}\pysiglinewithargsret{\bfcode{MakeSet}}{\emph{x}}{}
\end{fulllineitems}

\index{Union() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.Union}\pysiglinewithargsret{\bfcode{Union}}{\emph{x}, \emph{y}}{}
\end{fulllineitems}

\index{execute\_analysis() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
\end{fulllineitems}

\index{getClustersInfo() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.getClustersInfo}\pysiglinewithargsret{\bfcode{getClustersInfo}}{\emph{GpeaksLabels}, \emph{GLabelsList}}{}
\end{fulllineitems}

\index{getCoordIdxB() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.getCoordIdxB}\pysiglinewithargsret{\bfcode{getCoordIdxB}}{\emph{xCoord}, \emph{yCoord}}{}
\end{fulllineitems}

\index{getCoordInfoB() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.getCoordInfoB}\pysiglinewithargsret{\bfcode{getCoordInfoB}}{\emph{xCoord}, \emph{yCoord}, \emph{peaksLabels}}{}
\end{fulllineitems}

\index{getCoordPeaksB() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.getCoordPeaksB}\pysiglinewithargsret{\bfcode{getCoordPeaksB}}{\emph{xCoord}, \emph{yCoord}}{}
\end{fulllineitems}

\index{getNearestPeakIndex() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.getNearestPeakIndex}\pysiglinewithargsret{\bfcode{getNearestPeakIndex}}{\emph{myPeaksArray}, \emph{myPeak}}{}
\end{fulllineitems}

\index{getPixelMap() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.getPixelMap}\pysiglinewithargsret{\bfcode{getPixelMap}}{\emph{Nx}, \emph{Ny}}{}
\end{fulllineitems}

\index{getnpgimage() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.getnpgimage}\pysiglinewithargsret{\strong{classmethod }\bfcode{getnpgimage}}{\emph{PeaksLabels}, \emph{LabelsList}, \emph{peaksArrayIndex}, \emph{peaksIntensities}, \emph{z}}{}
\end{fulllineitems}

\index{getnpgspec() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.getnpgspec}\pysiglinewithargsret{\strong{classmethod }\bfcode{getnpgspec}}{\emph{PeaksLabels}, \emph{LabelsList}, \emph{peaksArrayIndex}, \emph{peaksIntensities}, \emph{xCoord}, \emph{yCoord}}{}
\end{fulllineitems}

\index{myHC() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.myHC}\pysiglinewithargsret{\bfcode{myHC}}{\emph{labelsMMz}, \emph{TreeCut}}{}
\end{fulllineitems}

\index{record\_execute\_analysis\_outputs() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.record_execute_analysis_outputs}\pysiglinewithargsret{\bfcode{record\_execute\_analysis\_outputs}}{\emph{analysis\_output}}{}
We are recording our outputs manually as part of the execute function

\end{fulllineitems}

\index{splitLabelsList() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.splitLabelsList}\pysiglinewithargsret{\bfcode{splitLabelsList}}{\emph{LabelData}, \emph{Thres}, \emph{SplitMax}}{}
\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Implement support for qmz URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Implement support for qslice URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Implement support for qspectrum URL requests for the viewer

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.findpeaks.experimental.omsi\_npg.omsi\_npg class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.omsi_npg.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}


\end{fulllineitems}

\index{stop() (in module omsi.analysis.findpeaks.experimental.omsi\_npg)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.omsi_npg.stop}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.omsi\_npg.}\bfcode{stop}}{}{}
\end{fulllineitems}



\subparagraph{\texttt{mypeakfinder} Module}
\label{omsi.analysis.findpeaks:mypeakfinder-module}\label{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.experimental.mypeakfinder}\index{omsi.analysis.findpeaks.experimental.mypeakfinder (module)}\index{generateScript() (in module omsi.analysis.findpeaks.experimental.mypeakfinder)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.mypeakfinder.generateScript}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.mypeakfinder.}\bfcode{generateScript}}{\emph{scriptfile}, \emph{PFcontent=None}, \emph{repo=None}}{}
\end{fulllineitems}

\index{getJobOutput() (in module omsi.analysis.findpeaks.experimental.mypeakfinder)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.mypeakfinder.getJobOutput}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.mypeakfinder.}\bfcode{getJobOutput}}{\emph{jobname}, \emph{runtype}}{}
\end{fulllineitems}

\index{getPFcmd() (in module omsi.analysis.findpeaks.experimental.mypeakfinder)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.mypeakfinder.getPFcmd}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.mypeakfinder.}\bfcode{getPFcmd}}{\emph{pfstring}, \emph{lpfstring}, \emph{npgstring}, \emph{LPFIndex}, \emph{NPGIndex}, \emph{SkipNPG}, \emph{SkipPeakCube}, \emph{IndexFile=None}}{}
\end{fulllineitems}

\index{main() (in module omsi.analysis.findpeaks.experimental.mypeakfinder)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.mypeakfinder.main}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.mypeakfinder.}\bfcode{main}}{\emph{argv}}{}
\end{fulllineitems}

\index{monitorJob() (in module omsi.analysis.findpeaks.experimental.mypeakfinder)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.mypeakfinder.monitorJob}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.mypeakfinder.}\bfcode{monitorJob}}{\emph{jobid}, \emph{jobname}, \emph{runtype='pf'}}{}
\end{fulllineitems}

\index{printHelp() (in module omsi.analysis.findpeaks.experimental.mypeakfinder)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.mypeakfinder.printHelp}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.mypeakfinder.}\bfcode{printHelp}}{\emph{thisfilename}}{}
\end{fulllineitems}

\index{stop() (in module omsi.analysis.findpeaks.experimental.mypeakfinder)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.findpeaks:omsi.analysis.findpeaks.experimental.mypeakfinder.stop}\pysiglinewithargsret{\code{omsi.analysis.findpeaks.experimental.mypeakfinder.}\bfcode{stop}}{}{}
\end{fulllineitems}



\paragraph{multivariate\_stats Package}
\label{omsi.analysis.multivariate_stats:multivariate-stats-package}\label{omsi.analysis.multivariate_stats::doc}

\subparagraph{\texttt{multivariate\_stats} Package}
\label{omsi.analysis.multivariate_stats:id1}\phantomsection\label{omsi.analysis.multivariate_stats:module-omsi.analysis.multivariate_stats}\index{omsi.analysis.multivariate\_stats (module)}
Multivariate statistics analysis
\index{omsi\_nmf (class in omsi.analysis.multivariate\_stats)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_nmf}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.multivariate\_stats.}\bfcode{omsi\_nmf}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Class defining a basic nmf analysis.

The function has primarily been tested we MSI datasets but should support
arbitrary n-D arrays (n\textgreater{}=2). The last dimension of the input array must be the
spectrum dimnensions.

Initalize the basic data members
\index{execute\_analysis() (omsi.analysis.multivariate\_stats.omsi\_nmf method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_nmf.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
Execute the nmf for the given msidata

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.multivariate\_stats.omsi\_nmf class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_nmf.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Implement support for qmz URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.multivariate\_stats.omsi\_nmf class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_nmf.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Implement support for qslice URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.multivariate\_stats.omsi\_nmf class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_nmf.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.multivariate\_stats.omsi\_nmf class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_nmf.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Implement support for qspectrum URL requests for the viewer

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.multivariate\_stats.omsi\_nmf class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_nmf.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_cx (class in omsi.analysis.multivariate\_stats)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_cx}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.multivariate\_stats.}\bfcode{omsi\_cx}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Class used to implement CX factorization on MSI data.

Initalize the basic data members
\index{comp\_lev\_exact() (omsi.analysis.multivariate\_stats.omsi\_cx class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_cx.comp_lev_exact}\pysiglinewithargsret{\strong{classmethod }\bfcode{comp\_lev\_exact}}{\emph{A}, \emph{k}, \emph{axis}}{}
This function computes the column or row leverage scores of the input matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{A}} -- n-by-d matrix

\item {} 
\textbf{\texttt{k}} -- rank parameter, k \textless{}= min(n,d)

\item {} 
\textbf{\texttt{axis}} -- 0: compute row leverage scores; 1: compute column leverage scores.

\end{itemize}

\item[{Returns}] \leavevmode
1D array of leverage scores. If axis = 0, the length of lev is n.  otherwise, the length of lev is d.

\end{description}\end{quote}

\end{fulllineitems}

\index{dimension\_index (omsi.analysis.multivariate\_stats.omsi\_cx attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_cx.dimension_index}\pysigline{\bfcode{dimension\_index}\strong{ = \{`pixelDim': 1, `imageDim': 0\}}}
\end{fulllineitems}

\index{execute\_analysis() (omsi.analysis.multivariate\_stats.omsi\_cx method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_cx.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
EDIT\_ME:

Replace this text with the appropriate documentation for the analysis.
Describe what your analysis does and how a user can use it. Note, a user will
call the function execute(...) which takes care of storing parameters, collecting
execution data etc., so that you only need to implement your analysis, the rest
is taken care of by analysis\_base. omsi uses Sphynx syntax for the
documentation.

Keyword Arguments:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{mydata}} -- 
...


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.multivariate\_stats.omsi\_cx class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_cx.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Get the mz axes for the analysis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{qslice\_viewer\_option}} -- If multiple default viewer behaviors are available for a given
analysis then this option is used to switch between them for the qslice URL pattern.

\item {} 
\textbf{\texttt{qspectrum\_viewer\_option}} -- If multiple default viewer behaviors are available for a
given analysis then this option is used to switch between them for the qspectrum URL pattern.

\end{itemize}

\item[{Returns}] \leavevmode

The following four arrays are returned by the analysis:
\begin{itemize}
\item {} 
mz\_spectra : Array with the static mz values for the spectra.

\item {} 
label\_spectra : Lable for the spectral mz axis

\item {} 
mz\_slice : Array of the static mz values for the slices or None if identical to the mz\_spectra.

\item {} 
label\_slice : Lable for the slice mz axis or None if identical to label\_spectra.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.multivariate\_stats.omsi\_cx class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_cx.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Get 3D analysis dataset for which z-slices should be extracted for presentation in the OMSI viewer
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{z}} -- Selection string indicting which z values should be selected.

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis
then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode
numpy array with the data to be displayed in the image slice viewer. Slicing will
be performed typically like {[}:,:,zmin:zmax{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.multivariate\_stats.omsi\_cx class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_cx.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qslice.
The default implementation tries to take care of handling the spectra retrieval for all the depencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.  For
most cases this is not needed here as the support for slice operations is usually a static decision
based on the class type, however, in some cases additional checks may be needed (e.g., ensure that
the required data is available).

\item[{Returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be empty
if the analysis does not support qslice requests (i.e., v\_qslice(...) is not available).

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.multivariate\_stats.omsi\_cx class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_cx.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Get from which 3D analysis spectra in x/y should be extracted for presentation in the OMSI viewer
\begin{description}
\item[{Developer Note: h5py currently supports only a single index list. If the user provides an index-list for both}] \leavevmode
x and y, then we need to construct the proper merged list and load the data manually, or if
the data is small enough, one can load the full data into a numpy array which supports
mulitple lists in the selection.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{x}} -- x selection string

\item {} 
\textbf{\texttt{y}} -- y selection string

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis then
this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode

The following two elemnts are expected to be returned by this function :
\begin{enumerate}
\item {} 
1D, 2D or 3D numpy array of the requested spectra. NOTE: The mass (m/z) axis must be the last                 axis. For index selection x=1,y=1 a 1D array is usually expected. For indexList selections x={[}0{]}\&y={[}1{]}                 usually a 2D array is expected. For ragne selections x=0:1\&y=1:2 we one usually expects a 3D array.

\item {} 
None in case that the spectra axis returned by v\_qmz are valid for the returned spectrum. Otherwise,                 return a 1D numpy array with the m/z values for the spectrum (i.e., if custom m/z values are needed                 for interpretation of the returned spectrum).This may be needed, e.g., in cases where a per-spectrum                 peak analysis is performed and the peaks for each spectrum appear at different m/z values.

\end{enumerate}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.multivariate\_stats.omsi\_cx class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_cx.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qspectrum.
The default implementation tries to take care of handling the spectra retrieval for all the depencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.  For most cases
this is not needed here as the support for slice operations is usually a static decission based on the
class type, however, in some cases additional checks may be needed (e.g., ensure that the
required data is available).

\item[{Returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be empty
if the analysis does not support qspectrum requests (i.e., v\_qspectrum(...) is not available).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_kmeans (class in omsi.analysis.multivariate\_stats)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_kmeans}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.multivariate\_stats.}\bfcode{omsi\_kmeans}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Class defining a basic nmf analysis for a 2D MSI data file or slice of the data

Initalize the basic data members
\index{execute\_analysis() (omsi.analysis.multivariate\_stats.omsi\_kmeans method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_kmeans.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
Execute the kmeans clustering for the given msidata

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{\texttt{omsi\_nmf} Module}
\label{omsi.analysis.multivariate_stats:omsi-nmf-module}\label{omsi.analysis.multivariate_stats:module-omsi.analysis.multivariate_stats.omsi_nmf}\index{omsi.analysis.multivariate\_stats.omsi\_nmf (module)}
Module for performing non-negative matrix factorization (NMF) for MSI data.
\index{omsi\_nmf (class in omsi.analysis.multivariate\_stats.omsi\_nmf)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_nmf.omsi_nmf}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.multivariate\_stats.omsi\_nmf.}\bfcode{omsi\_nmf}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Class defining a basic nmf analysis.

The function has primarily been tested we MSI datasets but should support
arbitrary n-D arrays (n\textgreater{}=2). The last dimension of the input array must be the
spectrum dimnensions.

Initalize the basic data members
\index{execute\_analysis() (omsi.analysis.multivariate\_stats.omsi\_nmf.omsi\_nmf method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_nmf.omsi_nmf.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
Execute the nmf for the given msidata

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.multivariate\_stats.omsi\_nmf.omsi\_nmf class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_nmf.omsi_nmf.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Implement support for qmz URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.multivariate\_stats.omsi\_nmf.omsi\_nmf class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_nmf.omsi_nmf.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Implement support for qslice URL requests for the viewer

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.multivariate\_stats.omsi\_nmf.omsi\_nmf class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_nmf.omsi_nmf.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.multivariate\_stats.omsi\_nmf.omsi\_nmf class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_nmf.omsi_nmf.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Implement support for qspectrum URL requests for the viewer

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.multivariate\_stats.omsi\_nmf.omsi\_nmf class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.omsi_nmf.omsi_nmf.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Define which viewer\_options are supported for qspectrum URL's

\end{fulllineitems}


\end{fulllineitems}



\paragraph{multivariate\_stats.third\_party Package}
\label{omsi.analysis.multivariate_stats:multivariate-stats-third-party-package}

\subparagraph{\texttt{multivariate\_stats.third\_party} Package}
\label{omsi.analysis.multivariate_stats:id2}\phantomsection\label{omsi.analysis.multivariate_stats:module-omsi.analysis.multivariate_stats.third_party}\index{omsi.analysis.multivariate\_stats.third\_party (module)}
Package containing shared third-party code modules included here to reduce the need for external
dependencies when only small parts of external code are used.


\subparagraph{\texttt{nmf} Module}
\label{omsi.analysis.multivariate_stats:module-omsi.analysis.multivariate_stats.third_party.nmf}\label{omsi.analysis.multivariate_stats:nmf-module}\index{omsi.analysis.multivariate\_stats.third\_party.nmf (module)}
Copyright (c) 2005-2008 Chih-Jen Lin
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

3. Neither name of copyright holders nor the names of its contributors
may be used to endorse or promote products derived from this software
without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
{\color{red}\bfseries{}{}`{}`}AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\index{nlssubprob() (in module omsi.analysis.multivariate\_stats.third\_party.nmf)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.third_party.nmf.nlssubprob}\pysiglinewithargsret{\code{omsi.analysis.multivariate\_stats.third\_party.nmf.}\bfcode{nlssubprob}}{\emph{V}, \emph{W}, \emph{Hinit}, \emph{tol}, \emph{maxiter}}{}
H, grad: output solution and gradient
iter: \#iterations used
V, W: constant matrices
Hinit: initial solution
tol: stopping tolerance
maxiter: limit of iterations

\end{fulllineitems}

\index{nmf() (in module omsi.analysis.multivariate\_stats.third\_party.nmf)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.multivariate_stats:omsi.analysis.multivariate_stats.third_party.nmf.nmf}\pysiglinewithargsret{\code{omsi.analysis.multivariate\_stats.third\_party.nmf.}\bfcode{nmf}}{\emph{V}, \emph{Winit}, \emph{Hinit}, \emph{tol}, \emph{timelimit}, \emph{maxiter}}{}
(W,H) = nmf(V,Winit,Hinit,tol,timelimit,maxiter)
W,H: output solution
Winit,Hinit: initial solution
tol: tolerance for a relative stopping condition
timelimit, maxiter: limit of time and iterations

\end{fulllineitems}



\paragraph{multivariate\_stats.experimental Package}
\label{omsi.analysis.multivariate_stats:multivariate-stats-experimental-package}

\subparagraph{\texttt{multivariate\_stats.experimental} Package}
\label{omsi.analysis.multivariate_stats:id5}\phantomsection\label{omsi.analysis.multivariate_stats:module-omsi.analysis.multivariate_stats.experimental}\index{omsi.analysis.multivariate\_stats.experimental (module)}
Module with experimental analysis code, i.e., code that is
not (yet) used in production but is under development.
Often this is code that is used in a specific research.


\paragraph{msi\_filtering Package}
\label{omsi.analysis.msi_filtering:msi-filtering-package}\label{omsi.analysis.msi_filtering::doc}

\subparagraph{\texttt{msi\_filtering} Package}
\label{omsi.analysis.msi_filtering:id1}\phantomsection\label{omsi.analysis.msi_filtering:module-omsi.analysis.msi_filtering}\index{omsi.analysis.msi\_filtering (module)}
Module with third-party modules, functions, classes
used by some of the analysis modules in the containing
package.
\index{omsi\_tic\_norm (class in omsi.analysis.msi\_filtering)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.omsi_tic_norm}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.msi\_filtering.}\bfcode{omsi\_tic\_norm}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

TIC Normalization analysis.

Initalize the basic data members
\index{execute\_analysis() (omsi.analysis.msi\_filtering.omsi\_tic\_norm method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.omsi_tic_norm.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
Normalize the data based on the total intensity of a spectrum or the
intensities of a select set of ions.

Calculations are performed using a memory map approach to avoid loading
all data into memory. TIC normalization can as such be performed even
on large files (assuming sufficient disk space).

Keyword Arguments:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{msidata}} (\emph{\texttt{h5py.dataset or numpu array (3D)}}) -- The input MSI dataset

\item {} 
\textbf{\texttt{mzdata}} -- The mz axsis do the dataset

\item {} 
\textbf{\texttt{maxCount}} -- 
...


\item {} 
\textbf{\texttt{mzTol}} -- 
...


\item {} 
\textbf{\texttt{infIons}} -- List of informative ions

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{record\_execute\_analysis\_outputs() (omsi.analysis.msi\_filtering.omsi\_tic\_norm method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.omsi_tic_norm.record_execute_analysis_outputs}\pysiglinewithargsret{\bfcode{record\_execute\_analysis\_outputs}}{\emph{analysis\_output}}{}
We are not returning any outputs here, but we are going to record them manually.
:param analysis\_output: The output of the execute\_analysis(...) function.

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.msi\_filtering.omsi\_tic\_norm class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.omsi_tic_norm.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Get the mz axes for the analysis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{qslice\_viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis then
this option is used to switch between them for the qslice URL pattern.

\item {} 
\textbf{\texttt{qspectrum\_viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis
then this option is used to switch between them for the qspectrum URL pattern.

\end{itemize}

\item[{Returns}] \leavevmode

The following four arrays are returned by the analysis:
\begin{itemize}
\item {} 
mz\_spectra : Array with the static mz values for the spectra.

\item {} 
label\_spectra : Lable for the spectral mz axis

\item {} 
mz\_slice : Array of the static mz values for the slices or None if identical to the mz\_spectra.

\item {} 
label\_slice : Lable for the slice mz axis or None if identical to label\_spectra.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.msi\_filtering.omsi\_tic\_norm class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.omsi_tic_norm.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Get 3D analysis dataset for which z-slices should be extracted for presentation in the OMSI viewer
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{z}} -- Selection string indicting which z values should be selected.

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis
then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode
numpy array with the data to be displayed in the image slice viewer. Slicing will
be performed typically like {[}:,:,zmin:zmax{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.msi\_filtering.omsi\_tic\_norm class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.omsi_tic_norm.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qslice.
The default implementation tries to take care of handling the spectra retrieval for all the depencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.  For
most cases this is not needed here as the support for slice operations is usually a static
decision based on the class type, however, in some cases additional checks may be needed (e.g.,
ensure that the required data is available).

\item[{Returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be empty if
the analysis does not support qslice requests (i.e., v\_qslice(...) is not available).

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.msi\_filtering.omsi\_tic\_norm class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.omsi_tic_norm.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Get from which 3D analysis spectra in x/y should be extracted for presentation in the OMSI viewer
\begin{description}
\item[{Developer Note: h5py currently supports only a single index list. If the user provides an index-list for both}] \leavevmode
x and y, then we need to construct the proper merged list and load the data manually, or if
the data is small enough, one can load the full data into a numpy array which supports
multiple lists in the selection.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{x}} -- x selection string

\item {} 
\textbf{\texttt{y}} -- y selection string

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis then
this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode

The following two elements are expected to be returned by this function :
\begin{enumerate}
\item {} 
1D, 2D or 3D numpy array of the requested spectra. NOTE: The mass (m/z) axis must be the last                   axis. For index selection x=1,y=1 a 1D array is usually expected. For indexList selections                   x={[}0{]}\&y={[}1{]} usually a 2D array is expected. For ragne selections x=0:1\&y=1:2 we one usually                  expects a 3D array/

\item {} 
None in case that the spectra axis returned by v\_qmz are valid for the returned spectrum.                  Otherwise, return a 1D numpy array with the m/z values for the spectrum (i.e., if custom m/z                  values are needed for interpretation of the returned spectrum).This may be needed, e.g., in                  cases where a per-spectrum peak analysis is performed and the peaks for each spectrum appear                  at different m/z values.

\end{enumerate}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.msi\_filtering.omsi\_tic\_norm class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.omsi_tic_norm.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qspectrum.
The default implementation tries to take care of handling the spectra retrieval for all the depencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}
\begin{quote}\begin{description}
\item[{param analysis\_object}] \leavevmode
The omsi\_file\_analysis object for which slicing should be performed.  For most cases
this is not needed here as the support for slice operations is usually a static decission based
on the class type, however, in some cases additional checks may be needed (e.g., ensure that
the required data is available).

\item[{returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be empty
if the analysis does not support qspectrum requests (i.e., v\_qspectrum(...) is not available).

\end{description}\end{quote}
\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{\texttt{omsi\_tic\_norm} Module}
\label{omsi.analysis.msi_filtering:module-omsi.analysis.msi_filtering.omsi_tic_norm}\label{omsi.analysis.msi_filtering:omsi-tic-norm-module}\index{omsi.analysis.msi\_filtering.omsi\_tic\_norm (module)}
Module with the TIC normalization analysis.
\index{omsi\_tic\_norm (class in omsi.analysis.msi\_filtering.omsi\_tic\_norm)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.omsi_tic_norm.omsi_tic_norm}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.msi\_filtering.omsi\_tic\_norm.}\bfcode{omsi\_tic\_norm}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

TIC Normalization analysis.

Initalize the basic data members
\index{execute\_analysis() (omsi.analysis.msi\_filtering.omsi\_tic\_norm.omsi\_tic\_norm method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.omsi_tic_norm.omsi_tic_norm.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
Normalize the data based on the total intensity of a spectrum or the
intensities of a select set of ions.

Calculations are performed using a memory map approach to avoid loading
all data into memory. TIC normalization can as such be performed even
on large files (assuming sufficient disk space).

Keyword Arguments:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{msidata}} (\emph{\texttt{h5py.dataset or numpu array (3D)}}) -- The input MSI dataset

\item {} 
\textbf{\texttt{mzdata}} -- The mz axsis do the dataset

\item {} 
\textbf{\texttt{maxCount}} -- 
...


\item {} 
\textbf{\texttt{mzTol}} -- 
...


\item {} 
\textbf{\texttt{infIons}} -- List of informative ions

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{record\_execute\_analysis\_outputs() (omsi.analysis.msi\_filtering.omsi\_tic\_norm.omsi\_tic\_norm method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.omsi_tic_norm.omsi_tic_norm.record_execute_analysis_outputs}\pysiglinewithargsret{\bfcode{record\_execute\_analysis\_outputs}}{\emph{analysis\_output}}{}
We are not returning any outputs here, but we are going to record them manually.
:param analysis\_output: The output of the execute\_analysis(...) function.

\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.msi\_filtering.omsi\_tic\_norm.omsi\_tic\_norm class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.omsi_tic_norm.omsi_tic_norm.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Get the mz axes for the analysis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{qslice\_viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis then
this option is used to switch between them for the qslice URL pattern.

\item {} 
\textbf{\texttt{qspectrum\_viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis
then this option is used to switch between them for the qspectrum URL pattern.

\end{itemize}

\item[{Returns}] \leavevmode

The following four arrays are returned by the analysis:
\begin{itemize}
\item {} 
mz\_spectra : Array with the static mz values for the spectra.

\item {} 
label\_spectra : Lable for the spectral mz axis

\item {} 
mz\_slice : Array of the static mz values for the slices or None if identical to the mz\_spectra.

\item {} 
label\_slice : Lable for the slice mz axis or None if identical to label\_spectra.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.msi\_filtering.omsi\_tic\_norm.omsi\_tic\_norm class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.omsi_tic_norm.omsi_tic_norm.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Get 3D analysis dataset for which z-slices should be extracted for presentation in the OMSI viewer
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{z}} -- Selection string indicting which z values should be selected.

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis
then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode
numpy array with the data to be displayed in the image slice viewer. Slicing will
be performed typically like {[}:,:,zmin:zmax{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.msi\_filtering.omsi\_tic\_norm.omsi\_tic\_norm class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.omsi_tic_norm.omsi_tic_norm.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qslice.
The default implementation tries to take care of handling the spectra retrieval for all the depencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.  For
most cases this is not needed here as the support for slice operations is usually a static
decision based on the class type, however, in some cases additional checks may be needed (e.g.,
ensure that the required data is available).

\item[{Returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be empty if
the analysis does not support qslice requests (i.e., v\_qslice(...) is not available).

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.msi\_filtering.omsi\_tic\_norm.omsi\_tic\_norm class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.omsi_tic_norm.omsi_tic_norm.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Get from which 3D analysis spectra in x/y should be extracted for presentation in the OMSI viewer
\begin{description}
\item[{Developer Note: h5py currently supports only a single index list. If the user provides an index-list for both}] \leavevmode
x and y, then we need to construct the proper merged list and load the data manually, or if
the data is small enough, one can load the full data into a numpy array which supports
multiple lists in the selection.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{x}} -- x selection string

\item {} 
\textbf{\texttt{y}} -- y selection string

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given analysis then
this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode

The following two elements are expected to be returned by this function :
\begin{enumerate}
\item {} 
1D, 2D or 3D numpy array of the requested spectra. NOTE: The mass (m/z) axis must be the last                   axis. For index selection x=1,y=1 a 1D array is usually expected. For indexList selections                   x={[}0{]}\&y={[}1{]} usually a 2D array is expected. For ragne selections x=0:1\&y=1:2 we one usually                  expects a 3D array/

\item {} 
None in case that the spectra axis returned by v\_qmz are valid for the returned spectrum.                  Otherwise, return a 1D numpy array with the m/z values for the spectrum (i.e., if custom m/z                  values are needed for interpretation of the returned spectrum).This may be needed, e.g., in                  cases where a per-spectrum peak analysis is performed and the peaks for each spectrum appear                  at different m/z values.

\end{enumerate}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.msi\_filtering.omsi\_tic\_norm.omsi\_tic\_norm class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.omsi_tic_norm.omsi_tic_norm.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qspectrum.
The default implementation tries to take care of handling the spectra retrieval for all the depencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}
\begin{quote}\begin{description}
\item[{param analysis\_object}] \leavevmode
The omsi\_file\_analysis object for which slicing should be performed.  For most cases
this is not needed here as the support for slice operations is usually a static decission based
on the class type, however, in some cases additional checks may be needed (e.g., ensure that
the required data is available).

\item[{returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be empty
if the analysis does not support qspectrum requests (i.e., v\_qspectrum(...) is not available).

\end{description}\end{quote}
\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{msi\_filtering.third\_party Package}
\label{omsi.analysis.msi_filtering:msi-filtering-third-party-package}

\subparagraph{\texttt{msi\_filtering.third\_party} Package}
\label{omsi.analysis.msi_filtering:id2}\phantomsection\label{omsi.analysis.msi_filtering:module-omsi.analysis.msi_filtering.third_party}\index{omsi.analysis.msi\_filtering.third\_party (module)}
Package containing shared third-party code modules included here to reduce the need for external
dependencies when only small parts of external code are used.


\paragraph{msi\_filtering.experimental Package}
\label{omsi.analysis.msi_filtering:msi-filtering-experimental-package}

\subparagraph{\texttt{msi\_filtering.experimental} Package}
\label{omsi.analysis.msi_filtering:id3}\phantomsection\label{omsi.analysis.msi_filtering:module-omsi.analysis.msi_filtering.experimental}\index{omsi.analysis.msi\_filtering.experimental (module)}
Module with experimental analysis code, i.e., code that is
not (yet) used in production but is under development.
Often this is code that is used in a specific research.


\subparagraph{\texttt{omsi\_filter\_by\_mask} Module}
\label{omsi.analysis.msi_filtering:module-omsi.analysis.msi_filtering.experimental.omsi_filter_by_mask}\label{omsi.analysis.msi_filtering:omsi-filter-by-mask-module}\index{omsi.analysis.msi\_filtering.experimental.omsi\_filter\_by\_mask (module)}
Module for performing masking for MSI data.
\index{omsi\_filter\_by\_mask (class in omsi.analysis.msi\_filtering.experimental.omsi\_filter\_by\_mask)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.experimental.omsi_filter_by_mask.omsi_filter_by_mask}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.msi\_filtering.experimental.omsi\_filter\_by\_mask.}\bfcode{omsi\_filter\_by\_mask}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Class defining a basic mask creation a 2D MSI data file or slice of the data

Initalize the basic data members
\index{execute\_analysis() (omsi.analysis.msi\_filtering.experimental.omsi\_filter\_by\_mask.omsi\_filter\_by\_mask method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.experimental.omsi_filter_by_mask.omsi_filter_by_mask.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.msi\_filtering.experimental.omsi\_filter\_by\_mask.omsi\_filter\_by\_mask class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.experimental.omsi_filter_by_mask.omsi_filter_by_mask.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Get the mz axes for the analysis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{qslice\_viewer\_option}} -- If multiple default viewer behaviors are available for a
given analysis then this option is used to switch between them for the qslice URL pattern.

\item {} 
\textbf{\texttt{qspectrum\_viewer\_option}} -- If multiple default viewer behaviors are available for a
given analysis then this option is used to switch between them for the qspectrum URL pattern.

\end{itemize}

\item[{Returns}] \leavevmode

The following four arrays are returned by the analysis:
\begin{itemize}
\item {} 
mz\_spectra : Array with the static mz values for the spectra.

\item {} 
label\_spectra : Lable for the spectral mz axis

\item {} 
mz\_slice : Array of the static mz values for the slices or None if identical to the mz\_spectra.

\item {} 
label\_slice : Lable for the slice mz axis or None if identical to label\_spectra.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.msi\_filtering.experimental.omsi\_filter\_by\_mask.omsi\_filter\_by\_mask class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.experimental.omsi_filter_by_mask.omsi_filter_by_mask.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Get 3D analysis dataset for which z-slices should be extracted for presentation in the OMSI viewer
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{z}} -- Selection string indicting which z values should be selected.

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for
a given analysis then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode
numpy array with the data to be displayed in the image slice viewer.
Slicing will be performed typically like {[}:,:,zmin:zmax{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.msi\_filtering.experimental.omsi\_filter\_by\_mask.omsi\_filter\_by\_mask class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.experimental.omsi_filter_by_mask.omsi_filter_by_mask.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qslice.
The default implementation tries to take care of handling the spectra retrieval for all the depencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.
For most cases this is not needed here as the support for slice operations is usually a
static decision based on the class type, however, in some cases additional checks may be
needed (e.g., ensure that the required data is available).

\item[{Returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be
empty if the analysis does not support qslice requests (i.e., v\_qslice(...) is not available).

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.msi\_filtering.experimental.omsi\_filter\_by\_mask.omsi\_filter\_by\_mask class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.experimental.omsi_filter_by_mask.omsi_filter_by_mask.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Get from which 3D analysis spectra in x/y should be extracted for presentation in the OMSI viewer
\begin{description}
\item[{Developer Note: h5py currently supports only a single index list. If the user provides an index-list for both}] \leavevmode
x and y, then we need to construct the proper merged list and load the data manually, or if
the data is small enough, one can load the full data into a numpy array which supports
mulitple lists in the selection.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{x}} -- x selection string

\item {} 
\textbf{\texttt{y}} -- y selection string

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given
analysis then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode

The following two elemnts are expected to be returned by this function :
\begin{enumerate}
\item {} 
1D, 2D or 3D numpy array of the requested spectra. NOTE: The mass (m/z) axis must be the last axis.                For index selection x=1,y=1 a 1D array is usually expected. For indexList selections x={[}0{]}\&y={[}1{]}                usually a 2D array is expected. For ragne selections x=0:1\&y=1:2 we one usually expects a 3D array.

\item {} 
None in case that the spectra axis returned by v\_qmz are valid for the returned spectrum. Otherwise,                return a 1D numpy array with the m/z values for the spectrum (i.e., if custom m/z values are needed                for interpretation of the returned spectrum).This may be needed, e.g., in cases where a per-spectrum                peak analysis is performed and the peaks for each spectrum appear at different m/z values.

\end{enumerate}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.msi\_filtering.experimental.omsi\_filter\_by\_mask.omsi\_filter\_by\_mask class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.experimental.omsi_filter_by_mask.omsi_filter_by_mask.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qspectrum.
The default implementation tries to take care of handling the spectra retrieval for all the dependencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}
\begin{quote}\begin{description}
\item[{param analysis\_object}] \leavevmode
The omsi\_file\_analysis object for which slicing should be performed.
For most cases this is not needed here as the support for slice operations is usually a
static decission based on the class type, however, in some cases additional checks
may be needed (e.g., ensure that the required data is available).

\item[{returns}] \leavevmode
List of strings indicating the different available viewer options. The list should
be empty if the analysis does not support qspectrum requests
(i.e., v\_qspectrum(...) is not available).

\end{description}\end{quote}
\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{\texttt{omsi\_mask\_by\_cluster} Module}
\label{omsi.analysis.msi_filtering:omsi-mask-by-cluster-module}\label{omsi.analysis.msi_filtering:module-omsi.analysis.msi_filtering.experimental.omsi_mask_by_cluster}\index{omsi.analysis.msi\_filtering.experimental.omsi\_mask\_by\_cluster (module)}
Module for performing making a mask from cluster matrix for MSI data.
\index{omsi\_mask\_by\_cluster (class in omsi.analysis.msi\_filtering.experimental.omsi\_mask\_by\_cluster)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.experimental.omsi_mask_by_cluster.omsi_mask_by_cluster}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.msi\_filtering.experimental.omsi\_mask\_by\_cluster.}\bfcode{omsi\_mask\_by\_cluster}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Class defining a basic mask creation a 2D MSI data file or slice of the data

Initalize the basic data members
\index{execute\_analysis() (omsi.analysis.msi\_filtering.experimental.omsi\_mask\_by\_cluster.omsi\_mask\_by\_cluster method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.experimental.omsi_mask_by_cluster.omsi_mask_by_cluster.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
\end{fulllineitems}

\index{v\_qmz() (omsi.analysis.msi\_filtering.experimental.omsi\_mask\_by\_cluster.omsi\_mask\_by\_cluster class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.experimental.omsi_mask_by_cluster.omsi_mask_by_cluster.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Get the mz axes for the analysis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{qslice\_viewer\_option}} -- If multiple default viewer behaviors are available for a
given analysis then this option is used to switch between them for the qslice URL pattern.

\item {} 
\textbf{\texttt{qspectrum\_viewer\_option}} -- If multiple default viewer behaviors are available for a
given analysis then this option is used to switch between them for the qspectrum URL pattern.

\end{itemize}

\item[{Returns}] \leavevmode

The following four arrays are returned by the analysis:
\begin{itemize}
\item {} 
mz\_spectra : Array with the static mz values for the spectra.

\item {} 
label\_spectra : Lable for the spectral mz axis

\item {} 
mz\_slice : Array of the static mz values for the slices or None if identical to the mz\_spectra.

\item {} 
label\_slice : Lable for the slice mz axis or None if identical to label\_spectra.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice() (omsi.analysis.msi\_filtering.experimental.omsi\_mask\_by\_cluster.omsi\_mask\_by\_cluster class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.experimental.omsi_mask_by_cluster.omsi_mask_by_cluster.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Get 3D analysis dataset for which z-slices should be extracted for presentation in the OMSI viewer
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{z}} -- Selection string indicting which z values should be selected.

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for
a given analysis then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode
numpy array with the data to be displayed in the image slice viewer.
Slicing will be performed typically like {[}:,:,zmin:zmax{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.analysis.msi\_filtering.experimental.omsi\_mask\_by\_cluster.omsi\_mask\_by\_cluster class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.experimental.omsi_mask_by_cluster.omsi_mask_by_cluster.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qslice.
The default implementation tries to take care of handling the spectra retrieval for all the depencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.
For most cases this is not needed here as the support for slice operations is usually a
static decision based on the class type, however, in some cases additional checks may be
needed (e.g., ensure that the required data is available).

\item[{Returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be
empty if the analysis does not support qslice requests (i.e., v\_qslice(...) is not available).

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum() (omsi.analysis.msi\_filtering.experimental.omsi\_mask\_by\_cluster.omsi\_mask\_by\_cluster class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.experimental.omsi_mask_by_cluster.omsi_mask_by_cluster.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Get from which 3D analysis spectra in x/y should be extracted for presentation in the OMSI viewer
\begin{description}
\item[{Developer Note: h5py currently supports only a single index list. If the user provides an index-list for both}] \leavevmode
x and y, then we need to construct the proper merged list and load the data manually, or if
the data is small enough, one can load the full data into a numpy array which supports
mulitple lists in the selection.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{x}} -- x selection string

\item {} 
\textbf{\texttt{y}} -- y selection string

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given
analysis then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode

The following two elemnts are expected to be returned by this function :
\begin{enumerate}
\item {} 
1D, 2D or 3D numpy array of the requested spectra. NOTE: The mass (m/z) axis must be the last axis.                For index selection x=1,y=1 a 1D array is usually expected. For indexList selections x={[}0{]}\&y={[}1{]}                usually a 2D array is expected. For ragne selections x=0:1\&y=1:2 we one usually expects a 3D array.

\item {} 
None in case that the spectra axis returned by v\_qmz are valid for the returned spectrum. Otherwise,                return a 1D numpy array with the m/z values for the spectrum (i.e., if custom m/z values are needed                for interpretation of the returned spectrum).This may be needed, e.g., in cases where a per-spectrum                peak analysis is performed and the peaks for each spectrum appear at different m/z values.

\end{enumerate}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.analysis.msi\_filtering.experimental.omsi\_mask\_by\_cluster.omsi\_mask\_by\_cluster class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.msi_filtering:omsi.analysis.msi_filtering.experimental.omsi_mask_by_cluster.omsi_mask_by_cluster.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qspectrum.
The default implementation tries to take care of handling the spectra retrieval for all the dependencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}
\begin{quote}\begin{description}
\item[{param analysis\_object}] \leavevmode
The omsi\_file\_analysis object for which slicing should be performed.
For most cases this is not needed here as the support for slice operations is usually a
static decission based on the class type, however, in some cases additional checks
may be needed (e.g., ensure that the required data is available).

\item[{returns}] \leavevmode
List of strings indicating the different available viewer options. The list should
be empty if the analysis does not support qspectrum requests
(i.e., v\_qspectrum(...) is not available).

\end{description}\end{quote}
\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{compound\_stats Package}
\label{omsi.analysis.compound_stats:compound-stats-package}\label{omsi.analysis.compound_stats::doc}

\subparagraph{\texttt{compound\_stats} Package}
\label{omsi.analysis.compound_stats:id1}\phantomsection\label{omsi.analysis.compound_stats:module-omsi.analysis.compound_stats}\index{omsi.analysis.compound\_stats (module)}
Package containing shared third-party code modules included here to reduce the need for external
dependencies when only small parts of external code are used.


\subparagraph{\texttt{omsi\_score\_midas} Module}
\label{omsi.analysis.compound_stats:omsi-score-midas-module}\label{omsi.analysis.compound_stats:module-omsi.analysis.compound_stats.omsi_score_midas}\index{omsi.analysis.compound\_stats.omsi\_score\_midas (module)}
MIDAS spectrum analysis
\index{omsi\_score\_midas (class in omsi.analysis.compound\_stats.omsi\_score\_midas)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.compound_stats:omsi.analysis.compound_stats.omsi_score_midas.omsi_score_midas}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.compound\_stats.omsi\_score\_midas.}\bfcode{omsi\_score\_midas}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Class for executing midas on an MSI or local peak finding dataset.

Initialize the basic data members
\index{execute\_analysis() (omsi.analysis.compound\_stats.omsi\_score\_midas.omsi\_score\_midas method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.compound_stats:omsi.analysis.compound_stats.omsi_score_midas.omsi_score_midas.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{\emph{spectrum\_indexes=None}, \emph{compound\_list=None}}{}
Execute the local peak finder for the given msidata.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{spectrum\_indexes}} -- List with a list of integer indicies of the subset of sepctra
that should be processed by this MPI task.  If spectrum\_indexes is set, then the given
subblock will be processed in SERIAL instead of processing self{[}'fpl\_data'{]} in PARALLEL
(if available). This parameter is strictly optional and intended for internal use only
to facilitate the efficient parallel implementation.

\item {} 
\textbf{\texttt{compound\_list}} -- List of the compounds from the database file. This parameter is used
to avoid having to read the compound database on every compute task that calls this function
when running in parallel.  This  parameter is strictly optional and intended for internal
use only to facilitate the efficient parallel implementation.

\end{itemize}

\item[{Returns}] \leavevmode

A tuple with an array of hit\_tables with the scores for each pixel and a 2D array
of pixel indices describing for each spectrum the (x,y) pixel location in the image. The
hit\_table is an array of (\#spectra x \#compounds). The hit\_table is a structured numpy
array with the following columns:
\begin{itemize}
\item {} 
`score',  float,  MIDAS score of row

\item {} 
`id',     str,    database ID e.g. `MetaCyC\_7884'

\item {} 
`name',   str,    database name, e.g. `glycine'

\item {} 
`mass',   float,  mass in Da of IDed compound

\item {} 
`n\_peaks', int,   number of peaks in data

\item {} 
`n\_match', int,   number of peaks in data matched

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{\texttt{omsi\_score\_pactolus} Module}
\label{omsi.analysis.compound_stats:module-omsi.analysis.compound_stats.omsi_score_pactolus}\label{omsi.analysis.compound_stats:omsi-score-pactolus-module}\index{omsi.analysis.compound\_stats.omsi\_score\_pactolus (module)}
MIDAS spectrum analysis
\index{omsi\_score\_pactolus (class in omsi.analysis.compound\_stats.omsi\_score\_pactolus)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.compound_stats:omsi.analysis.compound_stats.omsi_score_pactolus.omsi_score_pactolus}\pysiglinewithargsret{\strong{class }\code{omsi.analysis.compound\_stats.omsi\_score\_pactolus.}\bfcode{omsi\_score\_pactolus}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Class for executing Pactolus on a local peak finding dataset.

Initialize the basic data members
\index{execute\_analysis() (omsi.analysis.compound\_stats.omsi\_score\_pactolus.omsi\_score\_pactolus method)}

\begin{fulllineitems}
\phantomsection\label{omsi.analysis.compound_stats:omsi.analysis.compound_stats.omsi_score_pactolus.omsi_score_pactolus.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{\emph{spectrum\_indexes=None}, \emph{file\_lookup\_table=None}}{}
Execute the local peak finder for the given msidata.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{spectrum\_indexes}} -- List with a list of integer indicies of the subset of sepctra
that should be processed by this MPI task.  If spectrum\_indexes is set, then the given
subblock will be processed in SERIAL instead of processing self{[}'fpl\_data'{]} in PARALLEL
(if available). This parameter is strictly optional and intended for internal use only
to facilitate the efficient parallel implementation.

\item {} 
\textbf{\texttt{file\_lookup\_table}} -- The Pactolus lookup table with the list of tree files and their mass.

\end{itemize}

\item[{Returns}] \leavevmode

A series of numpy arrays  with the score data for each pixel and a 2D array
of pixel indices describing for each spectrum the (x,y) pixel location in the image.
\begin{description}
\item[{{[}'pixel\_index', `score', `id', `name', `mass', `n\_peaks', `n\_match'{]}}] \leavevmode\begin{itemize}
\item {} 
`pixel\_index'  , int,  2D array of pixel indices describing for each spectrum                    the (x,y) pixel location in the imag

\item {} 
`score',  float,  MIDAS score of row

\item {} 
`id',     str,    database ID e.g. `MetaCyC\_7884'

\item {} 
`name',   str,    database name, e.g. `glycine'

\item {} 
`mass',   float,  mass in Da of IDed compound

\item {} 
`n\_peaks', int,   number of peaks in data

\item {} 
`n\_match', int,   number of peaks in data matched

\end{itemize}

\end{description}


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{compound\_stats.third\_party Package}
\label{omsi.analysis.compound_stats:compound-stats-third-party-package}

\subparagraph{\texttt{compound\_stats.third\_party} Package}
\label{omsi.analysis.compound_stats:id2}\phantomsection\label{omsi.analysis.compound_stats:module-omsi.analysis.compound_stats.third_party}\index{omsi.analysis.compound\_stats.third\_party (module)}
Package containing shared third-party code modules included here to reduce the need for external
dependencies when only small parts of external code are used.


\paragraph{compound\_stats.experimental Package}
\label{omsi.analysis.compound_stats:compound-stats-experimental-package}

\subparagraph{\texttt{compound\_stats.experimental} Package}
\label{omsi.analysis.compound_stats:id3}\phantomsection\label{omsi.analysis.compound_stats:module-omsi.analysis.compound_stats.experimental}\index{omsi.analysis.compound\_stats.experimental (module)}
Module with experimental analysis code, i.e., code that is
not (yet) used in production but is under development.
Often this is code that is used in a specific research.


\subsection{dataformat Package}
\label{omsi.dataformat:dataformat-package}\label{omsi.dataformat::doc}
Main module for specification of data formats. This module also contains the
\emph{omsi\_file} module which specifies the OpenMSI HDF5 data format. In addition
it defines the base class for third-party file readers (i.e, \emph{file\_reader\_base})
and implements various basic file readers for third-party formats, e.g,
\emph{img\_file} and \emph{mzml\_file} for IMG and MZML data files respectively (among others).

\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


{\hyperref[omsi.dataformat.omsi_file:module\string-omsi.dataformat.omsi_file]{\emph{\code{omsi.dataformat.omsi\_file}}}}
 & 
Module for specification of the OpenMSI file API.
\\
\hline
{\hyperref[omsi.dataformat.omsi_file:module\string-omsi.dataformat.omsi_file.analysis]{\emph{\code{omsi.dataformat.omsi\_file.analysis}}}}
 & 
Module for managing custom analysis data in OMSI HDF5 files.
\\
\hline
{\hyperref[omsi.dataformat.omsi_file:module\string-omsi.dataformat.omsi_file.common]{\emph{\code{omsi.dataformat.omsi\_file.common}}}}
 & 
Module for common data format classes and functionality.
\\
\hline
{\hyperref[omsi.dataformat.omsi_file:module\string-omsi.dataformat.omsi_file.dependencies]{\emph{\code{omsi.dataformat.omsi\_file.dependencies}}}}
 & 
Base module for managing of dependencies between data in OpenMSI HDF5 files
\\
\hline
{\hyperref[omsi.dataformat.omsi_file:module\string-omsi.dataformat.omsi_file.experiment]{\emph{\code{omsi.dataformat.omsi\_file.experiment}}}}
 & 
OMSI file module for management of experiment data.
\\
\hline
{\hyperref[omsi.dataformat.omsi_file:module\string-omsi.dataformat.omsi_file.format]{\emph{\code{omsi.dataformat.omsi\_file.format}}}}
 & 
This module defines the basic format for storing mass spectrometry imaging data, metadata, and analysis in HDF5 in compliance with OpenMSI file format.
\\
\hline
{\hyperref[omsi.dataformat.omsi_file:module\string-omsi.dataformat.omsi_file.instrument]{\emph{\code{omsi.dataformat.omsi\_file.instrument}}}}
 & 
Module for managing instrument related data in OMSI files.
\\
\hline
{\hyperref[omsi.dataformat.omsi_file:module\string-omsi.dataformat.omsi_file.main_file]{\emph{\code{omsi.dataformat.omsi\_file.main\_file}}}}
 & 
Module for managing OpenMSI HDF5 data files.
\\
\hline
{\hyperref[omsi.dataformat.omsi_file:module\string-omsi.dataformat.omsi_file.metadata_collection]{\emph{\code{omsi.dataformat.omsi\_file.metadata\_collection}}}}
 & 
Module for management of general metadata storage entities.
\\
\hline
{\hyperref[omsi.dataformat.omsi_file:module\string-omsi.dataformat.omsi_file.methods]{\emph{\code{omsi.dataformat.omsi\_file.methods}}}}
 & 
Module for management of method specific data in OMSI data files
\\
\hline
{\hyperref[omsi.dataformat.omsi_file:module\string-omsi.dataformat.omsi_file.msidata]{\emph{\code{omsi.dataformat.omsi\_file.msidata}}}}
 & 
Module for managing MSI data in OMSI data files
\\
\hline
{\hyperref[omsi.dataformat:module\string-omsi.dataformat.file_reader_base]{\emph{\code{omsi.dataformat.file\_reader\_base}}}}
 & 
Module for base classes for implementation and integration of third-party file readers.
\\
\hline
{\hyperref[omsi.dataformat:module\string-omsi.dataformat.bruckerflex_file]{\emph{\code{omsi.dataformat.bruckerflex\_file}}}}
 & 
This module provides functionality for reading bruker flex mass spectrometry image files
\\
\hline
{\hyperref[omsi.dataformat:module\string-omsi.dataformat.img_file]{\emph{\code{omsi.dataformat.img\_file}}}}
 & 
This module provides functionality for reading img mass spectrometry image files
\\
\hline
\code{omsi.dataformat.imzml\_file}
 & 

\\
\hline
\code{omsi.dataformat.mzml\_file}
 & 

\\
\hline\end{longtable}



\subsubsection{OMSI Dataformat Package}
\label{omsi.dataformat.omsi_file:omsi-dataformat-package}\label{omsi.dataformat.omsi_file::doc}
Main module for specification of the OpenMSI HDF5-based data format.
The module contains various sub-modules, with the main goal to
organize different categories of data.

Naming conventions for objects inside the HDF5 file are defined
in the \emph{omsi\_file.format} module. These are used by the manager
API classes to then implement the specific format.

The basic idea behind the design of the OpenMSI file format is the
concept of managed objects. Managed objects are objects in an HDF5 file
(usually HDF5 Groups --similar to directories just within a file)
that have a corresponding interface class in the API. These
classes in the API always start with the prefix \emph{omsi\_file\_} and
inherit from \emph{omsi\_file.common.omsi\_file\_common}.

To make it easy to nest different objects, we also have the concept
of manager helper classes, which encapsulate common functionality
for creation and interaction with the objects when they are
contained in another object. Manager helper classes follow the
following naming convection \emph{omsi\_\textless{}objectname\textgreater{}\_manager}, where
objectname is name of the object to be managed. E.g,
\emph{omsi\_instrument\_manager} is used to help place instrument
groups inside another managed object. This is done by inheriting
from the given manager helper class.

This means, multiple inheritance is used in order to nest other
managed modules with other interfaces. This allows us to easily
encapsulate common interaction features in centralized locations
and construct more complex containers simply via inheritance.

The user of multiple inheritance and \emph{super} can be tricky in python.
To simplify the use and ensure stability we use the following conventions:
\begin{itemize}
\item {} 
All \emph{omsi\_file\_*} manager classes must except the h5py.Group object
they manage as input and call \emph{super(..)\_\_init\_\_(managed\_group)}
with the managed group as parameter in their \emph{\_\_init\_\_}.

\item {} 
All \emph{omsi\_\textless{}objectname\textgreater{}\_manager} manager helper classes must except
the h5py.Group that contains the object(s) that should be managed
using the helper class as input and call \emph{super(..)\_\_init\_\_(managed\_group)}
with the managed group as parameter in their in \emph{\_\_init\_\_}.

\item {} 
All \emph{omsi\_file\_*} manager classes must inherit from \emph{omsi\_file.common.omsi\_file\_common}

\item {} 
All \emph{omsi\_\textless{}objectname\textgreater{}\_manager} manager helper classes must inherit from \emph{object}
(i.e., we use new-style classes).

\end{itemize}


\paragraph{\texttt{omsi\_file} Package}
\label{omsi.dataformat.omsi_file:omsi-file-package}\label{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file}\index{omsi.dataformat.omsi\_file (module)}
Module for specification of the OpenMSI file API.


\paragraph{\texttt{format} Module}
\label{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.format}\label{omsi.dataformat.omsi_file:format-module}\index{omsi.dataformat.omsi\_file.format (module)}
This module defines the basic format for storing mass spectrometry imaging data,
metadata, and analysis in HDF5 in compliance with OpenMSI file format.
\index{omsi\_format\_analysis (class in omsi.dataformat.omsi\_file.format)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_analysis}\pysigline{\strong{class }\code{omsi.dataformat.omsi\_file.format.}\bfcode{omsi\_format\_analysis}}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_common]{\emph{\code{omsi.dataformat.omsi\_file.format.omsi\_format\_common}}}}

Specification for storing analysis related data.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_analysis.analysis_groupname]{\emph{\textbf{\texttt{analysis\_groupname}}}}} -- \emph{analysis\_} : Group with additional analysis results

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_analysis.analysis_identifier]{\emph{\textbf{\texttt{analysis\_identifier}}}}} -- \emph{analysis\_identifier} : Identifier for the analysis to enable look-up by analysis id

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_analysis.analysis_type]{\emph{\textbf{\texttt{analysis\_type}}}}} -- \emph{analysis\_type} : Dataset used to store the analysis type descriptor string

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_analysis.analysis_parameter_group]{\emph{\textbf{\texttt{analysis\_parameter\_group}}}}} -- Group for storing analysis parameters. Dependent parameters are stored
separately using a omsi\_format\_dependencies group.

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_analysis.analysis_runinfo_group]{\emph{\textbf{\texttt{analysis\_runinfo\_group}}}}} -- Group for storing run information, e.g., where was the analysis run, how long
did it take etc.

\end{itemize}

\end{description}\end{quote}
\index{analysis\_groupname (omsi.dataformat.omsi\_file.format.omsi\_format\_analysis attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_analysis.analysis_groupname}\pysigline{\bfcode{analysis\_groupname}\strong{ = `analysis\_'}}
\end{fulllineitems}

\index{analysis\_identifier (omsi.dataformat.omsi\_file.format.omsi\_format\_analysis attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_analysis.analysis_identifier}\pysigline{\bfcode{analysis\_identifier}\strong{ = `analysis\_identifier'}}
\end{fulllineitems}

\index{analysis\_parameter\_group (omsi.dataformat.omsi\_file.format.omsi\_format\_analysis attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_analysis.analysis_parameter_group}\pysigline{\bfcode{analysis\_parameter\_group}\strong{ = `parameter'}}
\end{fulllineitems}

\index{analysis\_parameter\_help\_attr (omsi.dataformat.omsi\_file.format.omsi\_format\_analysis attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_analysis.analysis_parameter_help_attr}\pysigline{\bfcode{analysis\_parameter\_help\_attr}\strong{ = `help'}}
\end{fulllineitems}

\index{analysis\_runinfo\_group (omsi.dataformat.omsi\_file.format.omsi\_format\_analysis attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_analysis.analysis_runinfo_group}\pysigline{\bfcode{analysis\_runinfo\_group}\strong{ = `runinfo'}}
\end{fulllineitems}

\index{analysis\_type (omsi.dataformat.omsi\_file.format.omsi\_format\_analysis attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_analysis.analysis_type}\pysigline{\bfcode{analysis\_type}\strong{ = `analysis\_type'}}
\end{fulllineitems}

\index{current\_version (omsi.dataformat.omsi\_file.format.omsi\_format\_analysis attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_analysis.current_version}\pysigline{\bfcode{current\_version}\strong{ = `0.2'}}
\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_format\_common (class in omsi.dataformat.omsi\_file.format)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_common}\pysigline{\strong{class }\code{omsi.dataformat.omsi\_file.format.}\bfcode{omsi\_format\_common}}
Bases: \code{object}

Specification of common attributes, and names for the file format.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_common.str_type]{\emph{\textbf{\texttt{str\_type}}}}} -- \emph{str\_type  = h5py.new\_vlen(str)} : Datatype used for storing strings in hdf5

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_common.type_attribute]{\emph{\textbf{\texttt{type\_attribute}}}}} -- Name of the optional type attribute indicating which omsi\_file\_* class
should be used to interact with a given group.

\end{itemize}

\end{description}\end{quote}
\index{current\_version (omsi.dataformat.omsi\_file.format.omsi\_format\_common attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_common.current_version}\pysigline{\bfcode{current\_version}\strong{ = `0.1'}}
\end{fulllineitems}

\index{str\_type (omsi.dataformat.omsi\_file.format.omsi\_format\_common attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_common.str_type}\pysigline{\bfcode{str\_type}\strong{ = dtype(`O')}}
\end{fulllineitems}

\index{str\_type\_unicode (omsi.dataformat.omsi\_file.format.omsi\_format\_common attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_common.str_type_unicode}\pysigline{\bfcode{str\_type\_unicode}\strong{ = True}}
\end{fulllineitems}

\index{timestamp\_attribute (omsi.dataformat.omsi\_file.format.omsi\_format\_common attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_common.timestamp_attribute}\pysigline{\bfcode{timestamp\_attribute}\strong{ = `timestamp'}}
\end{fulllineitems}

\index{type\_attribute (omsi.dataformat.omsi\_file.format.omsi\_format\_common attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_common.type_attribute}\pysigline{\bfcode{type\_attribute}\strong{ = `omsi\_type'}}
\end{fulllineitems}

\index{version\_attribute (omsi.dataformat.omsi\_file.format.omsi\_format\_common attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_common.version_attribute}\pysigline{\bfcode{version\_attribute}\strong{ = `version'}}
\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_format\_data (class in omsi.dataformat.omsi\_file.format)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_data}\pysigline{\strong{class }\code{omsi.dataformat.omsi\_file.format.}\bfcode{omsi\_format\_data}}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_common]{\emph{\code{omsi.dataformat.omsi\_file.format.omsi\_format\_common}}}}

Specification for storing raw data information.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_data.data_groupname]{\emph{\textbf{\texttt{data\_groupname}}}}} -- The base name for the hdf5 group containing the imaging data

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_data.dataset_name]{\emph{\textbf{\texttt{dataset\_name}}}}} -- The base name for storing raw data. In the case of MSI data, this is                         the 3D data cube stored as 3D (full\_cube), 2D (partial\_cube) or                         1D (partial\_spectra) dataset, depending on the format\_type.

\item {} 
\textbf{\texttt{data\_dependency\_group}} -- Optional group for storing data dependencies

\end{itemize}

\end{description}\end{quote}
\index{current\_version (omsi.dataformat.omsi\_file.format.omsi\_format\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_data.current_version}\pysigline{\bfcode{current\_version}\strong{ = `0.1'}}
\end{fulllineitems}

\index{data\_groupname (omsi.dataformat.omsi\_file.format.omsi\_format\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_data.data_groupname}\pysigline{\bfcode{data\_groupname}\strong{ = `data\_'}}
\end{fulllineitems}

\index{dataset\_name (omsi.dataformat.omsi\_file.format.omsi\_format\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_data.dataset_name}\pysigline{\bfcode{dataset\_name}\strong{ = `data\_'}}
\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_format\_dependencies (class in omsi.dataformat.omsi\_file.format)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_dependencies}\pysigline{\strong{class }\code{omsi.dataformat.omsi\_file.format.}\bfcode{omsi\_format\_dependencies}}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_common]{\emph{\code{omsi.dataformat.omsi\_file.format.omsi\_format\_common}}}}

Specification for the management of a collection of dependencies.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_dependencies.dependencies_groupname]{\emph{\textbf{\texttt{dependencies\_groupname}}}}} -- \emph{dependency} : Name of the group the dependencies are stored in.

\end{description}\end{quote}
\index{current\_version (omsi.dataformat.omsi\_file.format.omsi\_format\_dependencies attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_dependencies.current_version}\pysigline{\bfcode{current\_version}\strong{ = `0.1'}}
\end{fulllineitems}

\index{dependencies\_groupname (omsi.dataformat.omsi\_file.format.omsi\_format\_dependencies attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_dependencies.dependencies_groupname}\pysigline{\bfcode{dependencies\_groupname}\strong{ = `dependency'}}
\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_format\_dependencydata (class in omsi.dataformat.omsi\_file.format)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_dependencydata}\pysigline{\strong{class }\code{omsi.dataformat.omsi\_file.format.}\bfcode{omsi\_format\_dependencydata}}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_common]{\emph{\code{omsi.dataformat.omsi\_file.format.omsi\_format\_common}}}}

Specification for the storage of a single dependency.

This type of group does not have specific name to allow the user to specify a specific link\_name
to ease retrieval of the data.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_dependencydata.dependency_parameter]{\emph{\textbf{\texttt{dependency\_parameter}}}}} -- \emph{parameter\_name} : Name of string dataset used to store the name of
the dependent parameter

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_dependencydata.dependency_selection]{\emph{\textbf{\texttt{dependency\_selection}}}}} -- \emph{selection} : Name of the string dataset used to store a selection string if needed.

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_dependencydata.dependency_mainname]{\emph{\textbf{\texttt{dependency\_mainname}}}}} -- \emph{main\_name} : Name of the string dataset used to store the description of the
link to the object that this depends on.

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_dependencydata.dependency_datasetname]{\emph{\textbf{\texttt{dependency\_datasetname}}}}} -- `data\_name{}` : Name fo the string dataset used to store the name of dataset
within the mainname highlevel object.

\end{itemize}

\end{description}\end{quote}
\index{current\_version (omsi.dataformat.omsi\_file.format.omsi\_format\_dependencydata attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_dependencydata.current_version}\pysigline{\bfcode{current\_version}\strong{ = `0.3'}}
\end{fulllineitems}

\index{dependency\_datasetname (omsi.dataformat.omsi\_file.format.omsi\_format\_dependencydata attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_dependencydata.dependency_datasetname}\pysigline{\bfcode{dependency\_datasetname}\strong{ = `data\_name'}}
\end{fulllineitems}

\index{dependency\_mainname (omsi.dataformat.omsi\_file.format.omsi\_format\_dependencydata attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_dependencydata.dependency_mainname}\pysigline{\bfcode{dependency\_mainname}\strong{ = `main\_name'}}
\end{fulllineitems}

\index{dependency\_parameter (omsi.dataformat.omsi\_file.format.omsi\_format\_dependencydata attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_dependencydata.dependency_parameter}\pysigline{\bfcode{dependency\_parameter}\strong{ = `parameter\_name'}}
\end{fulllineitems}

\index{dependency\_parameter\_help\_attr (omsi.dataformat.omsi\_file.format.omsi\_format\_dependencydata attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_dependencydata.dependency_parameter_help_attr}\pysigline{\bfcode{dependency\_parameter\_help\_attr}\strong{ = `help'}}
\end{fulllineitems}

\index{dependency\_selection (omsi.dataformat.omsi\_file.format.omsi\_format\_dependencydata attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_dependencydata.dependency_selection}\pysigline{\bfcode{dependency\_selection}\strong{ = `selection'}}
\end{fulllineitems}

\index{dependency\_typename (omsi.dataformat.omsi\_file.format.omsi\_format\_dependencydata attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_dependencydata.dependency_typename}\pysigline{\bfcode{dependency\_typename}\strong{ = `dependency\_type'}}
\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_format\_experiment (class in omsi.dataformat.omsi\_file.format)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_experiment}\pysigline{\strong{class }\code{omsi.dataformat.omsi\_file.format.}\bfcode{omsi\_format\_experiment}}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_common]{\emph{\code{omsi.dataformat.omsi\_file.format.omsi\_format\_common}}}}

Specification of file format specific name conventions
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_experiment.exp_groupname]{\emph{\textbf{\texttt{exp\_groupname}}}}} -- \emph{entry\_} : The base name for a group containing data about an experiment

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_experiment.exp_identifier_name]{\emph{\textbf{\texttt{exp\_identifier\_name}}}}} -- \emph{experiment\_identifier} : The identifier dataset for an experiment

\end{itemize}

\end{description}\end{quote}
\index{current\_version (omsi.dataformat.omsi\_file.format.omsi\_format\_experiment attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_experiment.current_version}\pysigline{\bfcode{current\_version}\strong{ = `0.1'}}
\end{fulllineitems}

\index{exp\_groupname (omsi.dataformat.omsi\_file.format.omsi\_format\_experiment attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_experiment.exp_groupname}\pysigline{\bfcode{exp\_groupname}\strong{ = `entry\_'}}
\end{fulllineitems}

\index{exp\_identifier\_name (omsi.dataformat.omsi\_file.format.omsi\_format\_experiment attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_experiment.exp_identifier_name}\pysigline{\bfcode{exp\_identifier\_name}\strong{ = `experiment\_identifier'}}
\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_format\_file (class in omsi.dataformat.omsi\_file.format)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_file}\pysigline{\strong{class }\code{omsi.dataformat.omsi\_file.format.}\bfcode{omsi\_format\_file}}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_common]{\emph{\code{omsi.dataformat.omsi\_file.format.omsi\_format\_common}}}}

Specification of main-file related specific name conventions
\index{current\_version (omsi.dataformat.omsi\_file.format.omsi\_format\_file attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_file.current_version}\pysigline{\bfcode{current\_version}\strong{ = `0.1'}}
\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_format\_instrument (class in omsi.dataformat.omsi\_file.format)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_instrument}\pysigline{\strong{class }\code{omsi.dataformat.omsi\_file.format.}\bfcode{omsi\_format\_instrument}}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_metadata_collection]{\emph{\code{omsi.dataformat.omsi\_file.format.omsi\_format\_metadata\_collection}}}}

Specification for storing instrument related information
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_instrument.instrument_groupname]{\emph{\textbf{\texttt{instrument\_groupname}}}}} -- \emph{instrument}  : Group with information about the intrument used

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_instrument.instrument_mz_name]{\emph{\textbf{\texttt{instrument\_mz\_name}}}}} -- \emph{mz} : Name of the dataset for the intrument's mz data values

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_instrument.instrument_name]{\emph{\textbf{\texttt{instrument\_name}}}}} -- \emph{name} : The dataset with the name of the instrument

\end{itemize}

\end{description}\end{quote}
\index{current\_version (omsi.dataformat.omsi\_file.format.omsi\_format\_instrument attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_instrument.current_version}\pysigline{\bfcode{current\_version}\strong{ = `0.2'}}
\end{fulllineitems}

\index{instrument\_groupname (omsi.dataformat.omsi\_file.format.omsi\_format\_instrument attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_instrument.instrument_groupname}\pysigline{\bfcode{instrument\_groupname}\strong{ = `instrument'}}
\end{fulllineitems}

\index{instrument\_mz\_name (omsi.dataformat.omsi\_file.format.omsi\_format\_instrument attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_instrument.instrument_mz_name}\pysigline{\bfcode{instrument\_mz\_name}\strong{ = `mz'}}
\end{fulllineitems}

\index{instrument\_name (omsi.dataformat.omsi\_file.format.omsi\_format\_instrument attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_instrument.instrument_name}\pysigline{\bfcode{instrument\_name}\strong{ = `name'}}
\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_format\_metadata\_collection (class in omsi.dataformat.omsi\_file.format)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_metadata_collection}\pysigline{\strong{class }\code{omsi.dataformat.omsi\_file.format.}\bfcode{omsi\_format\_metadata\_collection}}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_common]{\emph{\code{omsi.dataformat.omsi\_file.format.omsi\_format\_common}}}}

Specification of the basic format for a general-purpose metadata storage
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_metadata_collection.metadata_collection_groupname_default]{\emph{\textbf{\texttt{metadata\_collection\_groupname\_default}}}}} -- Default name for the group where
the collection of metadata is stored.

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_metadata_collection.description_value_attribute]{\emph{\textbf{\texttt{description\_value\_attribute}}}}} -- The attribute to be associated with each
metadata value describing the content in a human-readable form

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_metadata_collection.unit_value_attribute]{\emph{\textbf{\texttt{unit\_value\_attribute}}}}} -- The attribute to be associated with each metatdata
value describing the unit

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_metadata_collection.ontology_value_attribute]{\emph{\textbf{\texttt{ontology\_value\_attribute}}}}} -- Optional ontology associated with a metadata value

\end{itemize}

\end{description}\end{quote}
\index{current\_version (omsi.dataformat.omsi\_file.format.omsi\_format\_metadata\_collection attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_metadata_collection.current_version}\pysigline{\bfcode{current\_version}\strong{ = `0.1'}}
\end{fulllineitems}

\index{description\_value\_attribute (omsi.dataformat.omsi\_file.format.omsi\_format\_metadata\_collection attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_metadata_collection.description_value_attribute}\pysigline{\bfcode{description\_value\_attribute}\strong{ = `description'}}
\end{fulllineitems}

\index{metadata\_collection\_groupname\_default (omsi.dataformat.omsi\_file.format.omsi\_format\_metadata\_collection attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_metadata_collection.metadata_collection_groupname_default}\pysigline{\bfcode{metadata\_collection\_groupname\_default}\strong{ = `metadata'}}
\end{fulllineitems}

\index{ontology\_value\_attribute (omsi.dataformat.omsi\_file.format.omsi\_format\_metadata\_collection attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_metadata_collection.ontology_value_attribute}\pysigline{\bfcode{ontology\_value\_attribute}\strong{ = `ontology'}}
\end{fulllineitems}

\index{unit\_value\_attribute (omsi.dataformat.omsi\_file.format.omsi\_format\_metadata\_collection attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_metadata_collection.unit_value_attribute}\pysigline{\bfcode{unit\_value\_attribute}\strong{ = `unit'}}
\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_format\_methods (class in omsi.dataformat.omsi\_file.format)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_methods}\pysigline{\strong{class }\code{omsi.dataformat.omsi\_file.format.}\bfcode{omsi\_format\_methods}}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_metadata_collection]{\emph{\code{omsi.dataformat.omsi\_file.format.omsi\_format\_metadata\_collection}}}}

Specification of the basic format for storing method-related information
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_methods.methods_groupname]{\emph{\textbf{\texttt{methods\_groupname}}}}} -- \emph{methods} : The group storing all the information about the method

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_methods.methods_old_groupname]{\emph{\textbf{\texttt{methods\_old\_groupname}}}}} -- \emph{method} : The group object was refactored to methods. To ensure that old
files can still be read, this variable was added and is checked as well if needed.

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_methods.methods_name]{\emph{\textbf{\texttt{methods\_name}}}}} -- \emph{name} : The dataset with the name of the method

\end{itemize}

\end{description}\end{quote}
\index{current\_version (omsi.dataformat.omsi\_file.format.omsi\_format\_methods attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_methods.current_version}\pysigline{\bfcode{current\_version}\strong{ = `0.3'}}
\end{fulllineitems}

\index{methods\_groupname (omsi.dataformat.omsi\_file.format.omsi\_format\_methods attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_methods.methods_groupname}\pysigline{\bfcode{methods\_groupname}\strong{ = `methods'}}
\end{fulllineitems}

\index{methods\_name (omsi.dataformat.omsi\_file.format.omsi\_format\_methods attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_methods.methods_name}\pysigline{\bfcode{methods\_name}\strong{ = `name'}}
\end{fulllineitems}

\index{methods\_old\_groupname (omsi.dataformat.omsi\_file.format.omsi\_format\_methods attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_methods.methods_old_groupname}\pysigline{\bfcode{methods\_old\_groupname}\strong{ = `sample'}}
\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_format\_msidata (class in omsi.dataformat.omsi\_file.format)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata}\pysigline{\strong{class }\code{omsi.dataformat.omsi\_file.format.}\bfcode{omsi\_format\_msidata}}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_data]{\emph{\code{omsi.dataformat.omsi\_file.format.omsi\_format\_data}}}}

Specification of the basic format for storing an MSI dataset consisting of a complete 3D cube
(or a 3D cube completed with 0s for missing data)
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata.format_types]{\emph{\textbf{\texttt{format\_types}}}}} -- Data layout types supported for storing MSI data.

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata.mzdata_name]{\emph{\textbf{\texttt{mzdata\_name}}}}} -- Global mz axis for the MSI data cube.

\item {} 
{\hyperref[omsi.dataformat.omsi_file:module\string-omsi.dataformat.omsi_file.format]{\emph{\textbf{\texttt{format}}}}} -- Dataset in HDF5 with the format\_type descriptor.

\end{itemize}

\end{description}\end{quote}
\index{current\_version (omsi.dataformat.omsi\_file.format.omsi\_format\_msidata attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata.current_version}\pysigline{\bfcode{current\_version}\strong{ = `0.1'}}
\end{fulllineitems}

\index{format\_name (omsi.dataformat.omsi\_file.format.omsi\_format\_msidata attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata.format_name}\pysigline{\bfcode{format\_name}\strong{ = `format'}}
\end{fulllineitems}

\index{format\_types (omsi.dataformat.omsi\_file.format.omsi\_format\_msidata attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata.format_types}\pysigline{\bfcode{format\_types}\strong{ = \{`full\_cube': 1, `partial\_cube': 2, `partial\_spectra': 3\}}}
\end{fulllineitems}

\index{mzdata\_name (omsi.dataformat.omsi\_file.format.omsi\_format\_msidata attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata.mzdata_name}\pysigline{\bfcode{mzdata\_name}\strong{ = `mz'}}
\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_format\_msidata\_partial\_cube (class in omsi.dataformat.omsi\_file.format)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata_partial_cube}\pysigline{\strong{class }\code{omsi.dataformat.omsi\_file.format.}\bfcode{omsi\_format\_msidata\_partial\_cube}}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata]{\emph{\code{omsi.dataformat.omsi\_file.format.omsi\_format\_msidata}}}}

Specification of the basic format for storing an MSI datasets that define a partial
cube with full spectra
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata_partial_cube.xy_index_name]{\emph{\textbf{\texttt{xy\_index\_name}}}}} -- 2D dataset indicating for each spectrum its start location in the the main dataset

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata_partial_cube.inv_xy_index_name]{\emph{\textbf{\texttt{inv\_xy\_index\_name}}}}} -- 2D dataset with n rows and 2 columns indicating for each spectrum i the (x,y)
pixel index the spectrum belongs to.  This index is stored for convenience purposes but
is not actually needed for data access.

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata_partial_cube.shape_name]{\emph{\textbf{\texttt{shape\_name}}}}} -- Simple {[}3{]} indicating the true image size in x,y,mz

\end{itemize}

\end{description}\end{quote}
\index{inv\_xy\_index\_name (omsi.dataformat.omsi\_file.format.omsi\_format\_msidata\_partial\_cube attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata_partial_cube.inv_xy_index_name}\pysigline{\bfcode{inv\_xy\_index\_name}\strong{ = `inv\_xy\_index'}}
\end{fulllineitems}

\index{shape\_name (omsi.dataformat.omsi\_file.format.omsi\_format\_msidata\_partial\_cube attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata_partial_cube.shape_name}\pysigline{\bfcode{shape\_name}\strong{ = `shape'}}
\end{fulllineitems}

\index{xy\_index\_name (omsi.dataformat.omsi\_file.format.omsi\_format\_msidata\_partial\_cube attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata_partial_cube.xy_index_name}\pysigline{\bfcode{xy\_index\_name}\strong{ = `xyindex'}}
\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_format\_msidata\_partial\_spectra (class in omsi.dataformat.omsi\_file.format)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata_partial_spectra}\pysigline{\strong{class }\code{omsi.dataformat.omsi\_file.format.}\bfcode{omsi\_format\_msidata\_partial\_spectra}}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata_partial_cube]{\emph{\code{omsi.dataformat.omsi\_file.format.omsi\_format\_msidata\_partial\_cube}}}}

Specification of the basic format for storing an MSI dataset of a full or
partial cube with partial spectra
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata_partial_spectra.mz_index_name]{\emph{\textbf{\texttt{mz\_index\_name}}}}} -- 1D dataset of the same size as the spectrum data, indicating the indices
into the global m/z list

\item {} 
{\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata_partial_spectra.xy_index_end_name]{\emph{\textbf{\texttt{xy\_index\_end\_name}}}}} -- 2D dataset indicating for each spectrum its end location (index not included)
in the the main dataset

\end{itemize}

\end{description}\end{quote}
\index{mz\_index\_name (omsi.dataformat.omsi\_file.format.omsi\_format\_msidata\_partial\_spectra attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata_partial_spectra.mz_index_name}\pysigline{\bfcode{mz\_index\_name}\strong{ = `mz\_index'}}
\end{fulllineitems}

\index{xy\_index\_end\_name (omsi.dataformat.omsi\_file.format.omsi\_format\_msidata\_partial\_spectra attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.format.omsi_format_msidata_partial_spectra.xy_index_end_name}\pysigline{\bfcode{xy\_index\_end\_name}\strong{ = `xyindexend'}}
\end{fulllineitems}


\end{fulllineitems}



\paragraph{\texttt{common} Module}
\label{omsi.dataformat.omsi_file:common-module}\label{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.common}\index{omsi.dataformat.omsi\_file.common (module)}
Module for common data format classes and functionality.
\index{omsi\_file\_common (class in omsi.dataformat.omsi\_file.common)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.common.}\bfcode{omsi\_file\_common}}{\emph{managed\_group}}{}
Bases: \code{object}

Base class for definition of file format modules for the OpenMSI data format.

\textbf{Use of super()}

This class inherits only from object and calls super in the \_\_init\_\_ without
parameters. In the standard design pattern of the \emph{omsi.dataformat.omsi\_file module},
it is, therefore, the last class we inherit from in the case of multiple inheritance.

Multiple inheritance is used in \emph{omsi.dataformat.omsi\_file module} when a class contains
other managed objects and uses the manager classes, e.g, omsi\_instrument\_mangager etc.
to get all the features needed to manage those objects.

All child classes of omsi\_file\_common also call super(..).\_\_init\_\_(manager\_group) but
using a single input parameter indicating the manager h5py.Group object that
contains the given object.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{managed\_group}} -- The h5py.Group object managed by the class

\item {} 
\textbf{\texttt{name}} -- The path to the object in the hdf5 file. Same as managed\_group.name

\item {} 
\textbf{\texttt{file}} -- The h5py.File object the managed\_group is associated with. Same as managed\_group.file

\end{itemize}

\end{description}\end{quote}
\index{create\_path\_string() (omsi.dataformat.omsi\_file.common.omsi\_file\_common static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common.create_path_string}\pysiglinewithargsret{\strong{static }\bfcode{create\_path\_string}}{\emph{filename}, \emph{objectname}}{}
Given the name of the file and the object path within the file,
create a string describing the external reference to the datra
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filename}} -- The full or relative path to the file

\item {} 
\textbf{\texttt{objectname}} -- The object path in the HDF5 file

\end{itemize}

\item[{Returns}] \leavevmode
String describing the path to the object

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_h5py\_object() (omsi.dataformat.omsi\_file.common.omsi\_file\_common class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common.get_h5py_object}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_h5py\_object}}{\emph{omsi\_object}, \emph{resolve\_dependencies=False}}{}
This static method is a convenience function used to retrieve the corresponding h5py
interface object for any omsi file API object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{omsi\_object}} -- omsi file API input object for which the corresponding h5py.Group, h5py.File, or
h5py.Dataset object should be retrieved. The omsi\_object input may itself also be
a h5py.Group, h5py.File, or h5py.Dataset, in which case omsi\_object itself is returned
by the function.

\item {} 
\textbf{\texttt{resolve\_dependencies}} -- Set to True if omsi\_file\_dependencydata objects should be resolved to retrieve
the dependent object the dependency is pointing to. Dependencies are resolved recursively,
i.e., if a dependency points to another dependency then that one will be resolved as well.
Default value is False, i.e., the omis\_file\_dependency object itself is returned.

\end{itemize}

\item[{Returns}] \leavevmode
h5py.Group, h5py.File, or h5py.Dataset corresponding to the given omsi\_object.

\item[{Raises}] \leavevmode
\textbf{\texttt{ValueError}} -- A ValueError is raised in case that an unsupported omsi\_object object is given, i.e.,
the input object is not a omsi\_file API object nor a h5py Group, File, or
Dataset object.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_managed\_group() (omsi.dataformat.omsi\_file.common.omsi\_file\_common method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common.get_managed_group}\pysiglinewithargsret{\bfcode{get\_managed\_group}}{}{}
Return the h5py object with the analysis data.

The returned object can be used to read data directly from the HDF5 file.
Write operations to the analysis group can be performed only if the
associated omsi\_file was opened with write permissions.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
h5py object for the analysis group.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_num\_items() (omsi.dataformat.omsi\_file.common.omsi\_file\_common class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common.get_num_items}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_num\_items}}{\emph{file\_group}, \emph{basename='`}}{}
Get the number of object with the given basename at the given path
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{file\_group}} -- The h5py object to be examined

\item {} 
\textbf{\texttt{basename}} -- The name that should be searched for.

\end{itemize}

\item[{Returns}] \leavevmode
Number of objects with the given basename at the given path

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_omsi\_object() (omsi.dataformat.omsi\_file.common.omsi\_file\_common class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common.get_omsi_object}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_omsi\_object}}{\emph{h5py\_object}, \emph{resolve\_dependencies=False}}{}
This static method is convenience function used to retrieve the corresponding interface class for a
given h5py group object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{h5py\_object}} -- h5py object for which the corresponding omsi\_file API object should be generated.
This may also be a string describing the requested object based on a combination of the
path to the file and a path ot the object \textless{}filename.h5\textgreater{}:\textless{}object\_path\textgreater{}

\item {} 
\textbf{\texttt{resolve\_dependencies}} -- Set to True if omsi\_file\_dependencydata objects should be resolved to retrieve
the dependent object the dependency is pointing to. Dependencies are resolved recursively,
i.e., if a dependency points to another dependency then that one will be resolved as well.
Default value is False, i.e., the omis\_file\_dependency object itself is returned.

\end{itemize}

\item[{Returns}] \leavevmode

None in case no corresponding object was found. Otherwise an instance of:
\begin{itemize}
\item {} 
omsi\_file : If the given object is a h5py.File object

\item {} 
omsi\_file\_experiment : If the given object is an experiment groupt

\item {} 
omsi\_file\_methods : If the given object is a method group

\item {} 
omsi\_file\_instrument : If the given object is an instrument group

\item {} 
omsi\_file\_analysis : If the given object is an analysis group

\item {} 
omsi\_file\_msidata : If the given object is a MSI data group

\item {} 
omsi\_file\_dependencydata : If the fiven object is a dependency group

\item {} 
The input h5py\_object: If the given object is a h5py.Dataset or h5py.Group

\item {} 
None: In case that an unknown type is given.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_timestamp() (omsi.dataformat.omsi\_file.common.omsi\_file\_common method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common.get_timestamp}\pysiglinewithargsret{\bfcode{get\_timestamp}}{}{}
Get the timestamp when the analysis group was created in the HDF5 file.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Python timestamp string generated using time.ctime().
None may be returned in case that the timestamp does not exists
or cannot be retrieved from the file for some reason.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_version() (omsi.dataformat.omsi\_file.common.omsi\_file\_common method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common.get_version}\pysiglinewithargsret{\bfcode{get\_version}}{}{}
Get the omsi version for the representation of this object in the HDF5 file

\end{fulllineitems}

\index{is\_managed() (omsi.dataformat.omsi\_file.common.omsi\_file\_common class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common.is_managed}\pysiglinewithargsret{\strong{classmethod }\bfcode{is\_managed}}{\emph{in\_object}}{}
Check whether the given object is managed by any omsi API class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{in\_object}} (\emph{\texttt{Any omsi\_file API object or h5py.Dataset or h5py.Group or h5py.File object.}}) -- The object to be checked

\end{description}\end{quote}

\end{fulllineitems}

\index{items() (omsi.dataformat.omsi\_file.common.omsi\_file\_common method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common.items}\pysiglinewithargsret{\bfcode{items}}{}{}
Get the list of items associdated with the h5py.Group object managed by this object

\end{fulllineitems}

\index{parse\_path\_string() (omsi.dataformat.omsi\_file.common.omsi\_file\_common static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common.parse_path_string}\pysiglinewithargsret{\strong{static }\bfcode{parse\_path\_string}}{\emph{path}}{}
Given a string of the form \textless{}filename.h5\textgreater{}:\textless{}object\_path\textgreater{} retrieve
the name of the file and the object path.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{path}} -- The string defining the file and object path.

\item[{Returns}] \leavevmode
Tuple with the filename and the object path. Both may
be None depending on whether an object\_path is given and
whether the path string is valid.

\item[{Raises}] \leavevmode
ValueError in case that an invalid string is given

\end{description}\end{quote}

\end{fulllineitems}

\index{same\_file() (omsi.dataformat.omsi\_file.common.omsi\_file\_common static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common.same_file}\pysiglinewithargsret{\strong{static }\bfcode{same\_file}}{\emph{filename1}, \emph{filename2}}{}
Check whether two files are the same.

This function uses the os.path.samefile(...) method to compare files and
falls back to comparing the absolute paths of files if samefile should
fail or cannot be imported.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filename1}} -- The name of the first file

\item {} 
\textbf{\texttt{filename2}} -- The name of the second file

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_file\_object\_manager (class in omsi.dataformat.omsi\_file.common)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_object_manager}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.common.}\bfcode{omsi\_file\_object\_manager}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{object}

Base class used to define manager helper classes  used to manage contained managed objects.
Managed objects are HDF5.Groups (or Datasets) with a corresponding manager API class
and may be nested within other Managed objects.

\textbf{What is a manager helper class?}

Manager classes are used in the design of \emph{omsi.dataformat.omsi\_file} to encapsulate
functionality needed for management of other manager objects. The expected use
of this class, hence, is through multiple inheritance where the main base
class is \emph{omsi.dataformat.omsi\_file.common.omsi\_file\_common}. This is important
due to the use of super to accomodate multiple inheritance to allow object
to manage an arbitrary number of other object and inherit from other object as well.

\textbf{Use of super()}

This class inherits only from object but calls super in the \_\_init\_\_(manager\_group)
with the manager\_group as only input parameter, in the expectation that this
class is used using multiple inheritance with \emph{omsi\_file\_common} as main base class .

Multiple inheritance is used in \emph{omsi.dataformat.omsi\_file module} when a class contains
other managed objects and uses the manager classes (such as this one)
to get all the features needed to manage those objects.

All child classes of omsi\_file\_common call super(..).\_\_init\_\_(manager\_group)
and all manager helper classes (such as this one) use a single input parameter
indicating the manager h5py.Group object that contains the given object.

\end{fulllineitems}



\paragraph{\texttt{main\_file} Module}
\label{omsi.dataformat.omsi_file:main-file-module}\label{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.main_file}\index{omsi.dataformat.omsi\_file.main\_file (module)}
Module for managing OpenMSI HDF5 data files.
\index{omsi\_file (class in omsi.dataformat.omsi\_file.main\_file)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.main_file.omsi_file}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.main\_file.}\bfcode{omsi\_file}}{\emph{filename}, \emph{mode='a'}, \emph{**kwargs}}{}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.experiment.omsi_experiment_manager]{\emph{\code{omsi.dataformat.omsi\_file.experiment.omsi\_experiment\_manager}}}}, {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common]{\emph{\code{omsi.dataformat.omsi\_file.common.omsi\_file\_common}}}}

API for creating and managing a single OpenMSI data file.

\textbf{Use of supe()r}

This class inherits from \emph{omsi.dataformat.omsi\_file.common.omsi\_file\_common} .
Consistent with the design pattern for multiple inheritance of the
\emph{omsi.dataformat.omsi\_file} module, the \emph{\_\_init\_\_} function calls
\emph{super(...).\_\_init\_\_(manager\_group)} with a single  parameter indicating the
parent group.

\textbf{Inherited Instance Variables}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{managed\_group}} -- The group that is managed by this object

\item {} 
\textbf{\texttt{name}} -- Name of the managed group

\end{itemize}

\end{description}\end{quote}

Open the given file or create it if does not exit.

The creation of the object may fail  if the file does not exist, and
the selected mode is `r' or `r+'.

Keyword arguments:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filename}} -- string indicating the name+path of the OpenMSI data file. Alternatively
this may also be an h5py.File instance (or an h5py.Group, h5py.Dataset
instance from which we can get the file)

\item {} 
\textbf{\texttt{mode}} -- 
read/write mode. One of :

r = readonly, file must exist.

r+ = read/write, file must exist.

w = Create file, truncate if exists.

w- = create file, fail if exists.

a = read/write if exists, create otherwise (default)


\item {} 
\textbf{\texttt{**kargs}} -- 
Other keyword arguments to be used for opening the file using h5py.
See the h5py.File documentation for details. For example to use parallel HDF5,
the following additional parameters can be given driver='mpio', comm:MPI.COMM\_WORLD.


\end{itemize}

\end{description}\end{quote}
\index{close\_file() (omsi.dataformat.omsi\_file.main\_file.omsi\_file method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.main_file.omsi_file.close_file}\pysiglinewithargsret{\bfcode{close\_file}}{}{}
Close the msi data file

\end{fulllineitems}

\index{flush() (omsi.dataformat.omsi\_file.main\_file.omsi\_file method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.main_file.omsi_file.flush}\pysiglinewithargsret{\bfcode{flush}}{}{}
Flush all I/O

\end{fulllineitems}

\index{get\_filename() (omsi.dataformat.omsi\_file.main\_file.omsi\_file method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.main_file.omsi_file.get_filename}\pysiglinewithargsret{\bfcode{get\_filename}}{}{}
Get the name of the omsi file
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
String indicating the filename (possibly including the full path,
depending on how the object has been initalized)

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_h5py\_file() (omsi.dataformat.omsi\_file.main\_file.omsi\_file method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.main_file.omsi_file.get_h5py_file}\pysiglinewithargsret{\bfcode{get\_h5py\_file}}{}{}
Get the h5py object for the omsi file
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
h5py redernce to the HDF5 file

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_valid\_dataset() (omsi.dataformat.omsi\_file.main\_file.omsi\_file class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.main_file.omsi_file.is_valid_dataset}\pysiglinewithargsret{\strong{classmethod }\bfcode{is\_valid\_dataset}}{\emph{name}}{}
Perform basic checks for the given filename, whether it is a valid OMSI file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{name}} -- Name of the file to be checked.

\item[{Returns}] \leavevmode
Boolean indicating whether the file is valid

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_xdmf\_header() (omsi.dataformat.omsi\_file.main\_file.omsi\_file method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.main_file.omsi_file.write_xdmf_header}\pysiglinewithargsret{\bfcode{write\_xdmf\_header}}{\emph{xdmf\_filename}}{}
Write XDMF header file for the current HDF5 datafile
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{xdmf\_filename}} -- The name of the xdmf XML header file to be created for the HDF5 file.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{\texttt{experiment} Module}
\label{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.experiment}\label{omsi.dataformat.omsi_file:experiment-module}\index{omsi.dataformat.omsi\_file.experiment (module)}
OMSI file module for management of experiment data.
\index{omsi\_experiment\_manager (class in omsi.dataformat.omsi\_file.experiment)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.experiment.omsi_experiment_manager}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.experiment.}\bfcode{omsi\_experiment\_manager}}{\emph{experiment\_parent}}{}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_object_manager]{\emph{\code{omsi.dataformat.omsi\_file.common.omsi\_file\_object\_manager}}}}

Experiment manager helper class used to define common functionality needed for
experiment-related data. Usually, a class that defines a format that contains an
omsi\_file\_experiment object will inherit from this class (in addition to omsi\_file\_common)
to acquire the common features.

For more details see: \emph{omsi.dataforamt.omsi\_file.omsi\_common.omsi\_file\_object\_manager}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{experiment\_parent}} -- The h5py.Group parent object containing the instrument object to be managed.

\end{description}\end{quote}
\index{create\_experiment() (omsi.dataformat.omsi\_file.experiment.omsi\_experiment\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.experiment.omsi_experiment_manager.create_experiment}\pysiglinewithargsret{\bfcode{create\_experiment}}{\emph{exp\_identifier=None}, \emph{flush\_io=True}}{}
Create a new group in the file for a new experiment and return the omsi\_file\_experiment
object for the new experiment.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{exp\_identifier}} (\emph{\texttt{string or None (default)}}) -- The string used to identify the analysis

\item {} 
\textbf{\texttt{flush\_io}} -- Call flush on the HDF5 file to ensure all HDF5 bufferes are flushed so that
all data has been written to file.

\end{itemize}

\item[{Returns}] \leavevmode
omsi\_file\_experiment object for the newly created group for the experiment

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_experiment() (omsi.dataformat.omsi\_file.experiment.omsi\_experiment\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.experiment.omsi_experiment_manager.get_experiment}\pysiglinewithargsret{\bfcode{get\_experiment}}{\emph{exp\_index}}{}
Get the omsi\_format\_experiment object for the experiment with the given index
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{exp\_index}} (\emph{\texttt{uint}}) -- The index of the requested experiment

\item[{Returns}] \leavevmode
h5py reference to the experiment with the given index. Returns None in case                   the experiment does not exist.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_experiment\_by\_identifier() (omsi.dataformat.omsi\_file.experiment.omsi\_experiment\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.experiment.omsi_experiment_manager.get_experiment_by_identifier}\pysiglinewithargsret{\bfcode{get\_experiment\_by\_identifier}}{\emph{exp\_identifier\_string}}{}
Get the omsi\_format\_experiment object for the experiment with the given identifier.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{exp\_identifier\_string}} (\emph{\texttt{string}}) -- The string used to identify the analysis

\item[{Returns}] \leavevmode
Returns h5py object of the experiment group or None in case the experiment is not found.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_experiment\_path() (omsi.dataformat.omsi\_file.experiment.omsi\_experiment\_manager static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.experiment.omsi_experiment_manager.get_experiment_path}\pysiglinewithargsret{\strong{static }\bfcode{get\_experiment\_path}}{\emph{exp\_index=None}}{}
Based on the index of the experiment return the full path to the hdf5
group containing the data for an experiment.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{exp\_index}} -- The index of the experiment.

\item[{Returns}] \leavevmode
String indicating the path to the experiment.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_num\_experiments() (omsi.dataformat.omsi\_file.experiment.omsi\_experiment\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.experiment.omsi_experiment_manager.get_num_experiments}\pysiglinewithargsret{\bfcode{get\_num\_experiments}}{}{}
Get the number of experiments in this file.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Integer indicating the number of experiments.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_file\_experiment (class in omsi.dataformat.omsi\_file.experiment)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.experiment.omsi_file_experiment}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.experiment.}\bfcode{omsi\_file\_experiment}}{\emph{exp\_group}}{}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.methods.omsi_methods_manager]{\emph{\code{omsi.dataformat.omsi\_file.methods.omsi\_methods\_manager}}}}, {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.instrument.omsi_instrument_manager]{\emph{\code{omsi.dataformat.omsi\_file.instrument.omsi\_instrument\_manager}}}}, {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_analysis_manager]{\emph{\code{omsi.dataformat.omsi\_file.analysis.omsi\_analysis\_manager}}}}, {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.msidata.omsi_msidata_manager]{\emph{\code{omsi.dataformat.omsi\_file.msidata.omsi\_msidata\_manager}}}}, {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common]{\emph{\code{omsi.dataformat.omsi\_file.common.omsi\_file\_common}}}}

Class for managing experiment specific data

\textbf{Use of super():}

This class inherits from \emph{omsi.dataformat.omsi\_file.common.omsi\_file\_common}.
Consistent with the design pattern for multiple inheritance of the
\emph{omsi.dataformat.omsi\_file} module, the \_\_init\_\_ function calls
super(...).\_\_init\_\_(manager\_group) with a single  parameter indicating the
parent group.

\textbf{Inherited instance variable:}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{managed\_group}} -- The group that is managed by this object

\item {} 
\textbf{\texttt{methods\_parent}} -- The parent group containing the methods object (same as managed\_group)

\item {} 
\textbf{\texttt{instrument\_parent}} -- The parent group containing the instrument object (same as managed\_group)

\item {} 
\textbf{\texttt{name}} -- Name of the managed group

\end{itemize}

\end{description}\end{quote}

Initalize the experiment object given the h5py object of the experiment group
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{exp\_group}} -- The h5py object with the experiment group of the omsi hdf5 file.

\end{description}\end{quote}
\index{get\_experiment\_identifier() (omsi.dataformat.omsi\_file.experiment.omsi\_file\_experiment method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.experiment.omsi_file_experiment.get_experiment_identifier}\pysiglinewithargsret{\bfcode{get\_experiment\_identifier}}{}{}
Get the HDF5 dataset with the identifier description for the experiment.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
h5py object of the experiment identifier or None in case not present

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_experiment\_index() (omsi.dataformat.omsi\_file.experiment.omsi\_file\_experiment method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.experiment.omsi_file_experiment.get_experiment_index}\pysiglinewithargsret{\bfcode{get\_experiment\_index}}{}{}
Determine the index of the experiment based on the name of the group
:return: Integer index of the experiment

\end{fulllineitems}

\index{get\_instrument\_info() (omsi.dataformat.omsi\_file.experiment.omsi\_file\_experiment method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.experiment.omsi_file_experiment.get_instrument_info}\pysiglinewithargsret{\bfcode{get\_instrument\_info}}{\emph{check\_parent=False}}{}
Inherited from omsi\_instrument\_manager parent class. Overwritten here to change the default
parameter setting for check\_parent. See \emph{omsi.dataformat.omsi\_file.instrument.omsi\_instrument\_manager}
for details.

\end{fulllineitems}

\index{get\_method\_info() (omsi.dataformat.omsi\_file.experiment.omsi\_file\_experiment method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.experiment.omsi_file_experiment.get_method_info}\pysiglinewithargsret{\bfcode{get\_method\_info}}{\emph{check\_parent=False}}{}
Inherited from omsi\_method\_manager parent class. Overwritten here to change the default
parameter setting for check\_parent. See \emph{omsi.dataformat.omsi\_file.methods.omsi\_method\_manager}
for details

\end{fulllineitems}

\index{set\_experiment\_identifier() (omsi.dataformat.omsi\_file.experiment.omsi\_file\_experiment method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.experiment.omsi_file_experiment.set_experiment_identifier}\pysiglinewithargsret{\bfcode{set\_experiment\_identifier}}{\emph{identifier}}{}
Overwrite the current identfier string for the experiment with the given string
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{identifier}} -- The new experiment identifier string.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{\texttt{metadata\_collection} Module}
\label{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.metadata_collection}\label{omsi.dataformat.omsi_file:metadata-collection-module}\index{omsi.dataformat.omsi\_file.metadata\_collection (module)}
Module for management of general metadata storage entities. These are often specialized
---e.g., omsi\_file\_instrument, omsi\_file\_sample---to store specific metadata and add
more functionality.
\index{omsi\_file\_metadata\_collection (class in omsi.dataformat.omsi\_file.metadata\_collection)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.metadata_collection.omsi_file_metadata_collection}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.metadata\_collection.}\bfcode{omsi\_file\_metadata\_collection}}{\emph{metadata\_group}}{}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common]{\emph{\code{omsi.dataformat.omsi\_file.common.omsi\_file\_common}}}}

Class for managing method specific data.

\textbf{Use of super():}

This class inherits from \emph{omsi.dataformat.omsi\_file.common.omsi\_file\_common}.
Consistent with the design pattern for multiple inheritance of the
\emph{omsi.dataformat.omsi\_file} module, the \_\_init\_\_ function calls
super(...).\_\_init\_\_(manager\_group) with a single  parameter indicating the
parent group.

\textbf{Inherited Instance Variables}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{managed\_group}} -- The group that is managed by this object

\item {} 
\textbf{\texttt{name}} -- Name of the managed group

\end{itemize}

\end{description}\end{quote}

Initialize the metadata collection object given the h5py object of the metadata collection
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{metadata\_group}} -- The h5py object with the metadata collection group of the omsi hdf5 file.

\end{description}\end{quote}
\index{add\_metadata() (omsi.dataformat.omsi\_file.metadata\_collection.omsi\_file\_metadata\_collection method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.metadata_collection.omsi_file_metadata_collection.add_metadata}\pysiglinewithargsret{\bfcode{add\_metadata}}{\emph{metadata}}{}
Add a new metadata entry
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{metadata}} -- Instance of \emph{omsi.shared.metadata\_data.metadata\_value} or
describing \emph{omsi.shared.metadata\_data.metadata\_dict} with the
metadata to be added.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_metadata() (omsi.dataformat.omsi\_file.metadata\_collection.omsi\_file\_metadata\_collection method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.metadata_collection.omsi_file_metadata_collection.get_metadata}\pysiglinewithargsret{\bfcode{get\_metadata}}{\emph{key=None}}{}
Get dict with the full description of the metadata for the given key or all
metadata if no key is given.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\emph{omsi.shared.metadata\_data.metadata\_value} object if a key is given
or a \emph{omsi.shared.metadata\_data.metadata\_dict} with all metadata
if no key is specified.

\item[{Raises}] \leavevmode
KeyError is raised in case that the specified key does not exist

\end{description}\end{quote}

\end{fulllineitems}

\index{keys() (omsi.dataformat.omsi\_file.metadata\_collection.omsi\_file\_metadata\_collection method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.metadata_collection.omsi_file_metadata_collection.keys}\pysiglinewithargsret{\bfcode{keys}}{}{}
Get a list of all metadata keys
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of string with the metadata keys

\end{description}\end{quote}

\end{fulllineitems}

\index{values() (omsi.dataformat.omsi\_file.metadata\_collection.omsi\_file\_metadata\_collection method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.metadata_collection.omsi_file_metadata_collection.values}\pysiglinewithargsret{\bfcode{values}}{}{}
Convenience function returning a list of all metadata objects.
This is equivilant get\_metadata(key=None).values(), however, for consistency with
other dict-like interfaces this function returns a list of
\emph{omsi.shared.metadata\_data.metadata\_value} objects rather than
the \emph{omsi.shared.metadata\_data.metadata\_dict}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of \emph{omsi.shared.metadata\_data.metadata\_value} with all metadata

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_metadata\_collection\_manager (class in omsi.dataformat.omsi\_file.metadata\_collection)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.metadata_collection.omsi_metadata_collection_manager}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.metadata\_collection.}\bfcode{omsi\_metadata\_collection\_manager}}{\emph{metadata\_parent=None}}{}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_object_manager]{\emph{\code{omsi.dataformat.omsi\_file.common.omsi\_file\_object\_manager}}}}

This is a file format manager helper class
used to define common functionality needed for management of metadata-related data.
Usually, a class that defines a format that contains an omsi\_file\_metadata object
will inherit from this class (in addition to omsi\_file\_common) to acquire the common
features.

For more details see: \emph{omsi.dataforamt.omsi\_file.omsi\_common.omsi\_file\_object\_manager}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{metadata\_parent}} -- The parent h5py.Group object containing the method object to be managed

\end{description}\end{quote}
\index{create\_metadata\_collection() (omsi.dataformat.omsi\_file.metadata\_collection.omsi\_metadata\_collection\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.metadata_collection.omsi_metadata_collection_manager.create_metadata_collection}\pysiglinewithargsret{\bfcode{create\_metadata\_collection}}{\emph{group\_name=None}, \emph{metadata=None}, \emph{flush\_io=True}}{}
Add a new group for managing metadata
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{group\_name}} (\emph{\texttt{str, None}}) -- Optional name of the new metadata group. If None is given
then the omsi\_format\_metadata\_collection.metadata\_collection\_groupname\_default will be used

\item {} 
\textbf{\texttt{metadata}} (\emph{\texttt{None, omsi.shared.metadata\_data.metadata\_value, omsi\_shared.metadata\_data.metadata\_dict}}) -- Additional metadata to be added to the collection after creation

\item {} 
\textbf{\texttt{flush\_io}} -- Call flush on the HDF5 file to ensure all HDF5 buffers are
flushed so that all data has been written to file

\end{itemize}

\item[{Returns}] \leavevmode
\emph{omsi\_file\_metadata\_collection} object

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_default\_metadata\_collection() (omsi.dataformat.omsi\_file.metadata\_collection.omsi\_metadata\_collection\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.metadata_collection.omsi_metadata_collection_manager.get_default_metadata_collection}\pysiglinewithargsret{\bfcode{get\_default\_metadata\_collection}}{\emph{omsi\_object=None}}{}
Get the default metadata collection object if it exists
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{omsi\_object}} -- The omsi file API object or h5py.Group object that we should check.
If set to None (default) then the self.metadata\_parent will be used

\item[{Returns}] \leavevmode
None, omsi\_file\_metadata\_collection

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_metadata\_collections() (omsi.dataformat.omsi\_file.metadata\_collection.omsi\_metadata\_collection\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.metadata_collection.omsi_metadata_collection_manager.get_metadata_collections}\pysiglinewithargsret{\bfcode{get\_metadata\_collections}}{\emph{omsi\_object=None}, \emph{name=None}}{}
Get all metadata\_collections defined for given OpenMSI file API object or h5py.Group.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{omsi\_object}} -- The omsi file API object or h5py.Group object that we should check.
If set to None (default) then the self.metadata\_parent will be use

\item {} 
\textbf{\texttt{name}} -- If name is specified, then only retrieve collections with the given name

\end{itemize}

\item[{Returns}] \leavevmode
List of omsi\_file\_metadata\_collection objects for the requested group. The function
returns None in case that the h5py.Group for the omsi\_object could not be determined.

\end{description}\end{quote}

\end{fulllineitems}

\index{has\_default\_metadata\_collection() (omsi.dataformat.omsi\_file.metadata\_collection.omsi\_metadata\_collection\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.metadata_collection.omsi_metadata_collection_manager.has_default_metadata_collection}\pysiglinewithargsret{\bfcode{has\_default\_metadata\_collection}}{\emph{omsi\_object}}{}
Check whether the omsi API object (or h5py.Group) contains any a metadata collection with
the default name.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{has\_metadata\_collections() (omsi.dataformat.omsi\_file.metadata\_collection.omsi\_metadata\_collection\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.metadata_collection.omsi_metadata_collection_manager.has_metadata_collections}\pysiglinewithargsret{\bfcode{has\_metadata\_collections}}{\emph{omsi\_object=None}}{}
Check whether the given omsi API object (or h5py.Group) contains any metadata collections
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{omsi\_object}} -- The omsi file API object or h5py.Group object that we should check.
If set to None (default) then the self.metadata\_parent will be used

\item[{Returns}] \leavevmode
Boolean indicating whether metadata collections were found

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{\texttt{instrument} Module}
\label{omsi.dataformat.omsi_file:instrument-module}\label{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.instrument}\index{omsi.dataformat.omsi\_file.instrument (module)}
Module for managing instrument related data in OMSI files.
\index{omsi\_file\_instrument (class in omsi.dataformat.omsi\_file.instrument)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.instrument.omsi_file_instrument}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.instrument.}\bfcode{omsi\_file\_instrument}}{\emph{instrument\_group}}{}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.metadata_collection.omsi_file_metadata_collection]{\emph{\code{omsi.dataformat.omsi\_file.metadata\_collection.omsi\_file\_metadata\_collection}}}}

Class for managing instrument specific data

\textbf{Use of super():}

This class inherits from \emph{omsi.dataformat.omsi\_file.common.omsi\_file\_common}.
Consistent with the design pattern for multiple inheritance of the
\emph{omsi.dataformat.omsi\_file} module, the \_\_init\_\_ function calls
super(...).\_\_init\_\_(manager\_group) with a single  parameter indicating the
parent group.

\textbf{Inherited Instance Variables}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{managed\_group}} -- The group that is managed by this object

\item {} 
\textbf{\texttt{name}} -- Name of the managed group

\end{itemize}

\end{description}\end{quote}

Initalize the instrument object given the h5py object of the instrument group
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{instrument\_group}} -- The h5py object with the instrument group of the omsi hdf5 file.

\end{description}\end{quote}
\index{get\_instrument\_mz() (omsi.dataformat.omsi\_file.instrument.omsi\_file\_instrument method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.instrument.omsi_file_instrument.get_instrument_mz}\pysiglinewithargsret{\bfcode{get\_instrument\_mz}}{}{}
Get the HDF5 dataset with the mz data for the instrument.

To get the numpy array of the full mz data use:
get\_instrument\_mz(){[}:{]}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Returns the h5py object with the instrument mz data.
Returns None in case no mz data was found for the instrument.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_instrument\_name() (omsi.dataformat.omsi\_file.instrument.omsi\_file\_instrument method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.instrument.omsi_file_instrument.get_instrument_name}\pysiglinewithargsret{\bfcode{get\_instrument\_name}}{}{}
Get the HDF5 dataset with the name of the instrument.

To get the string of the instrument name use:
get\_instrument\_name(){[}...{]}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
h5py object to the dataset with the instrument name.
Returns None in case no method name is found.

\end{description}\end{quote}

\end{fulllineitems}

\index{has\_instrument\_name() (omsi.dataformat.omsi\_file.instrument.omsi\_file\_instrument method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.instrument.omsi_file_instrument.has_instrument_name}\pysiglinewithargsret{\bfcode{has\_instrument\_name}}{}{}
Check whether a name has been saved for the instrument
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_instrument\_name() (omsi.dataformat.omsi\_file.instrument.omsi\_file\_instrument method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.instrument.omsi_file_instrument.set_instrument_name}\pysiglinewithargsret{\bfcode{set\_instrument\_name}}{\emph{name}}{}
Overwrite the current identifier string for the experiment with the given string.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{name}} (\emph{\texttt{string.}}) -- The new instrument name.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_instrument\_manager (class in omsi.dataformat.omsi\_file.instrument)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.instrument.omsi_instrument_manager}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.instrument.}\bfcode{omsi\_instrument\_manager}}{\emph{instrument\_parent}}{}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.metadata_collection.omsi_metadata_collection_manager]{\emph{\code{omsi.dataformat.omsi\_file.metadata\_collection.omsi\_metadata\_collection\_manager}}}}

Instrument manager helper class
used to define common functionality needed for instrument-related data.
Usually, a class that defines a format that contains an omsi\_file\_methods object
will inherit from this class (in addition to omsi\_file\_common) to acquire the common
features.

For more details see: \emph{omsi.dataforamt.omsi\_file.omsi\_common.omsi\_file\_object\_manager}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{instrument\_parent}} -- The h5py.Group parent object containing the instrument object to be managed.

\end{description}\end{quote}
\index{create\_instrument\_info() (omsi.dataformat.omsi\_file.instrument.omsi\_instrument\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.instrument.omsi_instrument_manager.create_instrument_info}\pysiglinewithargsret{\bfcode{create\_instrument\_info}}{\emph{instrument\_name=None}, \emph{mzdata=None}, \emph{flush\_io=True}}{}
Add information about the instrument used for creating the images for this experiment.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{instrument\_name}} (\emph{\texttt{string, None}}) -- The name of the instrument

\item {} 
\textbf{\texttt{mzdata}} (\emph{\texttt{numpy array or None}}) -- Numpy array of the mz data values of the instrument

\item {} 
\textbf{\texttt{flush\_io}} -- Call flush on the HDF5 file to ensure all HDF5 bufferes are flushed so that all
data has been written to file

\end{itemize}

\item[{Returns}] \leavevmode
The function returns the h5py HDF5 handler to the instrument info group created for the experiment.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_instrument\_info() (omsi.dataformat.omsi\_file.instrument.omsi\_instrument\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.instrument.omsi_instrument_manager.get_instrument_info}\pysiglinewithargsret{\bfcode{get\_instrument\_info}}{\emph{check\_parent=True}}{}
Get the HDF5 group opbject with the instrument information.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{check\_parent}} -- If no method group is available for this dataset should we check
whether the parent object (i.e., the experiment group containing the dataset)
has information about the method. (default=True)

\item[{Returns}] \leavevmode
omsi\_file\_instrument object for the requested instrument info. The function returns                    None in case no instrument information was found for the experiment

\end{description}\end{quote}

\end{fulllineitems}

\index{has\_instrument\_info() (omsi.dataformat.omsi\_file.instrument.omsi\_instrument\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.instrument.omsi_instrument_manager.has_instrument_info}\pysiglinewithargsret{\bfcode{has\_instrument\_info}}{\emph{check\_parent=False}}{}
Check whether custom instrument information is available for this dataset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{check\_parent}} -- If no instrument group is available for this dataset should we check
whether the parent object (i.e., the experiment group containing the dataset)
has information about the instrument. (default=False)

\item[{Returns}] \leavevmode
Boolean indicating whether instrument info is available.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{\texttt{methods} Module}
\label{omsi.dataformat.omsi_file:methods-module}\label{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.methods}\index{omsi.dataformat.omsi\_file.methods (module)}
Module for management of method specific data in OMSI data files
\index{omsi\_file\_methods (class in omsi.dataformat.omsi\_file.methods)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.methods.omsi_file_methods}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.methods.}\bfcode{omsi\_file\_methods}}{\emph{method\_group}}{}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.metadata_collection.omsi_file_metadata_collection]{\emph{\code{omsi.dataformat.omsi\_file.metadata\_collection.omsi\_file\_metadata\_collection}}}}

Class for managing method specific data.

\textbf{Use of super():}

This class inherits from \emph{omsi.dataformat.omsi\_file.common.omsi\_file\_common}.
Consistent with the design pattern for multiple inheritance of the
\emph{omsi.dataformat.omsi\_file} module, the \_\_init\_\_ function calls
super(...).\_\_init\_\_(manager\_group) with a single  parameter indicating the
parent group.

\textbf{Inherited Instance Variables}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{managed\_group}} -- The group that is managed by this object

\item {} 
\textbf{\texttt{name}} -- Name of the managed group

\end{itemize}

\end{description}\end{quote}

Initialize the method object given the h5py object of the method group
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{method\_group}} -- The h5py object with the method group of the omsi hdf5 file.

\end{description}\end{quote}
\index{get\_method\_name() (omsi.dataformat.omsi\_file.methods.omsi\_file\_methods method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.methods.omsi_file_methods.get_method_name}\pysiglinewithargsret{\bfcode{get\_method\_name}}{}{}
Get the HDF5 dataset with the name of the method.

To retrieve the name string use get\_method\_name(){[}...{]}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
h5py object where the method name is stored.
Returns None in case no method name is found.

\end{description}\end{quote}

\end{fulllineitems}

\index{has\_method\_name() (omsi.dataformat.omsi\_file.methods.omsi\_file\_methods method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.methods.omsi_file_methods.has_method_name}\pysiglinewithargsret{\bfcode{has\_method\_name}}{}{}
Check whether an object has a method name
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_method\_name() (omsi.dataformat.omsi\_file.methods.omsi\_file\_methods method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.methods.omsi_file_methods.set_method_name}\pysiglinewithargsret{\bfcode{set\_method\_name}}{\emph{name\_string}}{}
Overwrite the name string for the method with the given name string
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{name\_string}} (\emph{\texttt{string}}) -- The new method name.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_methods\_manager (class in omsi.dataformat.omsi\_file.methods)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.methods.omsi_methods_manager}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.methods.}\bfcode{omsi\_methods\_manager}}{\emph{methods\_parent=None}}{}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.metadata_collection.omsi_metadata_collection_manager]{\emph{\code{omsi.dataformat.omsi\_file.metadata\_collection.omsi\_metadata\_collection\_manager}}}}

This is a file format manager helper class
used to define common functionality needed for methods-related data.
Usually, a class that defines a format that contains an omsi\_file\_methods object
will inherit from this class (in addition to omsi\_file\_common) to acquire the common
features.

For more details see: \emph{omsi.dataforamt.omsi\_file.omsi\_common.omsi\_file\_object\_manager}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{method\_parent}} -- The parent h5py.Group object containing the method object to be managed

\end{description}\end{quote}
\index{create\_method\_info() (omsi.dataformat.omsi\_file.methods.omsi\_methods\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.methods.omsi_methods_manager.create_method_info}\pysiglinewithargsret{\bfcode{create\_method\_info}}{\emph{method\_name=None}, \emph{metadata=None}, \emph{flush\_io=True}}{}
Add information about the method imaged to the experiment.
Note, if a methods group already exists, then that group
will be used. If method\_name is not None, then the existing
name will be overwritten by the new value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{method\_name}} (\emph{\texttt{str, None}}) -- Optional name of the method

\item {} 
\textbf{\texttt{metadata}} (\emph{\texttt{metadata\_value, metadata\_dict}}) -- Additional metadata to be stored with the methods

\item {} 
\textbf{\texttt{flush\_io}} -- Call flush on the HDF5 file to ensure all HDF5 buffers are
flushed so that all data has been written to file

\end{itemize}

\item[{Returns}] \leavevmode
h5py object of the newly created method group.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_method\_info() (omsi.dataformat.omsi\_file.methods.omsi\_methods\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.methods.omsi_methods_manager.get_method_info}\pysiglinewithargsret{\bfcode{get\_method\_info}}{\emph{check\_parent=True}}{}
Get the omsi\_file\_methods object with the method information.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{check\_parent}} -- If no method group is available for this dataset should we check
whether the parent object (i.e., the experiment group containing the dataset)
has information about the method. (default=True)

\item[{Returns}] \leavevmode
omsi\_file\_methods object for the requested method info. The function returns
None in case no method information was found for the experiment

\end{description}\end{quote}

\end{fulllineitems}

\index{has\_method\_info() (omsi.dataformat.omsi\_file.methods.omsi\_methods\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.methods.omsi_methods_manager.has_method_info}\pysiglinewithargsret{\bfcode{has\_method\_info}}{\emph{check\_parent=False}}{}
Check whether custom method information is available for this dataset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{check\_parent}} -- If no method group is available for this dataset should we check
whether the parent object (i.e., the experiment group containing the dataset)
has information about the method. (default=False)

\item[{Returns}] \leavevmode
Boolean indicating whether method info is available.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{\texttt{msidata} Module}
\label{omsi.dataformat.omsi_file:msidata-module}\label{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.msidata}\index{omsi.dataformat.omsi\_file.msidata (module)}
Module for managing MSI data in OMSI data files
\index{omsi\_file\_msidata (class in omsi.dataformat.omsi\_file.msidata)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.msidata.omsi_file_msidata}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.msidata.}\bfcode{omsi\_file\_msidata}}{\emph{data\_group}, \emph{fill\_space=True}, \emph{fill\_spectra=True}, \emph{preload\_mz=False}, \emph{preload\_xy\_index=False}}{}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_dependencies_manager]{\emph{\code{omsi.dataformat.omsi\_file.dependencies.omsi\_dependencies\_manager}}}}, {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.methods.omsi_methods_manager]{\emph{\code{omsi.dataformat.omsi\_file.methods.omsi\_methods\_manager}}}}, {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.instrument.omsi_instrument_manager]{\emph{\code{omsi.dataformat.omsi\_file.instrument.omsi\_instrument\_manager}}}}, {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.metadata_collection.omsi_metadata_collection_manager]{\emph{\code{omsi.dataformat.omsi\_file.metadata\_collection.omsi\_metadata\_collection\_manager}}}}, {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common]{\emph{\code{omsi.dataformat.omsi\_file.common.omsi\_file\_common}}}}

Interface for interacting with mass spectrometry imaging datasets stored in omis HDF5 files.
The interface allows users to interact with the data as if it where a 3D cube even if data
is missing. Full spectra may be missing in cases where only a region of interest in space
has been imaged. Spectra may further be pre-processed so that each spectrum has only information
about its peaks so that each spectrum has it's own mz-axis.

To load data ue standard array syntax, e.g., {[}1,1,:{]} can be used to retrieve the spectrums at
location (1,1).

\textbf{Use of super():}

This class inherits from \emph{omsi.dataformat.omsi\_file.common.omsi\_file\_common}.
Consistent with the design pattern for multiple inheritance of the
\emph{omsi.dataformat.omsi\_file} module, the \_\_init\_\_ function calls
super(...).\_\_init\_\_(manager\_group) with a single  parameter indicating the
parent group.

\textbf{Current limitations:}
\begin{itemize}
\item {} 
The estimates in def \_\_best\_dataset\_\_(self,keys) are fairly crude at this point

\item {} 
The \_\_getitem\_\_ function for the partial\_spectra case is not implemented yet.

\item {} 
The \_\_setitem\_\_ function for the partial spectra case is not implemented yet (Note, it       should also support dynamic expansion of the cube by adding previously missing spectra).

\item {} 
For the partial cube case, assignement using \_\_setitem\_\_ function is only supported to       valid spectra, i.e., spectra that were specified as occupied during the intital creation process.

\end{itemize}

\textbf{Public object variables:}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{shape}} -- Define the full 3D shape of the dataset (i.e., even if the data is stored in sparse manner)

\item {} 
\textbf{\texttt{dtype}} -- The numpy datatyp of the main MSI data. This is the same as dataset.dtype

\item {} 
\textbf{\texttt{name}} -- The name of the corresponding groupt in the HDF5 file. Used to generate hard-links to the group.

\item {} 
\textbf{\texttt{format\_type}} -- Define according to which standard the data is stored in the file

\item {} 
\textbf{\texttt{datasets}} -- List of h5py objects containing possibly multiple different version of the same MSI data                     (spectra). There may be multiple versions stored with different layouts in order to                     optimize the selection process.

\item {} 
\textbf{\texttt{mz}} -- dataset with the global mz axis information. If prelaod\_mz is set in the constructor, then this               is a numpy dataset with the preloaded data. Otherwise, this is the h5py dataset pointing to               the data on disk.

\item {} 
\textbf{\texttt{xy\_index}} -- None if format\_type is `full\_cube'. Otherwise, this is the 2D array indicating for                     each x/y location the index of the spectrum in dataset. If prelaod\_xy\_index is set                     in the constructor, then this is a numpy dataset with the preloaded data. Otherwise,                     this is the h5py dataset pointing to the data on disk. Negative (-1) entries indicate                     that no spectrum has been recored for the given pixel.

\item {} 
\textbf{\texttt{inv\_xy\_index}} -- 2D dataset with n rows and 2 columns indicating for each spectrum i the (x,y)                          pixel index the spectrum belongs to. This index is stored for convenience purposes but                          is not actually needed for data access.

\item {} 
\textbf{\texttt{mz\_index}} -- None if format\_type is not `partial\_spectra'. Otherwise this is a dataset of the same size                     as the spectra data stored in dataset. Each entry indicates an index into the mz dataset                     to determine the mz\_data value for a spectrum. This means mz{[} mx\_index {]} gives the true                     mz value.

\item {} 
\textbf{\texttt{xy\_index\_end}} -- None if format\_type is not `partial\_spectra'. Otherwise this is a 2D array indicating                    for each x/y location the index where the given spectrum ends in the dataset. If                    prelaod\_xy\_index is set in the constructor, then this is a numpy dataset with the                    preloaded data. Otherwise, this is the h5py dataset pointing to the data on disk.                    Negative (-1) entries indicate that no spectrum has been recored for the given pixel.

\end{itemize}

\end{description}\end{quote}

\textbf{Private object variables:}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{\_data\_group}} -- Store the pointer to the HDF5 group with all the data

\item {} 
\textbf{\texttt{\_fill\_xy}} -- Define whether the data should be reconstructed as a full image cube Set using the                     set\_fill\_space function(..)

\item {} 
\textbf{\texttt{\_fill\_mz}} -- Define whether spectra should be remapped onto a global m/z axis. Set using the                     set\_fill\_spectra function(..)

\end{itemize}

\end{description}\end{quote}

Initialize the omsi\_msidata object.

The fill options are provided to enable a more convenient access to the data independent of how the
data is stored in the file. If the fill options are enabled, then the user can interact with the
data as if it where a 3D cube while missing is data is filled in by the given fill value.

The prelaod options provided here refer to generally smaller parts of the data for which it may be
more efficient to load the data and keep it around rather than doing repeated reads. If the object is
used only for a single read and destroyed afterwards, then disabling the preload options may give a
slight advantage but in most cases enabling the preload should be Ok (default).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data\_group}} -- The h5py object for the group with the omsi\_msidata.

\item {} 
\textbf{\texttt{fill\_space}} -- Define whether the data should be padded in space (filled with 0's) when
accessing the data using {[}..{]} operator so that the data behaves like a 3D cube.

\item {} 
\textbf{\texttt{fill\_spectra}} -- Define whether the spectra should completed by adding 0's so that all
spectra retrieved via the {[}..{]} operator so that always spectra of the full
length are returned. This option is provided to ease extension of the class
to cases where only partial spectra are stored in the file but is not used at this point.

\item {} 
\textbf{\texttt{preload\_mz}} -- Should the data for the mz axis be kept in memory or loaded on the fly when needed.

\item {} 
\textbf{\texttt{preload\_xy\_index}} -- Should the xy index (if available) be preloaderd into memory or should the
required data be loaded on the fly when needed.

\end{itemize}

\end{description}\end{quote}
\index{copy\_dataset() (omsi.dataformat.omsi\_file.msidata.omsi\_file\_msidata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.msidata.omsi_file_msidata.copy_dataset}\pysiglinewithargsret{\bfcode{copy\_dataset}}{\emph{source}, \emph{destination}, \emph{print\_status=False}}{}
Helper function used to copy a source msi dataset one chunk at a time to the destination dataset.
The data copy is done one destination chunk at a time to achieve chunk-aligned write.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{source}} -- The source h5py dataset

\item {} 
\textbf{\texttt{destination}} -- The h5py desitnation h5py dataset.

\item {} 
\textbf{\texttt{print\_status}} -- Should the function print the status of the conversion process to the command line?

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_optimized\_chunking() (omsi.dataformat.omsi\_file.msidata.omsi\_file\_msidata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.msidata.omsi_file_msidata.create_optimized_chunking}\pysiglinewithargsret{\bfcode{create\_optimized\_chunking}}{\emph{chunks=None}, \emph{compression=None}, \emph{compression\_opts=None}, \emph{copy\_data=True}, \emph{print\_status=False}, \emph{flush\_io=True}}{}
Helper function to allow one to create optimized copies of the dataset with different internal data
layouts to speed up selections. The function expects that the original data has already been written
to the data group. The function takes
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{chunks}} -- Specify whether chunking should be used (True,False), or specify the chunk sizes
to be used explicitly.

\item {} 
\textbf{\texttt{compression}} -- h5py compression option. Compression strategy.  Legal values are `gzip', `szip',  `lzf'.
Can also use an integer in range(10) indicating gzip.

\item {} 
\textbf{\texttt{compression\_opts}} -- h5py compression settings.  This is an integer for gzip, 2-tuple for szip, etc..
For gzip (H5 deflate filter) this is the aggression paramter. The agression parameter is
a number between zero and nine (inclusive) to indicate the tradeoff between speed
and compression ratio (zero is fastest, nine is best ratio).

\item {} 
\textbf{\texttt{copy\_data}} -- Should the MSI data be copied by this function to the new dataset or not. If False, then
it is up to the user of the function to copy the appropriate data into the returned h5py
dataset (not recommended but may be useful for performance optimization).

\item {} 
\textbf{\texttt{print\_status}} -- Should the function print the status of the conversion process to the command line?

\item {} 
\textbf{\texttt{flush\_io}} -- Call flush on the HDF5 file to ensure all HDF5 bufferes are flushed so that all data has
been written to file

\end{itemize}

\item[{Returns}] \leavevmode
h5py dataset with the new copy of the data

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_h5py\_datasets() (omsi.dataformat.omsi\_file.msidata.omsi\_file\_msidata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.msidata.omsi_file_msidata.get_h5py_datasets}\pysiglinewithargsret{\bfcode{get\_h5py\_datasets}}{\emph{index=0}}{}
Get the h5py dataset object for the given dataset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{index}} -- The index of the dataset.

\item[{Returns}] \leavevmode
h5py object for the requested dataset.

\item[{Raises}] \leavevmode
and Index error is generated in case an invalid index is given.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_h5py\_mzdata() (omsi.dataformat.omsi\_file.msidata.omsi\_file\_msidata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.msidata.omsi_file_msidata.get_h5py_mzdata}\pysiglinewithargsret{\bfcode{get\_h5py\_mzdata}}{}{}
Get the h5py object for the mz datasets.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
h5py object of the requested mz dataset.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_fill\_space() (omsi.dataformat.omsi\_file.msidata.omsi\_file\_msidata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.msidata.omsi_file_msidata.set_fill_space}\pysiglinewithargsret{\bfcode{set\_fill\_space}}{\emph{fill\_space}}{}
Define whether spatial selection should be filled with 0's to retrieve full image slices
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{fill\_space}} -- Boolean indicating whether images should be filled with 0's

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_fill\_spectra() (omsi.dataformat.omsi\_file.msidata.omsi\_file\_msidata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.msidata.omsi_file_msidata.set_fill_spectra}\pysiglinewithargsret{\bfcode{set\_fill\_spectra}}{\emph{fill\_spectra}}{}
Define whether spectra should be filled with 0's to map them to the global mz axis when retrieved.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{fill\_spectra}} -- Define whether m/z values should be filled with 0's.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_msidata\_manager (class in omsi.dataformat.omsi\_file.msidata)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.msidata.omsi_msidata_manager}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.msidata.}\bfcode{omsi\_msidata\_manager}}{\emph{msidata\_parent}}{}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_object_manager]{\emph{\code{omsi.dataformat.omsi\_file.common.omsi\_file\_object\_manager}}}}

MSI-data  manager helper class used to define common functionality needed for
msidata-related data. Usually, a class that defines a format that contains an
omsi\_file\_msidata object will inherit from this class (in addition to omsi\_file\_common)
to acquire the common features.

For more details see: \emph{omsi.dataforamt.omsi\_file.omsi\_common.omsi\_file\_object\_manager}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{msidata\_parent}} -- The h5py.Group parent object containing the instrument object to be managed.

\end{description}\end{quote}

Initatize the manger object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{msidata\_parent}} -- The h5py.Group parent object for the msi data.

\end{description}\end{quote}
\index{create\_msidata\_full\_cube() (omsi.dataformat.omsi\_file.msidata.omsi\_msidata\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.msidata.omsi_msidata_manager.create_msidata_full_cube}\pysiglinewithargsret{\bfcode{create\_msidata\_full\_cube}}{\emph{data\_shape}, \emph{data\_type='f'}, \emph{mzdata\_type='f'}, \emph{chunks=None}, \emph{compression=None}, \emph{compression\_opts=None}, \emph{flush\_io=True}}{}
Create a new mass spectrometry imaging dataset for the given experiment written as a full 3D cube.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data\_shape}} -- Shape of the dataset. Eg. shape=(10,10,10) creates a 3D dataset with
10 entries per dimension

\item {} 
\textbf{\texttt{data\_type}} -- numpy style datatype to be used for the dataset.

\item {} 
\textbf{\texttt{mzdata\_type}} -- numpy style datatype to be used for the mz data array.

\item {} 
\textbf{\texttt{chunks}} -- Specify whether chunkning should be used (True,False), or specify the chunk
sizes to be used in x,y, and m/z explicitly.

\item {} 
\textbf{\texttt{compression}} -- h5py compression option. Compression strategy.  Legal values are `gzip', `szip',  `lzf'.
Can also use an integer in range(10) indicating gzip.

\item {} 
\textbf{\texttt{compression\_opts}} -- h5py compression settings.  This is an integer for gzip, 2-tuple for szip, etc..
For gzip (H5 deflate filter) this is the aggression paramter. The agression parameter is
a number between zero and nine (inclusive) to indicate the tradeoff between speed
and compression ratio (zero is fastest, nine is best ratio).

\item {} 
\textbf{\texttt{flush\_io}} -- Call flush on the HDF5 file to ensure all HDF5 bufferes are flushed so that all data has
been written to file

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{The following two empty (but approbriately sized) h5py datasets are returned in order}] \leavevmode
to be filled with data:

\end{description}
\begin{itemize}
\item {} 
\code{data\_dataset} : Primary h5py dataset for the MSI data with shape data\_shape and dtype data\_type.

\item {} 
\code{mz\_dataset} : h5py dataset for the mz axis data with shape {[}data\_shape{[}2{]}{]} and dtype mzdata\_type.

\end{itemize}


\item[{Returns}] \leavevmode
\code{data\_group} : The h5py object with the group in the HDF5 file where the data should be stored.

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_msidata\_partial\_cube() (omsi.dataformat.omsi\_file.msidata.omsi\_msidata\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.msidata.omsi_msidata_manager.create_msidata_partial_cube}\pysiglinewithargsret{\bfcode{create\_msidata\_partial\_cube}}{\emph{data\_shape}, \emph{mask}, \emph{data\_type='f'}, \emph{mzdata\_type='f'}, \emph{chunks=None}, \emph{compression=None}, \emph{compression\_opts=None}, \emph{flush\_io=True}}{}
Create a new mass spectrometry imaging dataset for the given experiment written as a partial 3D cube
of complete spectra.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data\_shape}} -- Shape of the dataset. Eg. shape=(10,10,10) creates a 3D dataset with
10 entries per dimension

\item {} 
\textbf{\texttt{mask}} -- 2D boolean NumPy array used as mask to indicate which (x,y) locations have
spectra associated with them.

\item {} 
\textbf{\texttt{data\_type}} -- numpy style datatype to be used for the dataset.

\item {} 
\textbf{\texttt{mzdata\_type}} -- numpy style datatype to be used for the mz data array.

\item {} 
\textbf{\texttt{chunks}} -- Specify whether chunkning should be used (True,False), or specify the chunk sizes
to be used in x,y, and m/z explicitly.

\item {} 
\textbf{\texttt{compression}} -- h5py compression option. Compression strategy.  Legal values are `gzip', `szip',  `lzf'.
Can also use an integer in range(10) indicating gzip.

\item {} 
\textbf{\texttt{compression\_opts}} -- h5py compression settings.  This is an integer for gzip, 2-tuple for szip, etc..
For gzip (H5 deflate filter) this is the aggression paramter. The agression parameter is
a number between zero and nine (inclusive) to indicate the tradeoff between speed
and compression ratio (zero is fastest, nine is best ratio).

\item {} 
\textbf{\texttt{flush\_io}} -- Call flush on the HDF5 file to ensure all HDF5 bufferes are flushed so that all data has
been written to file

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{The following two empty (but approbriately sized) h5py datasets are returned in order to}] \leavevmode
be filled with data:

\end{description}
\begin{itemize}
\item {} 
\code{data\_dataset} : Primary h5py dataset for the MSI data with shape data\_shape and dtype data\_type.

\item {} 
\code{mz\_dataset} : h5py dataset for the mz axis data with shape {[}data\_shape{[}2{]}{]} and dtype mzdata\_type.

\end{itemize}


\item[{Returns}] \leavevmode

The following already complete dataset
\begin{itemize}
\item {} 
\code{xy\_index\_dataset} : This dataset indicates for each xy location to which index in                                      \code{data\_dataset} the location corresponds to. This dataset is                                      needed to identify where spectra need to be written to.

\end{itemize}


\item[{Returns}] \leavevmode
\code{data\_group} : The h5py object with the group in the HDF5 file where the data should be stored.

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_msidata\_partial\_spectra() (omsi.dataformat.omsi\_file.msidata.omsi\_msidata\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.msidata.omsi_msidata_manager.create_msidata_partial_spectra}\pysiglinewithargsret{\bfcode{create\_msidata\_partial\_spectra}}{\emph{spectra\_length}, \emph{len\_global\_mz}, \emph{data\_type='f'}, \emph{mzdata\_type='f'}, \emph{chunks=None}, \emph{compression=None}, \emph{compression\_opts=None}, \emph{flush\_io=True}}{}
Create a new mass spectrometry imaging dataset for the given experiment written as a partial 3D
cube of partial spectra.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{spectra\_length}} -- 2D boolean NumPy array used indicating for each (x,y) locations the length
of the corresponding partial spectrum.

\item {} 
\textbf{\texttt{len\_global\_mz}} -- The total number of m/z values in the global m/z axis for the full 3D cube

\item {} 
\textbf{\texttt{data\_type}} -- The dtype for the MSI dataset

\item {} 
\textbf{\texttt{mzdata\_type}} -- The dtype for the mz dataset

\item {} 
\textbf{\texttt{mzdata\_type}} -- numpy style datatype to be used for the mz data array.

\item {} 
\textbf{\texttt{chunks}} -- Specify whether chunkning should be used (True,False), or specify the chunk sizes to
be used in x,y, and m/z explicitly.

\item {} 
\textbf{\texttt{compression}} -- h5py compression option. Compression strategy.  Legal values are `gzip', `szip',  `lzf'.
Can also use an integer in range(10) indicating gzip.

\item {} 
\textbf{\texttt{compression\_opts}} -- h5py compression settings.  This is an integer for gzip, 2-tuple for szip, etc..
For gzip (H5 deflate filter) this is the aggression paramter. The agression parameter is
a number between zero and nine (inclusive) to indicate the tradeoff between speed
and compression ratio (zero is fastest, nine is best ratio).

\item {} 
\textbf{\texttt{flush\_io}} -- Call flush on the HDF5 file to ensure all HDF5 bufferes are flushed so that all data
has been written to file

\end{itemize}

\item[{Returns}] \leavevmode

The following two empty (but approbriatelu sized) h5py datasets are returned in order to be
filled with data:
\begin{itemize}
\item {} 
\code{data\_dataset} : The primary h5py dataset for the MSI data with shape data\_shape and dtype data\_type.

\item {} 
\code{mz\_index\_dataset} : h5py dataset with the mz\_index values

\item {} 
\code{mz\_dataset} : h5py dataset for the mz axis data with shape {[}data\_shape{[}2{]}{]} and dtype mzdata\_type.

\end{itemize}


\item[{Returns}] \leavevmode

The following already complete dataset
\begin{itemize}
\item {} \begin{description}
\item[{\code{xy\_index\_dataset}}] \leavevmode{[}This dataset indicates for each xy location at which index in \code{data\_dataset}{]}
the corresponding spectrum starts. This dataset is needed to identify where spectra
need to be written to.

\end{description}

\item {} \begin{description}
\item[{\code{xy\_index\_end\_dataset}}] \leavevmode{[}This dataset indicates for each xy location at which index in{]}
\code{data\_dataset} the corresponding spectrum ends (exclusing the given value).
This dataset is needed to identify where spectra need to be written to.

\end{description}

\end{itemize}


\item[{Returns}] \leavevmode
\code{data\_group} : The h5py object with the group in the HDF5 file where the data should be stored.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_msidata() (omsi.dataformat.omsi\_file.msidata.omsi\_msidata\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.msidata.omsi_msidata_manager.get_msidata}\pysiglinewithargsret{\bfcode{get\_msidata}}{\emph{data\_index}, \emph{fill\_space=True}, \emph{fill\_spectra=True}, \emph{preload\_mz=True}, \emph{preload\_xy\_index=True}}{}
Get the dataset with the given index for the given experiment.

For more detailed information about the use of the fill\_space and fill\_spectra and preload\_mz and
preload\_xy\_index options, see the init function of omsi.dataformat.omsi\_file\_msidata.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data\_index}} (\emph{\texttt{unsigned int}}) -- Index of the dataset.

\item {} 
\textbf{\texttt{fill\_space}} -- Define whether the data should be padded in space (filled with 0's)
when accessing the data using {[}..{]} operator so that the data behaves like a 3D cube.

\item {} 
\textbf{\texttt{fill\_spectra}} -- Define whether the spectra should completed by adding 0's so that
all spectra retrived via the {[}..{]} opeator so that always spectra of the full
length are returned.

\item {} 
\textbf{\texttt{preload\_mz}} -- Should the data for the mz axis be kept in memory or loaded on the fly when needed.

\item {} 
\textbf{\texttt{preload\_xy\_index}} -- Should the xy index (if available) be preloaderd into memory or should the
required data be loaded on the fly when needed.

\end{itemize}

\item[{Returns}] \leavevmode
omsi\_file\_msidata object for the given data\_index or None in case the data
with given index does not exist or the access failed for any
other reason.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_msidata\_by\_name() (omsi.dataformat.omsi\_file.msidata.omsi\_msidata\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.msidata.omsi_msidata_manager.get_msidata_by_name}\pysiglinewithargsret{\bfcode{get\_msidata\_by\_name}}{\emph{data\_name}}{}
Get the h5py data object for the the msidata with the given name.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{data\_name}} (\emph{\texttt{string}}) -- The name of the dataset

\item[{Returns}] \leavevmode
h5py object of the dataset or None in case the dataset is not found.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_num\_msidata() (omsi.dataformat.omsi\_file.msidata.omsi\_msidata\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.msidata.omsi_msidata_manager.get_num_msidata}\pysiglinewithargsret{\bfcode{get\_num\_msidata}}{}{}
Get the number of raw mass spectrometry images stored for a given experiment
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Integer indicating the number of msi datasets available for the experiment.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{\texttt{analysis} Module}
\label{omsi.dataformat.omsi_file:analysis-module}\label{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.analysis}\index{omsi.dataformat.omsi\_file.analysis (module)}
Module for managing custom analysis data in OMSI HDF5 files.
\index{omsi\_analysis\_manager (class in omsi.dataformat.omsi\_file.analysis)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_analysis_manager}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.analysis.}\bfcode{omsi\_analysis\_manager}}{\emph{analysis\_parent}}{}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_object_manager]{\emph{\code{omsi.dataformat.omsi\_file.common.omsi\_file\_object\_manager}}}}

Analysis manager helper class used to define common functionality needed for analysis-related data.
Usually, a class that defines a format that contains an omsi\_file\_analysis object
will inherit from this class (in addition to omsi\_file\_common) to acquire the common
features.

For more details see: \emph{omsi.dataforamt.omsi\_file.omsi\_common.omsi\_file\_object\_manager}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{analysis\_parent}} -- The h5py.Group parent object containing the instrument object to be managed.

\end{description}\end{quote}
\index{create\_analysis() (omsi.dataformat.omsi\_file.analysis.omsi\_analysis\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_analysis_manager.create_analysis}\pysiglinewithargsret{\bfcode{create\_analysis}}{\emph{analysis}, \emph{flush\_io=True}, \emph{force\_save=False}, \emph{save\_unsaved\_dependencies=True}, \emph{mpi\_root=0}, \emph{mpi\_comm=None}}{}
Add a new group for storing derived analysis results for the current experiment

Create the analysis group using omsi\_file\_analysis.\_\_create\_\_\_ which in turn uses
omsi\_file\_analysis.\_\_populate\_analysis\_\_(...) to populate the group with the appropriate data.

NOTE: Dependencies are generally resolved to point to file objects. However, if save\_unsaved\_dependencies
is set to False and a given in-memory dependency has not been saved yet, then the value associated with
that dependency will be saved instead as part of the parameters and, hence, only the value of the
dependency is persevered in that case and not the full dependency chain.

NOTE: Dependencies if they only exists in memory are typically saved recursively unless
save\_unsaved\_dependencies is set to False. I.e, calling create\_analysis may result in the
creating of multiple other dependent analyses if they have not been saved before.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis}} (\emph{\texttt{omsi.analysis.analysis\_base:}}) -- Instance of omsi.analysis.analysis\_base defining the analysis

\item {} 
\textbf{\texttt{flush\_io}} (\emph{\texttt{bool}}) -- Call flush on the HDF5 file to ensure all HDF5 bufferes are flushed
so that all data has been written to file

\item {} 
\textbf{\texttt{force\_save}} (\emph{\texttt{bool}}) -- Should we save the analysis even if it has been saved in the same location before?
If force\_save is False (default) and the self.omsi\_analysis\_storage parameter of the analysis object
contains a matching storage location---i.e., same file and experiment---, then the analysis will
not be saved again, but the object will only be retrieved from file.
If force\_save is True, then the analysis will be saved either way and the self.omsi\_analysis\_storage
parameter will be extended.

\item {} 
\textbf{\texttt{save\_unsaved\_dependencies}} (\emph{\texttt{bool}}) -- If there are unsaved (in-memory) dependencies, then should those be
saved to file as well? Default value is True, i.e, by default all in-memory dependencies that have
not been saved yet, i.e, for which the self.omsi\_analysis\_storage of the corresponding {\color{red}\bfseries{}omsi\_analysis\_}
base object is empty, are saved as well. If in-memory dependencies have been saved before, then a
link to those dependencies will be established, rather than re-saving the dependency.

\item {} 
\textbf{\texttt{mpi\_root}} -- The root MPI process that should perform the writing. This is to allow all analyses
to call the function and have communication in the analysis.write\_analysis\_data function be
handled.

\item {} 
\textbf{\texttt{mpi\_comm}} -- The MPI communicator to be used. None if default should be used (ie., MPI.COMM\_WORLD

\end{itemize}

\item[{Returns}] \leavevmode
The omsi\_file\_analysis object for the newly created analysis group and the
integer index of the analysis. NOTE: if force\_save is False (default), then the group
returned may not be new but may be simply the first entry in the list of existing
storage locations for the given analysis. NOTE: If we are in MPI parallel and we are on a
core that does not write any data, then None is returned instead.

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_analysis\_static() (omsi.dataformat.omsi\_file.analysis.omsi\_analysis\_manager static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_analysis_manager.create_analysis_static}\pysiglinewithargsret{\strong{static }\bfcode{create\_analysis\_static}}{\emph{analysis\_parent}, \emph{analysis}, \emph{flush\_io=True}, \emph{force\_save=False}, \emph{save\_unsaved\_dependencies=True}, \emph{mpi\_root=0}, \emph{mpi\_comm=None}}{}
Same as create\_analysis(...) but instead of relying on object-level, this function
allows additional parameters (specifically the analysis\_parent) to be provided as
input, rather than being determined based on self
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_parent}} -- The h5py.Group object or omsi.dataformat.omsi\_file.common.omsi\_file\_common object
where the analysis should be created

\item {} 
\textbf{\texttt{kwargs}} -- Additional keyword arguments for create\_analysis(...). See create\_analysis(...) for details.

\end{itemize}

\item[{Returns}] \leavevmode
The output of create\_analysis

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_analysis() (omsi.dataformat.omsi\_file.analysis.omsi\_analysis\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_analysis_manager.get_analysis}\pysiglinewithargsret{\bfcode{get\_analysis}}{\emph{analysis\_index}}{}
Get the omsi\_format\_analysis analysis object for the experiment with
the given index.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_index}} (\emph{\texttt{Unsigned integer}}) -- The index of the analysis

\item[{Returns}] \leavevmode
omsi\_file\_analysis object for the requested analysis. The function
returns None in case the analysis object was not found.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_analysis\_by\_identifier() (omsi.dataformat.omsi\_file.analysis.omsi\_analysis\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_analysis_manager.get_analysis_by_identifier}\pysiglinewithargsret{\bfcode{get\_analysis\_by\_identifier}}{\emph{analysis\_identifier\_string}}{}
Get the omsi\_format\_analysis analysis object for the the analysis with the given identifier.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_identifier\_string}} (\emph{\texttt{string}}) -- The string used as identifier for the analysis.

\item[{Returns}] \leavevmode
h5py obejct of the analysis or None in case the analysis is not found.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_analysis\_identifiers() (omsi.dataformat.omsi\_file.analysis.omsi\_analysis\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_analysis_manager.get_analysis_identifiers}\pysiglinewithargsret{\bfcode{get\_analysis\_identifiers}}{}{}
Get a list of all identifiers for all analysis stored for the experiment
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of strings of analysis identifiers.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_num\_analysis() (omsi.dataformat.omsi\_file.analysis.omsi\_analysis\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_analysis_manager.get_num_analysis}\pysiglinewithargsret{\bfcode{get\_num\_analysis}}{}{}
Get the number of raw mass spectrometry images stored for a given experiment
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Integer indicating the number of analyses available for the experiment.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_file\_analysis (class in omsi.dataformat.omsi\_file.analysis)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_file_analysis}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.analysis.}\bfcode{omsi\_file\_analysis}}{\emph{analysis\_group}}{}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_dependencies_manager]{\emph{\code{omsi.dataformat.omsi\_file.dependencies.omsi\_dependencies\_manager}}}}, {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common]{\emph{\code{omsi.dataformat.omsi\_file.common.omsi\_file\_common}}}}

Class for managing analysis specific data in omsi hdf5 files

Initialize the analysis object given the h5py object of the analysis group.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_group}} -- The h5py object with the analysis group of the omsi hdf5 file.

\end{description}\end{quote}
\index{get\_all\_analysis\_data() (omsi.dataformat.omsi\_file.analysis.omsi\_file\_analysis method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_file_analysis.get_all_analysis_data}\pysiglinewithargsret{\bfcode{get\_all\_analysis\_data}}{\emph{load\_data=False}}{}
Get all analysis data associated with the analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{load\_data}} -- load\_data: Should the data be loaded or just the h5py objects be
stored in the dictionary.

\item[{Returns}] \leavevmode
List of analysis\_data objects with the names and h5py or numpy objects.
Access using {[}index{]}{[}'name'{]} and {[}index{]}{[}'data'{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_parameter\_data() (omsi.dataformat.omsi\_file.analysis.omsi\_file\_analysis method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_file_analysis.get_all_parameter_data}\pysiglinewithargsret{\bfcode{get\_all\_parameter\_data}}{\emph{load\_data=False}, \emph{exclude\_dependencies=False}}{}
Get all parameter data associated with the analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{load\_data}} -- Should the data be loaded or just the h5py objects be stored in the dictionary.

\item[{Returns}] \leavevmode
List of parameter\_data objects with names and h5py or numpy object. Access using
{[}index{]}{[}'name'{]} and {[}index{]}{[}'data'{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_runinfo\_data() (omsi.dataformat.omsi\_file.analysis.omsi\_file\_analysis method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_file_analysis.get_all_runinfo_data}\pysiglinewithargsret{\bfcode{get\_all\_runinfo\_data}}{\emph{load\_data=False}}{}
Get a dict of all runtime information stored in the file
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
omsi.shared.run\_info\_data.run\_info\_dict type python dict with the runtime information restored.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_analysis\_data\_names() (omsi.dataformat.omsi\_file.analysis.omsi\_file\_analysis method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_file_analysis.get_analysis_data_names}\pysiglinewithargsret{\bfcode{get\_analysis\_data\_names}}{}{}
This function returns all dataset names (and groups) that are custom
to the analysis, i.e., that are not part of the omsi file standard.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of analysis-specific dataset names.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_analysis\_data\_shapes\_and\_types() (omsi.dataformat.omsi\_file.analysis.omsi\_file\_analysis method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_file_analysis.get_analysis_data_shapes_and_types}\pysiglinewithargsret{\bfcode{get\_analysis\_data\_shapes\_and\_types}}{}{}
This function returns two dictionaries with all dataset names (and groups)
that are custom to the analysis, i.e., that are not part of the omsi
file standard, and idenifies the shape of the analysis data objects.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Dictonary indicating for each analysis-specific dataset its name (key) and
shape (value). And a second dictionariy indicating the name (key) and dtype
of the dataset.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_analysis\_identifier() (omsi.dataformat.omsi\_file.analysis.omsi\_file\_analysis method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_file_analysis.get_analysis_identifier}\pysiglinewithargsret{\bfcode{get\_analysis\_identifier}}{}{}
Get the identifier name of the analysis.

Use get\_analysis\_identifier(){[}...{]} to retrive the identifier string.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
h5py object for the dataset with the identifier string.
Returns None, in case no identifer exisits. This should
not be the case for a valid OpenMSI file.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_analysis\_index() (omsi.dataformat.omsi\_file.analysis.omsi\_file\_analysis method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_file_analysis.get_analysis_index}\pysiglinewithargsret{\bfcode{get\_analysis\_index}}{}{}
Based on the name of the group, get the index of the analysis.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Integer index of the analysis in the file.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_analysis\_type() (omsi.dataformat.omsi\_file.analysis.omsi\_file\_analysis method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_file_analysis.get_analysis_type}\pysiglinewithargsret{\bfcode{get\_analysis\_type}}{}{}
Get the type for the analysis.

Use get\_analysis\_type(){[}...{]} tor retrieve the type string.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
h5py object with the dataset of the analysis string. Returns,
None in case no analysis type exists. This should not be the
case in a valid omsi file.

\end{description}\end{quote}

\end{fulllineitems}

\index{recreate\_analysis() (omsi.dataformat.omsi\_file.analysis.omsi\_file\_analysis method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_file_analysis.recreate_analysis}\pysiglinewithargsret{\bfcode{recreate\_analysis}}{\emph{**kwargs}}{}
Load an analysis from file and re-execute it.
This is equivalent to omsi\_analysis.base.restore\_analysis().execute()
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{kwargs}} -- Additional keyword arguments to be passed to the execute function of the analysis

\item[{Returns}] \leavevmode
Instance of the specific analysis object (e.g, omsi\_nmf) that inherits from
omsi.analysis.analysis\_base with the input parameters and
dependencies restored from file. The output, however, is the result from
re-executing the analysis. None is returned in case the analysis object
cannot be created.

\end{description}\end{quote}

\end{fulllineitems}

\index{restore\_analysis() (omsi.dataformat.omsi\_file.analysis.omsi\_file\_analysis method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.analysis.omsi_file_analysis.restore_analysis}\pysiglinewithargsret{\bfcode{restore\_analysis}}{\emph{load\_data=True}, \emph{load\_parameters=True}, \emph{load\_runtime\_data=True}, \emph{dependencies\_omsi\_format=True}}{}
Load an analysis from file and create an instance of the appropriate
analysis object defined by the analysis type (i.e., a derived class
of \emph{omsi.analysis. analysis\_base})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{load\_data}} -- Should the analysis data be loaded from file (default) or just stored as h5py data objects

\item {} 
\textbf{\texttt{load\_parameters}} -- Should parameters be loaded from file (default) or just stored as h5py data objects.

\item {} 
\textbf{\texttt{load\_runtime\_data}} -- Should runtime data be loaded from file (default) or just stored as h5py data objects.

\item {} 
\textbf{\texttt{dependencies\_omsi\_format}} -- Should dependencies be loaded as omsi\_file API objects (default)
or just as h5py objects.

\end{itemize}

\item[{Returns}] \leavevmode
Instance of the specific analysis object (e.g, omsi\_nmf) that inherits from
omsi.analysis.analysis\_base with the input parameters, output result,
and dependencies restored. We can call execute(..) on the returned object
to rerun an analysis. May return analysis\_generic in case that the
specific analysis is not known.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{\texttt{dependencies} Module}
\label{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.dependencies}\label{omsi.dataformat.omsi_file:dependencies-module}\index{omsi.dataformat.omsi\_file.dependencies (module)}
Base module for managing of dependencies between data in OpenMSI HDF5 files
\index{omsi\_dependencies\_manager (class in omsi.dataformat.omsi\_file.dependencies)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_dependencies_manager}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.dependencies.}\bfcode{omsi\_dependencies\_manager}}{\emph{dependencies\_parent}}{}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_object_manager]{\emph{\code{omsi.dataformat.omsi\_file.common.omsi\_file\_object\_manager}}}}

Dependencies manager helper class
used to define common functionality needed for managing dependencies.
Usually, a class that defines a format that contains an omsi\_file\_dependencies object
will inherit from this class (in addition to omsi\_file\_common) to acquire the common
features.

For more details see: \emph{omsi.dataforamt.omsi\_file.omsi\_common.omsi\_file\_object\_manager}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{dependencies\_parent}} -- h5py.Group object containing the dependencies object(s) to be managed

\item {} 
{\hyperref[omsi.dataformat.omsi_file:module\string-omsi.dataformat.omsi_file.dependencies]{\emph{\textbf{\texttt{dependencies}}}}} -- omsi\_file\_dependencies object managed by this object or None

\end{itemize}

\item[{Parameters}] \leavevmode
\textbf{\texttt{dependencies\_parent}} -- Parent group containing the dependencies object to be managed

\end{description}\end{quote}
\index{add\_dependency() (omsi.dataformat.omsi\_file.dependencies.omsi\_dependencies\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_dependencies_manager.add_dependency}\pysiglinewithargsret{\bfcode{add\_dependency}}{\emph{dependency}, \emph{flush\_io=True}}{}
Create a new dependency for this dataset
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{dependency}} -- omsi.shared.dependency\_dict object describing the data dependency

\item {} 
\textbf{\texttt{flush\_io}} -- Call flush on the HDF5 file to ensure all HDF5 bufferes are flushed
so that all data has been written to file

\end{itemize}

\item[{Returns}] \leavevmode
omsi\_file\_dependencydata object with the dependency data or None in case that
an error occurred and the dependency has not been generated.

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_dependencies() (omsi.dataformat.omsi\_file.dependencies.omsi\_dependencies\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_dependencies_manager.create_dependencies}\pysiglinewithargsret{\bfcode{create\_dependencies}}{\emph{dependencies\_data\_list=None}}{}
Create a managed group for storing data dependencies if none exists and store
the given set of dependencies in it. If a self.dependencies object already
exists, then the given dependencies will be added.

This is effectively a shortcut to omsi\_file\_dependencies.\_\_create\_\_\_(...) with specific
settings for the current dependencies object managed by self.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{dependencies\_data\_list}} -- List of dependency\_dict objects to be stored as dependencies.
Default is None which is mapped to an empty list {[}{]}

\item[{Returns}] \leavevmode
omsi\_file\_dependencies object created by the function.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_dependency\_data() (omsi.dataformat.omsi\_file.dependencies.omsi\_dependencies\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_dependencies_manager.get_all_dependency_data}\pysiglinewithargsret{\bfcode{get\_all\_dependency\_data}}{\emph{omsi\_dependency\_format=True}}{}
Get all direct dependencies associated with the data object.

This is convenience function providing access to
self.dependencies.get\_all\_dependency\_data(...) which is a function
of omsi\_file\_dependencies class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{omsi\_dependency\_format}} -- Should the dependencies be retrieved as omsi\_analysis\_dependency object (True)
or as an omsi\_file\_dependencydata object (False).

\item[{Returns}] \leavevmode
List dependency\_dict objects containing either omsi file API objects or h5py objects for the
dependencies. Access using {[}index{]}{[}'name'{]} and {[}index{]}{[}'data'{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_dependency\_data\_graph() (omsi.dataformat.omsi\_file.dependencies.omsi\_dependencies\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_dependencies_manager.get_all_dependency_data_graph}\pysiglinewithargsret{\bfcode{get\_all\_dependency\_data\_graph}}{\emph{include\_omsi\_dependency=False}, \emph{include\_omsi\_file\_dependencydata=False}, \emph{recursive=True}, \emph{level=0}, \emph{name\_key='name'}, \emph{prev\_nodes=None}, \emph{prev\_links=None}, \emph{parent\_index=None}, \emph{metadata\_generator=None}, \emph{metadata\_generator\_kwargs=None}}{}
Get all direct and indirect dependencies associated with the analysis in form of a graph describing
all nodes and links in the provenance hierarchy.

This is convenience function providing access to
self.dependencies.get\_all\_dependency\_data\_graph(...) which is a function
of omsi\_file\_dependencies class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{include\_omsi\_dependency}} -- Should the dependency\_dict object be included in the entries
in the nodes dict?

\item {} 
\textbf{\texttt{include\_omsi\_file\_dependencydata}} -- Should the omsi\_file\_dependencydata object be included in
the entries in the nodes dict?

\item {} 
\textbf{\texttt{recursive}} -- Should we trace dependencies recursively to construct the full graph, or only the
direct dependencies. Default true (ie., trace recursively)

\item {} 
\textbf{\texttt{name\_key}} -- Which key should be used in the dicts to indicate the name of the object?
Default value is `name'

\item {} 
\textbf{\texttt{level}} -- Integer used to indicated the recursion level. Default value is 0.

\item {} 
\textbf{\texttt{prev\_nodes}} -- List of nodes that have been previously generated. Note, this list will be
modified by the call. Note, each node is represented by a dict which is expected to
have at least the following keys defined, path, name\_key, level (name\_key refers to the key
defined by the input parameter name\_key.

\item {} 
\textbf{\texttt{prev\_links}} -- Previouly established links in the list of nodes. Note, this list will be
modified by the call.

\item {} 
\textbf{\texttt{parent\_index}} -- Index of the parent node in the list of prev\_nodes for this call.

\item {} 
\textbf{\texttt{metadata\_generator}} -- 
Optional parameter. Pass in a function that generates additional metadata
about a given omsi API object. Note, the key's level and path and name (i.e., name\_key) are
already set by this function. The metadata\_generator may overwrite these key's, however,
the path has to be unique as it is used to identify duplicate nodes. Overwriting the path
with a non-unique value, hence, will lead to errors (missing entries) when generating the graph.
Note, the metadata\_generator function needs to support the following keyword arguments:
\begin{itemize}
\item {} 
inDict : The dictionary to which the metadata should be added to.

\item {} 
obj : The omsi file API object for which metadata should be generated

\item {} 
name : A qualifying name for the object

\item {} 
name\_key : The key to be used for storing the name

\end{itemize}


\item {} 
\textbf{\texttt{metadata\_generator\_kwargs}} -- Dictionary of additional keyword arguments that should be passed to
the metadata\_generator function.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{Dictionary containing two lists. 1) nodes}] \leavevmode{[}List of dictionaries, describing the elements{]}
in the dependency graph. 2) links : List of tuples with the links in the graph. Each
tuple consists of two integer indices for the nodes list. For each node the following
entries are given:

\end{description}
\begin{itemize}
\item {} \begin{description}
\item[{dependency\_dict: Optional key used to store the corresponding dependency\_dict object.}] \leavevmode
Used only of include\_omsi\_dependency is True.

\end{description}

\item {} \begin{description}
\item[{omsi\_file\_dependencydata: Optional key used to store the corresponding}] \leavevmode
omsi\_file\_dependencydata object. Used only of include\_omsi\_file\_dependencydata is True.

\end{description}

\item {} 
name : Name of the dependency. The actual key is sepecified by name\_key

\item {} 
level : The recursion level at which the object occurs.

\item {} 
... : Any other key/value pairs from the dependency\_dict dict.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_dependency\_data\_recursive() (omsi.dataformat.omsi\_file.dependencies.omsi\_dependencies\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_dependencies_manager.get_all_dependency_data_recursive}\pysiglinewithargsret{\bfcode{get\_all\_dependency\_data\_recursive}}{\emph{omsi\_dependency\_format=True}, \emph{omsi\_main\_parent=None}, \emph{dependency\_list=None}}{}
Get all direct and indirect dependencies associated with the data object.

This is convenience function providing access to
self.dependencies.get\_all\_dependency\_data\_recursive(...) which is a function
of omsi\_file\_dependencies class.

\textbf{NOTE:} omsi\_main\_parent and omsi\_main\_parent are used primarily to ensure that the
case of circular dependencies are supported properly. Circular dependencies may
occur in the case of semantic dependencies (rather than pure use dependencies), e.g.,
two datasets that are related modalities may reference each other, e.g., MS1 pointing
to related MS2 data and the MS2 datasets referencing the corresponding MS1 datasets.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{omsi\_dependency\_format}} -- Should the dependencies be retrieved as dependency\_dict object (True)
or as an omsi\_file\_dependencydata object (False)

\item {} 
\textbf{\texttt{omsi\_main\_parent}} -- The main parent for which the dependencies are calculated. This is needed
to avoid recursion back into the main parent for which we are computing dependencies and avoiding
that it is added itself as a dependency for itself. If set to None, then we will use our own
self.dependencies\_parent object

\item {} 
\textbf{\texttt{dependency\_list}} -- List of previously visited/created dependencies. This is needed only
to avoid deep recursion and duplication due to circular dependencies

\end{itemize}

\item[{Returns}] \leavevmode
List analysis\_data objects containing either omsi file API interface objects or h5py
objects for the dependcies. Access using {[}index{]}{[}'name'{]} and {[}index{]}{[}'data'{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{has\_dependencies() (omsi.dataformat.omsi\_file.dependencies.omsi\_dependencies\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_dependencies_manager.has_dependencies}\pysiglinewithargsret{\bfcode{has\_dependencies}}{}{}
Check whether any dependencies exists for this datasets

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_file\_dependencies (class in omsi.dataformat.omsi\_file.dependencies)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencies}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.dependencies.}\bfcode{omsi\_file\_dependencies}}{\emph{dependencies\_group}}{}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common]{\emph{\code{omsi.dataformat.omsi\_file.common.omsi\_file\_common}}}}

Class for managing collections of dependencies.

** Use of super()**

This class inherits from \emph{omsi.dataformat.omsi\_file.common.omsi\_file\_common}.
Consistent with the design pattern for multiple inheritance of the
\emph{omsi.dataformat.omsi\_file} module, the \_\_init\_\_ function calls
super(...).\_\_init\_\_(manager\_group) with a single  parameter indicating the
parent group.
\index{\_omsi\_file\_dependencies\_\_create\_dependency\_graph\_node() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencies static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencies._omsi_file_dependencies__create_dependency_graph_node}\pysiglinewithargsret{\strong{static }\bfcode{\_omsi\_file\_dependencies\_\_create\_dependency\_graph\_node}}{\emph{level}, \emph{name}, \emph{path}, \emph{dependency\_object}, \emph{omsi\_object}, \emph{include\_omsi\_dependency=False}, \emph{include\_omsi\_file\_dependencydata=False}, \emph{name\_key='name'}, \emph{metadata\_generator=None}, \emph{metadata\_generator\_kwargs=None}}{}
Internal helper function used to create a new node in the graph
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{level}} -- The recursion level at which the node exists

\item {} 
\textbf{\texttt{name}} -- The name of the node

\item {} 
\textbf{\texttt{path}} -- The path of the node

\item {} 
\textbf{\texttt{dependency\_object}} -- The omsi\_file\_dependencydata object. May be None in case a node
to a specific object is set

\item {} 
\textbf{\texttt{omsi\_object}} -- The OpenMSI file API object. This is required and may NOT be None.

\item {} 
\textbf{\texttt{include\_omsi\_dependency}} -- Should the dependency\_dict object be included in the entries
in the nodes dict?

\item {} 
\textbf{\texttt{include\_omsi\_file\_dependencydata}} -- Should the omsi\_file\_dependencydata object be included in
the entries in the nodes dict?

\item {} 
\textbf{\texttt{name\_key}} -- Which key should be used in the dicts to indicate the name of the object?
Default value is `name'

\item {} 
\textbf{\texttt{metadata\_generator}} -- 
Optional parameter. Pass in a function that generates additional metadata
about a given omsi API object. Note, the key's level and path and name (i.e., name\_key) are
already set by this function. The metadata\_generator may overwrite these key's, however,
the path has to be unique as it is used to identify duplicate nodes. Overwriting the path
with a non-unique value, hence, will lead to errors (missing entries) when generating the graph.
Note, the metadata\_generator function needs to support the following keyword arguments:
\begin{itemize}
\item {} 
in\_dict : The dictionary to which the metadata should be added to.

\item {} 
obj : The omsi file API object for which metadata should be generated

\item {} 
name : A qualifying name for the object

\item {} 
name\_key : The key to be used for storing the name

\end{itemize}


\item {} 
\textbf{\texttt{metadata\_generator\_kwargs}} -- Dictionary of additional keyword arguments that should be passed to
the metadata\_generator function.

\end{itemize}

\item[{Returns}] \leavevmode
Dict describing the new node, containing the `name', `level', and `path' and
optionally `dependency\_dict' and/or `omsi\_file\_dependencydata' and any additional
data generated by the metadata\_generator function

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_dependency() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencies method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencies.add_dependency}\pysiglinewithargsret{\bfcode{add\_dependency}}{\emph{dependency\_data}}{}
Add a new dependency to the collection.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{dependency\_data}} (\emph{\texttt{omsi.shared.omsi\_dependency\_data}}) -- The analysis dependency specification.

\item[{Returns}] \leavevmode
the newly created omsi\_file\_dependencydata object

\item[{Raises}] \leavevmode
KeyError in case that a dependency with the same name already exists

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_dependency\_data() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencies method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencies.get_all_dependency_data}\pysiglinewithargsret{\bfcode{get\_all\_dependency\_data}}{\emph{omsi\_dependency\_format=True}}{}
Get all direct dependencies associated with the analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{omsi\_dependency\_format}} -- Should the dependencies be retrieved as omsi\_analysis\_dependency object
(True) or as an omsi\_file\_dependencydata object (False).

\item[{Returns}] \leavevmode
List dependency\_dict objects containing either omsi file API objects or h5py objects for
the dependencies. Access using {[}index{]}{[}'name'{]} and {[}index{]}{[}'data'{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_dependency\_data\_graph() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencies method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencies.get_all_dependency_data_graph}\pysiglinewithargsret{\bfcode{get\_all\_dependency\_data\_graph}}{\emph{include\_omsi\_dependency=False}, \emph{include\_omsi\_file\_dependencydata=False}, \emph{recursive=True}, \emph{level=0}, \emph{name\_key='name'}, \emph{prev\_nodes=None}, \emph{prev\_links=None}, \emph{parent\_index=None}, \emph{metadata\_generator=None}, \emph{metadata\_generator\_kwargs=None}}{}
Get all direct and indirect dependencies associated with the analysis in form of a graph describing
all nodes and links in the provenance hierarchy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{include\_omsi\_dependency}} -- Should the dependency\_dict object be included in the entries
in the nodes dict?

\item {} 
\textbf{\texttt{include\_omsi\_file\_dependencydata}} -- Should the omsi\_file\_dependencydata object be included in
the entries in the nodes dict?

\item {} 
\textbf{\texttt{recursive}} -- Should we trace dependencies recursively to construct the full graph, or only the
direct dependencies. Default true (ie., trace recursively)

\item {} 
\textbf{\texttt{name\_key}} -- Which key should be used in the dicts to indicate the name of the object?
Default value is `name'

\item {} 
\textbf{\texttt{level}} -- Integer used to indicated the recursion level. Default value is 0.

\item {} 
\textbf{\texttt{prev\_nodes}} -- List of nodes that have been previously generated. Note, this list will be
modified by the call. Note, each node is represented by a dict which is expected to
have at least the following keys defined, path, name\_key, level (name\_key refers to the key
defined by the input parameter name\_key.

\item {} 
\textbf{\texttt{prev\_links}} -- Previously established links in the list of nodes. Note, this list will be
modified by the call.

\item {} 
\textbf{\texttt{parent\_index}} -- Index of the parent node in the list of prev\_nodes for this call. May be
None in case the parent we are calling this function for is not yet in the list. If None,
then we will add our own parent that contains the dependencies to the list.

\item {} 
\textbf{\texttt{metadata\_generator}} -- 
Optional parameter. Pass in a function that generates additional metadata
about a given omsi API object. Note, the key's level and path and name (i.e., name\_key) are
already set by this function. The metadata\_generator may overwrite these key's, however,
the path has to be unique as it is used to identify duplicate nodes. Overwriting the path
with a non-unique value, hence, will lead to errors (missing entries) when generating the graph.
Note, the metadata\_generator function needs to support the following keyword arguments:
\begin{itemize}
\item {} 
in\_dict : The dictionary to which the metadata should be added to.

\item {} 
obj : The omsi file API object for which metadata should be generated

\item {} 
name : A qualifying name for the object

\item {} 
name\_key : The key to be used for storing the name

\end{itemize}


\item {} 
\textbf{\texttt{metadata\_generator\_kwargs}} -- Dictionary of additional keyword arguments that should be passed to
the metadata\_generator function.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{Dictionary containing two lists. 1) nodes}] \leavevmode{[}List of dictionaries, describing the elements{]}
in the dependency graph. 2) links : List of tuples with the links in the graph. Each
tuple consists of two integer indices for the nodes list. For each node the following
entries are given:

\end{description}
\begin{itemize}
\item {} \begin{description}
\item[{dependency\_dict: Optional key used to store the corresponding dependency\_dict object.}] \leavevmode
Used only of include\_omsi\_dependency is True.

\end{description}

\item {} \begin{description}
\item[{omsi\_file\_dependencydata: Optional key used to store the corresponding}] \leavevmode
omsi\_file\_dependencydata object. Used only of include\_omsi\_file\_dependencydata is True.

\end{description}

\item {} 
name : Name of the dependency. The actual key is sepecified by name\_key

\item {} 
level : The recursion level at which the object occurs.

\item {} 
path : The full path to the object

\item {} 
filename : The full path to the file

\item {} 
... : Any other key/value pairs from the dependency\_dict dict.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_dependency\_data\_recursive() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencies method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencies.get_all_dependency_data_recursive}\pysiglinewithargsret{\bfcode{get\_all\_dependency\_data\_recursive}}{\emph{omsi\_dependency\_format=True}, \emph{omsi\_main\_parent=None}, \emph{dependency\_list=None}}{}
Get all direct and indirect dependencies associated with the analysis.

\textbf{NOTE:} omsi\_main\_parent and omsi\_main\_parent are used primarily to ensure that the
case of circular dependencies are supported properly. Circular dependencies may
occur in the case of semantic dependencies (rather than pure use dependencies), e.g.,
two datasets that are related modalities may reference each other, e.g., MS1 pointing
to related MS2 data and the MS2 datasets referencing the corresponding MS1 datasets.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{omsi\_dependency\_format}} -- Should the dependencies be retrieved as dependency\_dict object (True)
or as an omsi\_file\_dependencydata object (False)

\item {} 
\textbf{\texttt{omsi\_main\_parent}} -- The main parent for which the dependencies are calculated. This is needed
to avoid recursion back into the main parent for which we are computing dependencies and avoiding
that it is added itself as a dependency for itself. If set to None, then we will use the omsi\_object
associated with the parent group of the dependency group.

\item {} 
\textbf{\texttt{dependency\_list}} -- List of previously visited/created dependencies. This is needed only
to avoid deep recursion and duplication due to circular dependencies

\end{itemize}

\item[{Returns}] \leavevmode
List analysis\_data objects containing either omsi file API interface objects or
h5py objects for the dependcies. Access using {[}index{]}{[}'name'{]} and {[}index{]}{[}'data'{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_dependency\_omsiobject() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencies method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencies.get_dependency_omsiobject}\pysiglinewithargsret{\bfcode{get\_dependency\_omsiobject}}{\emph{name}, \emph{recursive=True}}{}~\begin{quote}

Get the omsi file API object corresponding to the object the dependency is pointing to.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- Name of the dependency opbject to be loaded .

\item {} 
\textbf{\texttt{recursive}} -- Should the dependency be resolved recursively, i.e., if the dependeny points
to another dependencies. Default=True.

\end{itemize}

\item[{Returns}] \leavevmode
An omsi file API object (e.g., omsi\_file\_analysis or omsi\_file\_msidata) if the link points
to a group or the h5py.Dataset the link is pointing to.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_omsi\_file\_dependencydata() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencies method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencies.get_omsi_file_dependencydata}\pysiglinewithargsret{\bfcode{get\_omsi\_file\_dependencydata}}{\emph{name}}{}
Retrieve the omsi\_file\_dependencydata object for the dependency with the given name.

\end{fulllineitems}


\end{fulllineitems}

\index{omsi\_file\_dependencydata (class in omsi.dataformat.omsi\_file.dependencies)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencydata}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.omsi\_file.dependencies.}\bfcode{omsi\_file\_dependencydata}}{\emph{dependency\_group}}{}
Bases: {\hyperref[omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.common.omsi_file_common]{\emph{\code{omsi.dataformat.omsi\_file.common.omsi\_file\_common}}}}

Class for managing data groups used for storing data dependencies

Create a new omsi\_file\_dependencydata object for the given h5py.Group
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{dependency\_group}} (\emph{\texttt{h5py.Group with a corresponding omsi type}}) -- h5py.Group object with the dependency data

\end{description}\end{quote}
\index{get\_dataset\_name() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencydata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencydata.get_dataset_name}\pysiglinewithargsret{\bfcode{get\_dataset\_name}}{}{}
Get the string indicating the name of dataset. This may be empty as it is only used if the
dependency points to an objec within a managed omsi API object.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
String indicating the name of the optional dataset.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_dependency\_objecttype() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencydata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencydata.get_dependency_objecttype}\pysiglinewithargsret{\bfcode{get\_dependency\_objecttype}}{\emph{recursive=True}}{}
Indicated the type of the object the dependency is pointing to.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{recursive}} -- Should dependencies be resolved recursively, i.e., if the dependency points to another
dependencies. Default=True.

\item[{Returns}] \leavevmode
String indicating the class of the omsi file API class that is suited to manage the dependency
link or the name of the corresponding h5py class.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_dependency\_omsiobject() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencydata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencydata.get_dependency_omsiobject}\pysiglinewithargsret{\bfcode{get\_dependency\_omsiobject}}{\emph{recursive=True}, \emph{external\_mode=None}}{}
Get the omsi file API object corresponding to the object the dependency is pointing to.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{recursive}} -- Should dependencies be resolved recursively, i.e., if the dependency points
to another dependencies. Default=True.

\item {} 
\textbf{\texttt{external\_mode}} -- The file open mode (e.g., `r', `a') to be used when we encounter external dependencies,
i.e., dependencies that are stored in external files. By default this is set to None,
indicating that the same mode should be used in which this (i.e,. the current file
describing the dependency) was opened. Allowed modes are `r', `r+', and `a'. The modes
`w', `w+, `x' are prohibited to ensure that we do not break external files.

\end{itemize}

\item[{Returns}] \leavevmode
An omsi file API object (e.g., omsi\_file\_analysis or omsi\_file\_msidata) if the link
points to a group or the h5py.Dataset the link is pointing to.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_dependency\_type() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencydata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencydata.get_dependency_type}\pysiglinewithargsret{\bfcode{get\_dependency\_type}}{}{}
Get the string describing the type of the dependency

NOTE: If the type is missing in the file but we have a parameter name specified,
then the default type `parameter' will be returned other None is returned.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
String indicating the type of the dependency or None if the type is not known.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_link\_name() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencydata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencydata.get_link_name}\pysiglinewithargsret{\bfcode{get\_link\_name}}{}{}
Get the name of the dependency link
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
String indicating the name of the dependency link.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_mainname() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencydata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencydata.get_mainname}\pysiglinewithargsret{\bfcode{get\_mainname}}{}{}
Get the main name string describing the name of the object (and possibly path of the file if external)
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
String indicating the main name of the object that we link to

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_omsi\_dependency() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencydata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencydata.get_omsi_dependency}\pysiglinewithargsret{\bfcode{get\_omsi\_dependency}}{}{}
Get the dependency information as an omsi.shared.dependency\_dict object
(as defined in the omsi.shared.dependency\_dict module)
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
dependency\_dict object with all the dependency data.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_parameter\_help() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencydata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencydata.get_parameter_help}\pysiglinewithargsret{\bfcode{get\_parameter\_help}}{}{}
Get the help string for the parameter name if available.

\end{fulllineitems}

\index{get\_parameter\_name() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencydata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencydata.get_parameter_name}\pysiglinewithargsret{\bfcode{get\_parameter\_name}}{}{}
Get the string indicating the name of the dependend parameter of the analysis.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
String of the parameter name that has the dependency.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_selection\_string() (omsi.dataformat.omsi\_file.dependencies.omsi\_file\_dependencydata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat.omsi_file:omsi.dataformat.omsi_file.dependencies.omsi_file_dependencydata.get_selection_string}\pysiglinewithargsret{\bfcode{get\_selection\_string}}{}{}
String indicating the applied selection. This is an empty string in case no selection was applied.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Selection string. See the omsi.shared.omsi\_data\_selection for helper functions to
deal with selection strings.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{\texttt{file\_reader\_base} Module}
\label{omsi.dataformat:module-omsi.dataformat.file_reader_base}\label{omsi.dataformat:file-reader-base-module}\index{omsi.dataformat.file\_reader\_base (module)}
Module for base classes for implementation and integration of third-party file readers.

ToDo:
\begin{itemize}
\item {} 
get\_number\_of\_regions(...) should be updated to return a list of regions, one per dataset

\item {} 
Need to add base class for multi dataset formats

\item {} 
Need to add base class for multi dataset+region formats

\item {} 
Need to implement new file format for combined raw data file (ie., multiple raw files in one folder).

\end{itemize}
\index{file\_reader\_base (class in omsi.dataformat.file\_reader\_base)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.file\_reader\_base.}\bfcode{file\_reader\_base}}{\emph{basename}, \emph{requires\_slicing=True}}{}
Bases: \code{object}

Base-class used to define the basic interface that file-readers
for a new format need to implement.

\textbf{\_\_init\_\_ interface:}

To avoid the need for custom code subclasses should be able to be constructed     by providing just the basename parameter and optional requires\_slicing parameter.     If additional inputs are needed, then file conversion and management scripts     may need to be modified to account for the custom requirements. 
\textbf{Required Attributes:}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data\_type}} -- String indicating the data type to be used (e.g., uint16)

\item {} 
\textbf{\texttt{shape}} -- Tuple indicating the shape of the data

\item {} 
\textbf{\texttt{mz}} -- Numpy array with the m/z axis data. In the case of multi-data this is a
list of numpy arrays, one per dataset.

\item {} 
\textbf{\texttt{basename}} -- The basename provided for opening the file.

\end{itemize}

\end{description}\end{quote}

\textbf{Required Interface Functions:}
\begin{itemize}
\item {} 
\code{close\_file} : Close any opened files

\item {} 
\code{is\_valid\_dataset} : Check whether a given dir/file is valid under the current format

\item {} 
\code{spectrum\_iter} : Generator function that iterates over all the spectra in the current data cube and yield the         numpy array with the intensity and integer x, y position of the spectrum

\end{itemize}

\textbf{Optional Interface Functions:}
\begin{itemize}
\item {} \begin{description}
\item[{\code{\_\_getitem\_\_}}] \leavevmode{[}Implement array slicing for files. Reuqired if the requires\_slicing parameter{]}
should be supported.

\end{description}

\item {} 
\code{supports\_regions} : Specify whether the format supports multiple regions (default=False)

\item {} 
\code{supports\_multidata}: Specify whether the format supports multiple datasets (default=False)

\item {} 
\code{supports\_multiexperiment}: Specify whether the format supports multiple experiments (default=False)

\end{itemize}

Construct the base class and define required attributes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{basename}} -- The name of the file or directory with the file to be opened by the reader

\item {} 
\textbf{\texttt{requires\_slicing}} -- Boolean indicating whether the user requires array slicing via
the \_\_getitem\_\_ function to work or not. This is an optimization, because many MSI
data formats do not easily support arbitrary slicing of data but rather only
iteration over spectra.

\end{itemize}

\end{description}\end{quote}
\index{available\_formats() (omsi.dataformat.file\_reader\_base.file\_reader\_base static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base.available_formats}\pysiglinewithargsret{\strong{static }\bfcode{available\_formats}}{}{}
Get dictionary of all available file formats that implement the file\_format\_base API.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Dictionary where the keys are the names of the formats and the values are
the corresponding file reader classes.

\end{description}\end{quote}

\end{fulllineitems}

\index{close\_file() (omsi.dataformat.file\_reader\_base.file\_reader\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base.close_file}\pysiglinewithargsret{\bfcode{close\_file}}{}{}
Close the file.

\end{fulllineitems}

\index{format\_name() (omsi.dataformat.file\_reader\_base.file\_reader\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base.format_name}\pysiglinewithargsret{\strong{classmethod }\bfcode{format\_name}}{}{}
Define the name of the format.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
String indicating the name of the format.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_dataset\_metadata() (omsi.dataformat.file\_reader\_base.file\_reader\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base.get_dataset_metadata}\pysiglinewithargsret{\bfcode{get\_dataset\_metadata}}{}{}
Get dict of additional metadata associated with the current dataset

NOTE: In the case that multiple regions and/or datasets are supported,
this function should return the metadata of the currently selected
dataset only. If no particular dataset is selected, then all should
be returned.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Instance of omsi.shared.metadata\_data.metadata\_dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_number\_of\_datasets() (omsi.dataformat.file\_reader\_base.file\_reader\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base.get_number_of_datasets}\pysiglinewithargsret{\bfcode{get\_number\_of\_datasets}}{}{}
File readers with multi dataset support must overwrite this function
to retrieve the true number of raw datasets in the file.
Default implementation returns 1.

\end{fulllineitems}

\index{get\_number\_of\_regions() (omsi.dataformat.file\_reader\_base.file\_reader\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base.get_number_of_regions}\pysiglinewithargsret{\bfcode{get\_number\_of\_regions}}{}{}
File readers with multi region support must overwrite this function
to retrieve the true number of regions in the file.
Default implementation returns 1.

\end{fulllineitems}

\index{is\_valid\_dataset() (omsi.dataformat.file\_reader\_base.file\_reader\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base.is_valid_dataset}\pysiglinewithargsret{\strong{classmethod }\bfcode{is\_valid\_dataset}}{\emph{name}}{}
Classmethod used to check whether a given directory (or file)
defines as valid data file of the file format specified by
the current child class
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{name}} (\emph{\texttt{String}}) -- Name of the dir or file.

\item[{Returns}] \leavevmode
Boolean indicating whether the given file or folder is a valid file.

\end{description}\end{quote}

\end{fulllineitems}

\index{size() (omsi.dataformat.file\_reader\_base.file\_reader\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base.size}\pysiglinewithargsret{\strong{classmethod }\bfcode{size}}{\emph{name}}{}
Classmethod used to check the estimated size for the given file/folder.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{name}} (\emph{\texttt{String}}) -- Name of the dir or file.

\item[{Returns}] \leavevmode
Integer indicating the size in byte or None if unknown.

\end{description}\end{quote}

\end{fulllineitems}

\index{spectrum\_iter() (omsi.dataformat.file\_reader\_base.file\_reader\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base.spectrum_iter}\pysiglinewithargsret{\bfcode{spectrum\_iter}}{}{}
Enable iteration of the spectra of the current data cube.

Iterate over all the spectra in the current data cube and yield the
numpy array with the intensity and integer x, y position of the spectrum.

NOTE: As this is a generator one needs to use yield.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode

The function yields for each spectrum the following information:
\begin{itemize}
\item {} 
tuple of (x,y) or (x,y,z) position of the spectrum

\item {} 
Numpy array with the spectrum

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{supports\_multidata() (omsi.dataformat.file\_reader\_base.file\_reader\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base.supports_multidata}\pysiglinewithargsret{\strong{classmethod }\bfcode{supports\_multidata}}{}{}
Define whether the file format support multiple independent datasets.

\end{fulllineitems}

\index{supports\_multiexperiment() (omsi.dataformat.file\_reader\_base.file\_reader\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base.supports_multiexperiment}\pysiglinewithargsret{\strong{classmethod }\bfcode{supports\_multiexperiment}}{}{}
Define whether the file format supports multiple independent experiments,
each of which may contain multiple datasets.

\end{fulllineitems}

\index{supports\_regions() (omsi.dataformat.file\_reader\_base.file\_reader\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base.supports_regions}\pysiglinewithargsret{\strong{classmethod }\bfcode{supports\_regions}}{}{}
Define whether the file format support multiple regions.

\end{fulllineitems}


\end{fulllineitems}

\index{file\_reader\_base\_multidata (class in omsi.dataformat.file\_reader\_base)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base_multidata}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.file\_reader\_base.}\bfcode{file\_reader\_base\_multidata}}{\emph{basename}, \emph{requires\_slicing}}{}
Bases: {\hyperref[omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base]{\emph{\code{omsi.dataformat.file\_reader\_base.file\_reader\_base}}}}

Base-class used to define the basic interface for file-readers
used to implement new file formats with support for multiple
dataset (e.g, MSI dataset with multiple spectrum types).
This class extends file\_reader\_base, and accordingly all
required attributes and functions of
file\_reader\_base must be implemented by subclasses.

In addition to the file\_reader\_base functions we need to implement
the get\_number\_of\_datasets(...) and get\_dataset\_dependencies(...)
functions.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{select\_dataset}} -- Unsigned integer indicating the currently selected dataset

\end{description}\end{quote}

Construct the base class and define required attributes.
\index{get\_dataset\_dependencies() (omsi.dataformat.file\_reader\_base.file\_reader\_base\_multidata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base_multidata.get_dataset_dependencies}\pysiglinewithargsret{\bfcode{get\_dataset\_dependencies}}{}{}
Get the dependencies between the current dataset and any of the
other datasets stored in the current file. If self.select\_dataset
is not set, then the function is expected to return a list of lists
with all dependencies for all datasets.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode

List of dependencies (or list of lists of dependencies if self.select\_dataset is None)
where each dependency is a dict of the following form:
\begin{itemize}
\item {} 
`omsi\_object': None,         \# The omsi file API object where the data is stored. Often None.

\item {} 
`link\_name': ms2\_link\_name,  \# Name for the dependency link to be used

\item {} 
`basename': basename,        \# Basename of the file

\item {} 
`region': None,              \# Index of the region in the dataset or None

\item {} 
`dataset': ind2,             \# Index of the dataset withing the file or None

\item {} 
`help':scan\_types{[}ms1scan{]},  \# Help describing the depdency

\item {} 
dependency\_type': ... \}     \# Type of dependency see dependency\_dict.dependency\_type for available types

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_number\_of\_datasets() (omsi.dataformat.file\_reader\_base.file\_reader\_base\_multidata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base_multidata.get_number_of_datasets}\pysiglinewithargsret{\bfcode{get\_number\_of\_datasets}}{}{}
Get the number of available datasets.

\end{fulllineitems}

\index{set\_dataset\_selection() (omsi.dataformat.file\_reader\_base.file\_reader\_base\_multidata method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base_multidata.set_dataset_selection}\pysiglinewithargsret{\bfcode{set\_dataset\_selection}}{\emph{dataset\_index}}{}
Define the current dataset to be read.

\end{fulllineitems}

\index{supports\_multidata() (omsi.dataformat.file\_reader\_base.file\_reader\_base\_multidata class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base_multidata.supports_multidata}\pysiglinewithargsret{\strong{classmethod }\bfcode{supports\_multidata}}{}{}
Define whether the file format supports multiple data blocks.

\end{fulllineitems}


\end{fulllineitems}

\index{file\_reader\_base\_with\_regions (class in omsi.dataformat.file\_reader\_base)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base_with_regions}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.file\_reader\_base.}\bfcode{file\_reader\_base\_with\_regions}}{\emph{basename}, \emph{requires\_slicing}}{}
Bases: {\hyperref[omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base]{\emph{\code{omsi.dataformat.file\_reader\_base.file\_reader\_base}}}}

Base-class used to define the basic interface for file-readers
used to implement new file formats with support for multiple
imaging regions per file. This class extends file\_reader\_base,
and accordingly all required attributes and functions of
file\_reader\_base must be implemented by subclasses.

\textbf{Additional required attributes:}
\begin{itemize}
\item {} 
\code{select\_region} : Integer indicating which region should be selected.                     If set to None, indicates that the data should be treated                     as a whole. If set to a region index, then the data should                     be treated by the reader as if it only pertains to that                     region, ie., the shape of the data should be set accordingly                     and \_\_getitem\_\_ should behave as such as well.

\item {} 
\code{region\_dicts} : List of dictionaries, where each dictionary describes a                     given region (e.g,. the origin and extend for rectangular                     regions.

\end{itemize}

Construct the base class and define required attributes.
\index{get\_dataset\_dependencies() (omsi.dataformat.file\_reader\_base.file\_reader\_base\_with\_regions method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base_with_regions.get_dataset_dependencies}\pysiglinewithargsret{\bfcode{get\_dataset\_dependencies}}{}{}
Get the dependencies between the current region and any of the
other region datasets stored in the current file. If self.select\_region
is not set, then the function is expected to return a list of lists
with all dependencies for all datasets.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode

List of dependencies (or list of lists of dependencies if self.select\_dataset is None)
where each dependency is a dict of the following form:
\begin{itemize}
\item {} 
`omsi\_object': None,         \# The omsi file API object where the data is stored. Often None.

\item {} 
`link\_name': ms2\_link\_name,  \# Name for the dependency link to be used

\item {} 
`basename': basename,        \# Basename of the file

\item {} 
`region': None,              \# Index of the region in the dataset or None

\item {} 
`dataset': ind2,             \# Index of the dataset withing the file or None

\item {} 
`help':scan\_types{[}ms1scan{]},  \# Help describing the depdency

\item {} 
dependency\_type': ... \}     \# Type of dependency see dependency\_dict.dependency\_type for available types

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_number\_of\_regions() (omsi.dataformat.file\_reader\_base.file\_reader\_base\_with\_regions method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base_with_regions.get_number_of_regions}\pysiglinewithargsret{\bfcode{get\_number\_of\_regions}}{}{}
Get the number of available regions

\end{fulllineitems}

\index{get\_region\_selection() (omsi.dataformat.file\_reader\_base.file\_reader\_base\_with\_regions method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base_with_regions.get_region_selection}\pysiglinewithargsret{\bfcode{get\_region\_selection}}{}{}
Get the index of the selected region

\end{fulllineitems}

\index{get\_regions() (omsi.dataformat.file\_reader\_base.file\_reader\_base\_with\_regions method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base_with_regions.get_regions}\pysiglinewithargsret{\bfcode{get\_regions}}{}{}
Get list of all region dictionaries defining for each region the origin
and extend of the region. See also self.region\_dicts.

\end{fulllineitems}

\index{set\_region\_selection() (omsi.dataformat.file\_reader\_base.file\_reader\_base\_with\_regions method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base_with_regions.set_region_selection}\pysiglinewithargsret{\bfcode{set\_region\_selection}}{\emph{region\_index=None}}{}
Define which region should be selected for local data reads.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{region\_index}} -- The index of the region that should be read. The shape of the
data will be adjusted accordingly. Set to None to select all regions and treat
the data as a single full 3D image.

\end{description}\end{quote}

\end{fulllineitems}

\index{supports\_regions() (omsi.dataformat.file\_reader\_base.file\_reader\_base\_with\_regions class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base_with_regions.supports_regions}\pysiglinewithargsret{\strong{classmethod }\bfcode{supports\_regions}}{}{}
Define whether the file format support multiple regions.

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{\texttt{img\_file} Module}
\label{omsi.dataformat:img-file-module}\label{omsi.dataformat:module-omsi.dataformat.img_file}\index{omsi.dataformat.img\_file (module)}
This module provides functionality for reading img mass spectrometry image files
\index{img\_file (class in omsi.dataformat.img\_file)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.img_file.img_file}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.img\_file.}\bfcode{img\_file}}{\emph{hdr\_filename=None}, \emph{t2m\_filename=None}, \emph{img\_filename=None}, \emph{basename=None}, \emph{requires\_slicing=True}}{}
Bases: {\hyperref[omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base]{\emph{\code{omsi.dataformat.file\_reader\_base.file\_reader\_base}}}}

Interface for reading a single 2D img file

The img format consists of three different files:
i) hdr header file, ii) t2m which contains the m/z data,
iii) img data file.

Open an img file for data reading.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{hdr\_filename}} (\emph{\texttt{string}}) -- The name of the hdr header file

\item {} 
\textbf{\texttt{t2m\_filename}} (\emph{\texttt{string}}) -- The name of the t2m\_filename

\item {} 
\textbf{\texttt{img\_filename}} (\emph{\texttt{string}}) -- The name of the img data file

\item {} 
\textbf{\texttt{basename}} (\emph{\texttt{string}}) -- Instead of img\_filename, t2m\_filename, and hdr\_filename one may also supply just
a single basename. The basename is completed with the .img, .t2m, .hdr extension
to load the data.

\item {} 
\textbf{\texttt{requires\_slicing}} (\emph{\texttt{Boolean}}) -- Unused here. Slicing is always supported by this reader.

\end{itemize}

\item[{Raises}] \leavevmode
\textbf{\texttt{ValueError}} -- In case that basename and hdr\_filename, t2m\_filename, and img\_filename are specified.

\end{description}\end{quote}
\index{close\_file() (omsi.dataformat.img\_file.img\_file method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.img_file.img_file.close_file}\pysiglinewithargsret{\bfcode{close\_file}}{}{}
Close the img file

\end{fulllineitems}

\index{get\_files\_from\_dir() (omsi.dataformat.img\_file.img\_file class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.img_file.img_file.get_files_from_dir}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_files\_from\_dir}}{\emph{dirname}}{}
Get a list of all basenames of all img files in a given directory.
Note: The basenames include the dirname.

\end{fulllineitems}

\index{is\_valid\_dataset() (omsi.dataformat.img\_file.img\_file class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.img_file.img_file.is_valid_dataset}\pysiglinewithargsret{\strong{classmethod }\bfcode{is\_valid\_dataset}}{\emph{name}}{}
Check whether the given file or directory points to a img file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{name}} (\emph{\texttt{unicode}}) -- Name of the dir or file.

\item[{Returns}] \leavevmode
Boolean indicating whether the given file or folder is a valid img file.

\end{description}\end{quote}

\end{fulllineitems}

\index{size() (omsi.dataformat.img\_file.img\_file class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.img_file.img_file.size}\pysiglinewithargsret{\strong{classmethod }\bfcode{size}}{\emph{name}}{}
Classmethod used to check the estimated size for the given file/folder.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{name}} (\emph{\texttt{unicode}}) -- Name of the dir or file.

\item[{Returns}] \leavevmode
Integer indicating the size in byte or None if unknown.

\end{description}\end{quote}

\end{fulllineitems}

\index{spectrum\_iter() (omsi.dataformat.img\_file.img\_file method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.img_file.img_file.spectrum_iter}\pysiglinewithargsret{\bfcode{spectrum\_iter}}{}{}
Enable iteration over the spectra in the file
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
tuple of ((x , y) , intensities), i.e., the tuple of (x, y) integer index of the spectrum and
the numpy array of the intensities

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{\texttt{mzml\_file} Module}
\label{omsi.dataformat:mzml-file-module}

\subsubsection{\texttt{bruckerflex\_file} Module}
\label{omsi.dataformat:bruckerflex-file-module}\label{omsi.dataformat:module-omsi.dataformat.bruckerflex_file}\index{omsi.dataformat.bruckerflex\_file (module)}
This module provides functionality for reading bruker flex mass spectrometry image files

Limitations:
\begin{enumerate}
\item {} 
Currently the reader assumes a single global m/z axis for all spectra.

\item {} 
The read of acqu files does not convert \textless{}..\textgreater{} entries to python values but leaves them as strings.

\item {} 
\_\_read\_spotlist\_\_ converts the regions to start with a 0 index. This is somewhat inconsistent in the spot list file.  The spotname seems to number regions starting with 0 while the region list numbers them starting with 1.

\item {} 
\_\_read\_spotlist\_\_ computes the folder where the spots are located based on the filename of the spotlist.    The question is whether this is always the case??? The advantage is that we do not rely on the regions.xml    file which contains absolute paths which are in most cases invalid as the data has been copied between different    machines in many cases and is stored in different locations on each of the machines.

\item {} 
\_\_read\_spotlist\_\_ currenly assumes that there is only one fid file per spot

\item {} 
\_\_read\_spotlist\_\_ currenlty only looks at where the acqu and fid file is located for the spot. Other files   are currently ignored.

\item {} 
\_\_read\_spotlist\_\_ (and hence the reader at large) currently assumes that we have 2D images only.

\item {} 
\_\_read\_spotlist\_\_ currently generates maps for the image that assume that x and y pixel indices start at    0. Not all images may record data until the border, so that this strategy may add empty spectra rather than    generating a new bounding box for the image.

\item {} 
\_\_read\_spotlist\_\_ assumes in the variable spotname\_encoding a maximum of 24 characters in the spotname    R01X080Y013. This should in general be more than sufficient as this allows for 7 characters for each R, X,    Y entry, however, if this is not enough then this behaviour needs ot be changed.

\item {} 
\_\_getitem\_\_ currently only works if we have read the full data into memory. An on-demand load should be supported     as well.

\item {} 
We can currently only selected either a single region or the full data but we cannot selected multiple regions     at once. E.g. if a dataset contains 3 regions then we can either select all regions at once or region 1,2, or 3     but one cannot selected region 1+2, 1+3, or 2+3.

\end{enumerate}

import bruckerflex\_file
spotlist = ``/Users/oruebel/Devel/msidata/Bruker\_Data/UNC IMS Data/20130417 Bmycoides Paenibacillus Early SN03130/'' +            ``2013 Bmyc Paeni Early LP/2013 Bmyc Paeni Early LP Spot List.txt''
exppath =''/Users/oruebel/Devel/msidata/Bruker\_Data/UNC IMS Data/20130417 Bmycoides Paenibacillus Early SN03130/'' +         ``2013 Bmyc Paeni Early LP/2013 Bmyc Paeni Early LP/0\_R00X012Y006/1/1SLin''
f = bruckerflex\_file.bruckerflex\_file( spotlist\_filename = spotlist)
f.s\_read\_fid( exppath+''/fid'' , f.data\_type )
testacqu = f.s\_read\_acqu( exppath+''/acqu'' )
testmz   = f.s\_mz\_from\_acqu( testacqu )
testspotlist = f.s\_read\_spotlist(spotlist)

a = bruckerflex\_file( dirname )
\index{bruckerflex\_file (class in omsi.dataformat.bruckerflex\_file)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.bruckerflex_file.bruckerflex_file}\pysiglinewithargsret{\strong{class }\code{omsi.dataformat.bruckerflex\_file.}\bfcode{bruckerflex\_file}}{\emph{basename}, \emph{fid\_encoding='int32'}, \emph{requires\_slicing=True}}{}
Bases: {\hyperref[omsi.dataformat:omsi.dataformat.file_reader_base.file_reader_base_with_regions]{\emph{\code{omsi.dataformat.file\_reader\_base.file\_reader\_base\_with\_regions}}}}

Interface for reading a single bruker flex image file.

The reader supports standard array slicing for data read. I.e., to read a
spectrum use {[}x,y,:{]} to read an ion image using {[}:,:,mz{]}.

The reader supports multiple regions, i.e., reading of different independent
regions that were imaged as part of the same dataset. Using the get\_regions, get\_number\_of\_regions,
set\_region\_selection and get\_region\_selection the user can interact with the
region settings. Using the set\_region\_selection the user can define whether
the data of the complete image should be read (set\_region(None), default) or
whether data from a single region should be read. When a region is selected,
then the reader acts as if the region were the complete dataset, i.e., the
shape variable is addjusted to fit the selected region and the \_\_get\_item\_\_
method (which is used to implement array-like slicing (e.g., {[}1,1,:{]})) behaves
as if the selected region where the full data.

Open an img file for data reading.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{basename}} (\emph{\texttt{string}}) -- Name of the textfile with the spotlist. Alternatively this may also be the                                       folder with the spots.

\item {} 
\textbf{\texttt{requires\_slicing}} (\emph{\texttt{bool}}) -- Should the complete data be read into memory (this makes slicing easier). (default is True)

\item {} 
\textbf{\texttt{fid\_encoding}} (\emph{\texttt{string}}) -- String indicating in which binary format the intensity values (fid files) are stored.                                  (default value is `int32')

\end{itemize}

\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{self.basename}} -- Name of the file with the spotlist

\item {} 
\textbf{\texttt{self.pixel\_dict}} -- 
dictionary with the pixel array metadata (see also s\_read\_spotlist(...)). Some of                  the main keys of the dictionary are, e.g. (see also s\_read\_spotlist(...)) :
\begin{itemize}
\item {} 
`spotfolder' : String indicating the folder where all the spot-data is located

\item {} 
`fid' : 2D numpy masked array of strings indicating for (x,y) pixel the fid file with                            the intensity values.

\item {} 
`acqu' : 2D numpy masked array of strings indicating for each (x,y) pixel the acqu file with the                            metadata for that pixel.

\item {} 
`regions' : 2D numpy masked array of integers indicating for each pixels the index of the region                            it belongs to.

\item {} 
`xpos' : 2D numpy masked array of integers indicated for each pixel its x position.

\item {} 
`ypos' : 2D numpy masked array of integers indicated for each pixel its x position.

\item {} 
`spotname' : 2D masked numpy array of strings with the names of the spot corresponding to a pixel.

\end{itemize}


\item {} 
\textbf{\texttt{self.data\_type}} -- the encoding used for intensity values

\item {} 
\textbf{\texttt{self.shape}} -- The 3D shape of the MSI data volume for the currently selected region.

\item {} 
\textbf{\texttt{self.full\_shape}} -- Shape of the full 3D MSI dataset including all regions imaged.

\item {} 
\textbf{\texttt{self.metadata}} -- Dictionary with metadata from the acqu file

\item {} 
\textbf{\texttt{self.mz}} -- The 1D numpy array with the m/z axis information

\item {} 
\textbf{\texttt{self.data}} -- If requires\_slicing is set to true then this 3D array includes the complete data of the MSI data                   cube. Missing data values (e.g., from regions not imaged during the aquistion processes) are                   completed with zero values.

\item {} 
\textbf{\texttt{self.region\_dicts}} -- Dictionary with description of the imaging regions

\end{itemize}

\item[{Raises}] \leavevmode
\textbf{\texttt{ValueError}} -- In case that no valid data is found.

\end{description}\end{quote}
\index{close\_file() (omsi.dataformat.bruckerflex\_file.bruckerflex\_file method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.bruckerflex_file.bruckerflex_file.close_file}\pysiglinewithargsret{\bfcode{close\_file}}{}{}
Close the img file

\end{fulllineitems}

\index{get\_dataset\_dependencies() (omsi.dataformat.bruckerflex\_file.bruckerflex\_file method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.bruckerflex_file.bruckerflex_file.get_dataset_dependencies}\pysiglinewithargsret{\bfcode{get\_dataset\_dependencies}}{}{}
Get the dependencies between the current region and any of the
other region datasets stored in the current file. If self.select\_region
is not set, then the function is expected to return a list of lists
with all dependencies for all datasets.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode

List of dependencies (or list of lists of dependencies if self.select\_dataset is None)
where each dependency is a dict of the following form:
\begin{itemize}
\item {} 
`omsi\_object': None,         \# The omsi file API object where the data is stored. Often None.

\item {} 
`link\_name': ms2\_link\_name,  \# Name for the dependency link to be used

\item {} 
`basename': basename,        \# Basename of the file

\item {} 
`region': None,              \# Index of the region in the dataset or None

\item {} 
`dataset': ind2,             \# Index of the dataset withing the file or None

\item {} 
`help':scan\_types{[}ms1scan{]},  \# Help describing the depdency

\item {} 
dependency\_type': ... \}     \# Type of dependency see dependency\_dict.dependency\_type for available types

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{is\_valid\_dataset() (omsi.dataformat.bruckerflex\_file.bruckerflex\_file class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.bruckerflex_file.bruckerflex_file.is_valid_dataset}\pysiglinewithargsret{\strong{classmethod }\bfcode{is\_valid\_dataset}}{\emph{name}}{}
Determine whether the given file or name specifies a bruckerflex file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{name}} (\emph{\texttt{string}}) -- name of the file or dir

\item[{Returns}] \leavevmode
Boolean indicating whether the name is a valid bruckerflex

\end{description}\end{quote}

\end{fulllineitems}

\index{s\_mz\_from\_acqu() (omsi.dataformat.bruckerflex\_file.bruckerflex\_file static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.bruckerflex_file.bruckerflex_file.s_mz_from_acqu}\pysiglinewithargsret{\strong{static }\bfcode{s\_mz\_from\_acqu}}{\emph{acqu\_dict}}{}
Construct the m/z axis from the data stored in the acqu\_dict dictionary.
See also s\_read\_acqu
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{acqu\_dict}} -- 
Python dictionary with the complete information from the acqu file. See s\_read\_acqu(...).
\begin{quote}\begin{description}
\item[{returns}] \leavevmode
1D Numpy array of floats with the mz axis data.

\end{description}\end{quote}


\end{description}\end{quote}

\end{fulllineitems}

\index{s\_read\_acqu() (omsi.dataformat.bruckerflex\_file.bruckerflex\_file static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.bruckerflex_file.bruckerflex_file.s_read_acqu}\pysiglinewithargsret{\strong{static }\bfcode{s\_read\_acqu}}{\emph{filename}}{}
Construct an m/z axis for the given acqu file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{filename}} (\emph{\texttt{string}}) -- String with the name+path for the acqu file.

\item[{Returns}] \leavevmode
Return dictonary with the parsed metadata information

\end{description}\end{quote}

\end{fulllineitems}

\index{s\_read\_fid() (omsi.dataformat.bruckerflex\_file.bruckerflex\_file static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.bruckerflex_file.bruckerflex_file.s_read_fid}\pysiglinewithargsret{\strong{static }\bfcode{s\_read\_fid}}{\emph{filename}, \emph{data\_type='int32'}, \emph{selection=slice(None}, \emph{None}, \emph{None)}}{}
Read data from an fid file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filename}} (\emph{\texttt{string}}) -- String indicating the name+path to the fid file.

\item {} 
\textbf{\texttt{data\_type}} -- The numpy datatype encoding used for the fid files. (default is `int32').
In the instance of this class this is encoded in the data\_type variable associated
with the instance.

\item {} 
\textbf{\texttt{selection}} (\emph{\texttt{slice or list, i.e., a selection that numpy understands}}) -- This may be a python slice or a list of indecies to be read. Default value is to
read all (i.e., slice(None,None,None))

\end{itemize}

\item[{Returns}] \leavevmode
1D numpy array of intensity values read from the file.

\end{description}\end{quote}

\end{fulllineitems}

\index{s\_read\_spotlist() (omsi.dataformat.bruckerflex\_file.bruckerflex\_file static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.bruckerflex_file.bruckerflex_file.s_read_spotlist}\pysiglinewithargsret{\strong{static }\bfcode{s\_read\_spotlist}}{\emph{spotlist\_filename}}{}
Parse the given spotlist file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{spotlist\_filename}} (\emph{\texttt{string}}) -- Name of the textfile with the spotlist

\item[{Returns}] \leavevmode
\begin{description}
\item[{The function returns a number of different items in from of a python dictionary.}] \leavevmode
Most data is stored as 2D spatial maps, indicting for each (x,y) location the corresponding data.
Most data is stored as 2D masked numpy arrays. The masked of the array indicated whether data
has been recorded for a given pixel or not. The dict contains the following keys:

\end{description}
\begin{itemize}
\item {} 
`spotfolder' : String indicating the folder where all the spot-data is located

\item {} 
`fid' : 2D numpy masked array of strings with fid file name for each (x,y) pixel (intensities).

\item {} 
`acqu' : 2D numpy masked array of strings with acqu file name for each (x,y) (metadata).

\item {} 
`regions' : 2D numpy masked array of integers with region index for each (x,y) pixel.

\item {} 
`xpos' : 2D numpy masked array of integers indicated for each pixel its x position.

\item {} 
`ypos' : 2D numpy masked array of integers indicated for each pixel its x position.

\item {} 
`spotname' : 2D masked numpy array of strings with spot name for each (x,y) pixel.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{s\_spot\_from\_dir() (omsi.dataformat.bruckerflex\_file.bruckerflex\_file static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.bruckerflex_file.bruckerflex_file.s_spot_from_dir}\pysiglinewithargsret{\strong{static }\bfcode{s\_spot\_from\_dir}}{\emph{in\_dir}, \emph{spot\_folder\_only=False}}{}
Similar to  s\_read\_spotlist but instead of using a spotlist file the structure of the data is parsed
directly from the structure of the direcory containint all spots.
\begin{quote}
\begin{quote}\begin{description}
\item[{param in\_dir}] \leavevmode
Name of the directory with all spots

\item[{type in\_dir}] \leavevmode
string

\item[{param spot\_folder\_only}] \leavevmode
If set to True, then the function only constructs the spot folders but
does not check for acqu files etc. If set to True, only the spotfolder
list will be returned.

\item[{returns}] \leavevmode\begin{description}
\item[{The function returns None in case that no valid spots were found. Returns a list of strings}] \leavevmode
with the spotfolders if spot\_folder\_only is set to True. Otherwise, the function returns a
number of different items in from of a python dictionary. Most data is stored as 2D spatial
maps, indicting for each (x,y) location the corresponding data. Most data is stored as 2D
masked numpy arrays. The masked of the array indicated whether data has been recorded for
a given pixel or not. The dict contains the following keys:

\end{description}
\begin{itemize}
\item {} 
`spotfolder' : String indicating the folder where all the spot-data is located

\item {} 
`fid' : 2D numpy masked array of strings with fid file name for each (x,y) pixel (intensities)

\item {} 
`acqu' : 2D numpy masked array of strings with acqu file name  for each (x,y) pixel (metadata)

\item {} 
`regions' : 2D numpy masked array of integers with the index of the region for each (x,y) pixel.

\item {} 
`xpos' : 2D numpy masked array of integers indicated for each pixel its x position.

\item {} 
`ypos' : 2D numpy masked array of integers indicated for each pixel its x position.

\item {} 
`spotname' : 2D masked numpy array of strings with the name of the spot corresponding to a pixel.

\end{itemize}

\end{description}\end{quote}
\end{quote}

\end{fulllineitems}

\index{set\_region\_selection() (omsi.dataformat.bruckerflex\_file.bruckerflex\_file method)}

\begin{fulllineitems}
\phantomsection\label{omsi.dataformat:omsi.dataformat.bruckerflex_file.bruckerflex_file.set_region_selection}\pysiglinewithargsret{\bfcode{set\_region\_selection}}{\emph{region\_index=None}}{}
Define which region should be selected for local data reads.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{region\_index}} -- The index of the region that should be read. The shape of the
data will be adjusted accordingly. Set to None to select all regions and treat
the data as a single full 3D image.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{datastructures Package}
\label{omsi.datastructures::doc}\label{omsi.datastructures:datastructures-package}
\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


{\hyperref[omsi.datastructures:module\string-omsi.datastructures]{\emph{\code{omsi.datastructures}}}}
 & 
Package with a collection of various data structures and related classes used throughout the software stack, e.g., for metadata, analysis parameter data, runtime information data etc.
\\
\hline
{\hyperref[omsi.datastructures.metadata:module\string-omsi.datastructures.metadata]{\emph{\code{omsi.datastructures.metadata}}}}
 & 
Package with metadata datastructures
\\
\hline
{\hyperref[omsi.datastructures.metadata:module\string-omsi.datastructures.metadata.metadata_data]{\emph{\code{omsi.datastructures.metadata.metadata\_data}}}}
 & 
Define infrastructure for describing metadata (in memory)
\\
\hline
{\hyperref[omsi.datastructures.metadata:module\string-omsi.datastructures.metadata.metadata_ontologies]{\emph{\code{omsi.datastructures.metadata.metadata\_ontologies}}}}
 & 
Define ontologies for metadata
\\
\hline
{\hyperref[omsi.datastructures:module\string-omsi.datastructures.analysis_data]{\emph{\code{omsi.datastructures.analysis\_data}}}}
 & 
Helper module with data structures for managing analysis-related data.
\\
\hline
{\hyperref[omsi.datastructures:module\string-omsi.datastructures.dependency_data]{\emph{\code{omsi.datastructures.dependency\_data}}}}
 & 
Define a dependency to another omsi object
\\
\hline
{\hyperref[omsi.datastructures:module\string-omsi.datastructures.run_info_data]{\emph{\code{omsi.datastructures.run\_info\_data}}}}
 & 
Module with helper data structures for recording runtime provenance data
\\
\hline\end{longtable}



\subsubsection{\texttt{datastructures} Package}
\label{omsi.datastructures:id1}\phantomsection\label{omsi.datastructures:module-omsi.datastructures}\index{omsi.datastructures (module)}
Package with a collection of various data structures and related classes used throughout the software stack,
e.g., for metadata, analysis parameter data, runtime information data etc.


\subsubsection{\texttt{analysis\_data} Module}
\label{omsi.datastructures:analysis-data-module}\label{omsi.datastructures:module-omsi.datastructures.analysis_data}\index{omsi.datastructures.analysis\_data (module)}
Helper module with data structures for managing analysis-related data.
\index{analysis\_data (class in omsi.datastructures.analysis\_data)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.analysis_data}\pysiglinewithargsret{\strong{class }\code{omsi.datastructures.analysis\_data.}\bfcode{analysis\_data}}{\emph{name='undefined'}, \emph{data=None}, \emph{dtype='float32'}}{}
Bases: \code{dict}

Define an output dataset for the analysis that should be written to the omsi HDF5 file

The class can be used like a dictionary but restricts the set of keys that can be used
to the following required keys which should be provided during initalization.

\textbf{Required Keyword Arguments}:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- The name for the dataset in the HDF5 format

\item {} 
\textbf{\texttt{data}} -- The numpy array to be written to HDF5. The data write function
omsi\_file\_experiment.create\_analysis used for writing of the data to file can
in principal also handel other primitive data types by explicitly converting them
to numpy. However, in this case the dtype is determined based on the numpy conversion
and correct behavior is not guaranteed. I.e., even single scalars should be stored as
a 1D numpy array here. Default value is None which is mapped to np.empty( shape=(0) , dtype=dtype)
in \_\_init\_\_

\item {} 
\textbf{\texttt{dtype}} -- 
The data type to be used during writing. For standard numpy data types this is just
the dtype  of the dataset, i.e., {[}'data'{]}.dtype. Other allowed datatypes are:
\begin{itemize}
\item {} 
For string:  omsi\_format.str\_type (omsi\_format is located in omsi.dataformat.omsi\_file )

\item {} 
To generate data links: ana\_hdf5link   (analysis\_data)

\end{itemize}


\end{itemize}

\end{description}\end{quote}
\index{ana\_hdf5link (omsi.datastructures.analysis\_data.analysis\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.analysis_data.ana_hdf5link}\pysigline{\bfcode{ana\_hdf5link}\strong{ = -1}}
Value used to indicate that a hard link to another dataset should be created when saving an analysis object

\end{fulllineitems}


\end{fulllineitems}

\index{data\_dtypes (class in omsi.datastructures.analysis\_data)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.data_dtypes}\pysigline{\strong{class }\code{omsi.datastructures.analysis\_data.}\bfcode{data\_dtypes}}
Bases: \code{dict}

Class specifying basic function for specifying common
data types used as part of an analysis.
\index{bool\_type() (omsi.datastructures.analysis\_data.data\_dtypes static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.data_dtypes.bool_type}\pysiglinewithargsret{\strong{static }\bfcode{bool\_type}}{\emph{argument}}{}
Implement conversion of boolean input parameters since
arparse (or bool, depending on the point of view), do not
handle bool as a type in an intuitive fashion.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{argument}} -- The argument to be parsed to a boolean

\item[{Returns}] \leavevmode
The converted value

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_dtypes() (omsi.datastructures.analysis\_data.data\_dtypes static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.data_dtypes.get_dtypes}\pysiglinewithargsret{\strong{static }\bfcode{get\_dtypes}}{}{}
Get a list of available data type specifications

\end{fulllineitems}

\index{ndarray() (omsi.datastructures.analysis\_data.data\_dtypes static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.data_dtypes.ndarray}\pysiglinewithargsret{\strong{static }\bfcode{ndarray}}{\emph{argument}}{}
This dtype may be used to indicate numpy ndarrays as
well as h5py arrays or omsi\_dependencies
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{argument}} -- The argument to be parsed to ndarray

\item[{Returns}] \leavevmode
The converted ndarray

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{parameter\_data (class in omsi.datastructures.analysis\_data)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_data}\pysiglinewithargsret{\strong{class }\code{omsi.datastructures.analysis\_data.}\bfcode{parameter\_data}}{\emph{name}, \emph{help='`}, \emph{dtype=None}, \emph{required=False}, \emph{default=None}, \emph{choices=None}, \emph{data=None}, \emph{group=None}}{}
Bases: \code{dict}

Define a single input parameter for an analysis.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
{\hyperref[omsi.datastructures:omsi.datastructures.analysis_data.parameter_data.default_keys]{\emph{\textbf{\texttt{default\_keys}}}}} -- List of allowed dictionary keys:

\end{description}\end{quote}

Required keys:
\begin{itemize}
\item {} 
\emph{name} : The name of the parameter

\item {} 
\emph{help} : Help string describing the parameter

\item {} 
\emph{type} : Optional type. Default is None, indicating a dynamically typed dataset that the analysis will convert

\item {} 
\emph{required} : Boolean indicating whether the parameter is required (True) or optional (False). Default False

\item {} 
\emph{default} : Optional default value for the parameter. Default None.

\item {} 
\emph{choices} : Optional list of choices with allowed data values. Default None, indicating no choices set.

\item {} 
\emph{data} : The data assigned to the parameter. None by default.

\item {} 
`group' : Optional group string used to organize parameters. This may also be a dict of                    \{`name':\textless{}group\textgreater{}, `description':\textless{}description\textgreater{}\}

\end{itemize}

In the context of the argparse package the default keys have the following mapping:
\begin{itemize}
\item {} 
\emph{argparse.name} = \emph{name}

\item {} 
\emph{argparse.action} --\textgreater{} The action is constant and set to save value

\item {} 
\emph{argparse.nargs}  --\textgreater{} Left as default

\item {} 
{\color{red}\bfseries{}{}`}argparse.const   --\textgreater{} Not used as action is always save value

\item {} 
\emph{argparse.type} = \emph{type}

\item {} 
\emph{argparse.choices = {}`choices}

\item {} 
\emph{argparse.required = {}`required}

\item {} 
\emph{argparse.help = {}`help}

\item {} 
{\color{red}\bfseries{}{}`}argparse.metavar  --\textgreater{} Not used. Positional arguments are not allowed for analyses

\item {} 
\emph{argparse.destination --\textgreater{} Automatically determined by the {}`name} of the parameter

\item {} 
\emph{argparse.add\_argument\_group(...) --\textgreater{} Automatically determined based on the required parameter and            the {}`group} parameter if set.

\end{itemize}

Initialize a new parameter description.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- Required name for the parameter

\item {} 
\textbf{\texttt{help}} -- Required help string for the parameter

\item {} 
\textbf{\texttt{dtype}} -- Type argument. Default unicode.

\item {} 
\textbf{\texttt{required}} -- Boolean indicating whether the parameter is required (default=True)

\item {} 
\textbf{\texttt{default}} -- Optional default value for the parameter. Default None.

\item {} 
\textbf{\texttt{choices}} -- Optional list of choices with allowed data values. Default None, indicating no choices set.

\item {} 
\textbf{\texttt{data}} -- The data assigned to the parameter. None by default.

\item {} 
\textbf{\texttt{group}} -- The parameter group to be used. None by default.

\end{itemize}

\end{description}\end{quote}
\index{clear\_data() (omsi.datastructures.analysis\_data.parameter\_data method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_data.clear_data}\pysiglinewithargsret{\bfcode{clear\_data}}{}{}
Remove the currently assigned data.

\end{fulllineitems}

\index{copy() (omsi.datastructures.analysis\_data.parameter\_data method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_data.copy}\pysiglinewithargsret{\bfcode{copy}}{}{}
Return a new parameter\_data object with the same data as stored in the current object
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
dependency\_dict object

\end{description}\end{quote}

\end{fulllineitems}

\index{data\_ready() (omsi.datastructures.analysis\_data.parameter\_data method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_data.data_ready}\pysiglinewithargsret{\bfcode{data\_ready}}{}{}
This function check if the data points to a dependency and if so, then check if the dependency can be
resolved or not

\end{fulllineitems}

\index{data\_set() (omsi.datastructures.analysis\_data.parameter\_data method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_data.data_set}\pysiglinewithargsret{\bfcode{data\_set}}{}{}
Check if a data has been assigned for the parameter.

\end{fulllineitems}

\index{default\_keys (omsi.datastructures.analysis\_data.parameter\_data attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_data.default_keys}\pysigline{\bfcode{default\_keys}\strong{ = {[}'name', `default', `dtype', `choices', `required', `help', `data', `group'{]}}}
List of allowed keys for the parameter dict.

\end{fulllineitems}

\index{get\_data\_or\_default() (omsi.datastructures.analysis\_data.parameter\_data method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_data.get_data_or_default}\pysiglinewithargsret{\bfcode{get\_data\_or\_default}}{}{}
Get the data of the parameter if set, otherwise get the default value if available.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The data to be used for the parameter.

\item[{Raises}] \leavevmode
KeyError is raised in case that neither `default' nor `data' are available.
This should never be the case if the object was created properly.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_group\_description() (omsi.datastructures.analysis\_data.parameter\_data method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_data.get_group_description}\pysiglinewithargsret{\bfcode{get\_group\_description}}{}{}
Get the description for the group if available.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
String with the group description or None.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_group\_name() (omsi.datastructures.analysis\_data.parameter\_data method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_data.get_group_name}\pysiglinewithargsret{\bfcode{get\_group\_name}}{}{}
Get the name of the group to be used.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
String with the name of the group of None if not set

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_dependency() (omsi.datastructures.analysis\_data.parameter\_data method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_data.is_dependency}\pysiglinewithargsret{\bfcode{is\_dependency}}{}{}
Check whether the parameter defines a dependency.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Boolean indicating whether the parameter defines a dependency.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{parameter\_manager (class in omsi.datastructures.analysis\_data)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_manager}\pysigline{\strong{class }\code{omsi.datastructures.analysis\_data.}\bfcode{parameter\_manager}}
Bases: \code{object}

Base class for objects that manage their own parameters.

Parameters are set and their values retrieved by name using dict-like slicing. Derived classes
may overwrite \_\_getitem\_\_ and \_\_setitem\_\_ to implement their own behavior but
we exepct that the functionality of the interface is preserved, i.e., others should
still be able set parameter value and retrieve values via dict slicing.
\index{add\_parameter() (omsi.datastructures.analysis\_data.parameter\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_manager.add_parameter}\pysiglinewithargsret{\bfcode{add\_parameter}}{\emph{name}, \emph{help}, \emph{dtype=\textless{}type `unicode'\textgreater{}}, \emph{required=False}, \emph{default=None}, \emph{choices=None}, \emph{data=None}, \emph{group=None}}{}
Add a new parameter for the analysis. This function is typically used in the constructor
of a derived analysis to specify the parameters of the analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- The name of the parameter

\item {} 
\textbf{\texttt{help}} -- Help string describing the parameter

\item {} 
\textbf{\texttt{dtype}} -- Optional type. Default is string.

\item {} 
\textbf{\texttt{required}} -- Boolean indicating whether the parameter is required (True) or optional (False). Default False.

\item {} 
\textbf{\texttt{default}} -- Optional default value for the parameter. Default None.

\item {} 
\textbf{\texttt{choices}} -- Optional list of choices with allowed data values. Default None, indicating no choices set.

\item {} 
\textbf{\texttt{data}} -- The data assigned to the parameter. None by default.

\item {} 
\textbf{\texttt{group}} -- Optional group string used to organize parameters. Default None, indicating that
parameters are automatically organized by driver class (e.g. in required and optional parameters)

\end{itemize}

\item[{Raises}] \leavevmode
ValueError is raised if the parameter with the given name already exists.

\end{description}\end{quote}

\end{fulllineitems}

\index{clear\_parameter\_data() (omsi.datastructures.analysis\_data.parameter\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_manager.clear_parameter_data}\pysiglinewithargsret{\bfcode{clear\_parameter\_data}}{}{}
Clear the list of parameter data

\end{fulllineitems}

\index{define\_missing\_parameters() (omsi.datastructures.analysis\_data.parameter\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_manager.define_missing_parameters}\pysiglinewithargsret{\bfcode{define\_missing\_parameters}}{}{}
Set any required parameters that have not been defined to their respective default values.

This function may be overwritten in child classes to customize
the definition of default parameter values and to apply any
modifications (or checks) of parameters before the analysis is executed.
Any changes applied here will be recorded in the parameter of the analysis.

\end{fulllineitems}

\index{get\_all\_dependency\_data() (omsi.datastructures.analysis\_data.parameter\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_manager.get_all_dependency_data}\pysiglinewithargsret{\bfcode{get\_all\_dependency\_data}}{}{}
Get the complete list of all direct dependencies to be written to the HDF5 file

NOTE: These are only the direct dependencies as specified by the analysis itself.
Use  get\_all\_dependency\_data\_recursive(..) to also get the indirect dependencies of
the analysis due to dependencies of the dependencies themselves.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of parameter\_data objects that define dependencies.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_parameter\_data() (omsi.datastructures.analysis\_data.parameter\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_manager.get_all_parameter_data}\pysiglinewithargsret{\bfcode{get\_all\_parameter\_data}}{\emph{exclude\_dependencies=False}}{}
Get the complete list of all parameter datasets to be written to the HDF5 file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{exclude\_dependencies}} -- Boolean indicating whether we should exclude parameters
that define dependencies from the list

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_num\_dependency\_data() (omsi.datastructures.analysis\_data.parameter\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_manager.get_num_dependency_data}\pysiglinewithargsret{\bfcode{get\_num\_dependency\_data}}{}{}
Return the number of dependencies defined as part of the parameters

\end{fulllineitems}

\index{get\_num\_parameter\_data() (omsi.datastructures.analysis\_data.parameter\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_manager.get_num_parameter_data}\pysiglinewithargsret{\bfcode{get\_num\_parameter\_data}}{}{}
Return the number of parameter datasets to be wirtten to the HDF5 file

\end{fulllineitems}

\index{get\_parameter\_data() (omsi.datastructures.analysis\_data.parameter\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_manager.get_parameter_data}\pysiglinewithargsret{\bfcode{get\_parameter\_data}}{\emph{index}}{}
Given the index return the associated dataset to be written to the HDF5 file
\begin{description}
\item[{:param index}] \leavevmode{[}Return the index entry of the private member parameters. If a{]}
string is given, then get\_parameter\_data\_by\_name(...) will be used instead.

\end{description}
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
IndexError is raised when the index is out of bounds

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_parameter\_data\_by\_name() (omsi.datastructures.analysis\_data.parameter\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_manager.get_parameter_data_by_name}\pysiglinewithargsret{\bfcode{get\_parameter\_data\_by\_name}}{\emph{dataname}}{}
Given the key name of the data return the associated parameter\_data object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{dataname}} -- Name of the parameter requested from the parameters member.

\item[{Returns}] \leavevmode
The parameter\_data object or None if not found

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_parameter\_names() (omsi.datastructures.analysis\_data.parameter\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_manager.get_parameter_names}\pysiglinewithargsret{\bfcode{get\_parameter\_names}}{}{}
Get a list of all parameter dataset names (including those that may define
dependencies.

\end{fulllineitems}

\index{keys() (omsi.datastructures.analysis\_data.parameter\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_manager.keys}\pysiglinewithargsret{\bfcode{keys}}{}{}
Get a list of all valid keys, i.e., a list of all parameter names.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of strings with all input parameter and output names.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_parameter\_default\_value() (omsi.datastructures.analysis\_data.parameter\_manager method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.analysis_data.parameter_manager.set_parameter_default_value}\pysiglinewithargsret{\bfcode{set\_parameter\_default\_value}}{\emph{name}, \emph{value}}{}
Set the default value of the parameter with the given name
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- Name of the parameter

\item {} 
\textbf{\texttt{value}} -- New value

\end{itemize}

\item[{Raises}] \leavevmode
KeyError if parameter not found

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{\texttt{dependency\_data} Module}
\label{omsi.datastructures:module-omsi.datastructures.dependency_data}\label{omsi.datastructures:dependency-data-module}\index{omsi.datastructures.dependency\_data (module)}
Define a dependency to another omsi object
\index{dependency\_dict (class in omsi.datastructures.dependency\_data)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.dependency_data.dependency_dict}\pysiglinewithargsret{\strong{class }\code{omsi.datastructures.dependency\_data.}\bfcode{dependency\_dict}}{\emph{param\_name=None}, \emph{link\_name=None}, \emph{omsi\_object=None}, \emph{selection=None}, \emph{dataname=None}, \emph{help=None}, \emph{dependency\_type=None}}{}
Bases: \code{dict}

Define a dependency to another omsi file-based data object or in-memory analysis\_base object

\textbf{Required Keyword Arguments}:
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{param\_name}} -- The name of the parameter that has the depency

\item {} 
\textbf{\texttt{link\_name}} -- The name of for the link to be created in the HDF5 file.

\item {} 
\textbf{\texttt{omsi\_object}} -- The object to which a link should be established to. This
must be either an h5py.Dataset or the omsi\_file\_analysis or omsi\_file\_msidata
or any of the other omsi\_file API  interface ojects.

\item {} 
\textbf{\texttt{selection}} -- Optional string type parameter indicating a python selection for the dependency

\item {} 
\textbf{\texttt{dataname}} -- String indicating the dataset within the omsi\_object. If the omsi\_object
is an h5py object within a managed Group, then the omsi\_object is automatically split
up into the parent object and dataname.

\item {} 
\textbf{\texttt{\_data}} -- Private key used to store the data associated with the dependency object.

\end{itemize}

\end{description}\end{quote}

\textbf{Optional Keyword arguments}:
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{dependency\_type}} -- The type of the dependency being modeled. If not defined then
the default value of `parameter' is assumed.

\end{description}\end{quote}

Initialize the allowed set of keys.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{param\_name}} -- The name of the parameter that has the dependency

\item {} 
\textbf{\texttt{link\_name}} -- The name of for the link to be created in the HDF5 file.

\item {} 
\textbf{\texttt{omsi\_object}} -- The object to which a link should be established to. This
must be either an h5py.Dataset or the omsi\_file\_analysis or omsi\_file\_msidata
or any of the other omsi\_file API  interface objects.

\item {} 
\textbf{\texttt{selection}} -- Optional string type parameter indicating a python selection for the dependency

\item {} 
\textbf{\texttt{dataname}} -- String indicating the dataset within the omsi\_object. If the omsi\_object
is an h5py object within a managed Group, then the omsi\_object is automatically split
up into the parent object and dataname.

\item {} 
\textbf{\texttt{help}} -- Optional string describing the object

\end{itemize}

\end{description}\end{quote}
\index{copy() (omsi.datastructures.dependency\_data.dependency\_dict method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.dependency_data.dependency_dict.copy}\pysiglinewithargsret{\bfcode{copy}}{}{}
Return a new dependency\_dict object with the same data as stored in the current object
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
dependency\_dict object

\end{description}\end{quote}

\end{fulllineitems}

\index{dependency\_types (omsi.datastructures.dependency\_data.dependency\_dict attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.dependency_data.dependency_dict.dependency_types}\pysigline{\bfcode{dependency\_types}\strong{ = \{`subset': `subset', `undefined': None, `contains': `contains', `link': `link', `parameter': `parameter', `co\_modality': `co\_modality'\}}}
\end{fulllineitems}

\index{get\_data() (omsi.datastructures.dependency\_data.dependency\_dict method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.dependency_data.dependency_dict.get_data}\pysiglinewithargsret{\bfcode{get\_data}}{}{}
Get the data associated with the dependency.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
If a selection is applied and the dependency object supports
array data load (e.g., h5py.Dataset, omsi\_file\_msidata), then
the selected data will be loaded and returned as numpy array.
Otherwise the {[}'omsi\_object'{]} is returned.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{\texttt{run\_info\_data} Module}
\label{omsi.datastructures:module-omsi.datastructures.run_info_data}\label{omsi.datastructures:run-info-data-module}\index{omsi.datastructures.run\_info\_data (module)}
Module with helper data structures for recording runtime provenance data
\index{run\_info\_dict (class in omsi.datastructures.run\_info\_data)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.run_info_data.run_info_dict}\pysiglinewithargsret{\strong{class }\code{omsi.datastructures.run\_info\_data.}\bfcode{run\_info\_dict}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{dict}

Simple dictionary class for collecting runtime information

The typical use is as follows:

\textgreater{}\textgreater{} my\_run\_info = run\_info\_dict()
\textgreater{}\textgreater{} my\_run\_info(my\_function)(my\_parameters)

With this, all runtime information is automatically collected in my\_run\_info.
We can enable time-and-usage and memory profiling simply by calling
enable\_profile\_time\_and\_usage(...) or  enable\_profile\_memory(...), respectively,
before we run our function.

We can also use the data structure directly and control the population ourselves,
however, memory profiling is not supported by default in this case but we need to
set and run the memory profiler ourselves, since memory\_profiler expects that it
can wrap the function
\index{DEFAULT\_TIME\_FORMAT (omsi.datastructures.run\_info\_data.run\_info\_dict attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.run_info_data.run_info_dict.DEFAULT_TIME_FORMAT}\pysigline{\bfcode{DEFAULT\_TIME\_FORMAT}\strong{ = `\%Y-\%m-\%d \%H:\%M:\%S.\%f'}}
\end{fulllineitems}

\index{clean\_up() (omsi.datastructures.run\_info\_data.run\_info\_dict method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.run_info_data.run_info_dict.clean_up}\pysiglinewithargsret{\bfcode{clean\_up}}{}{}
Clean up the runinfo object. In particular remove empty keys that
either recorded None or recorded just an empty string.

This function may be overwritten to also do clean-up needed
due to additional custom runtime instrumentation.

When overwriting this function we should call super(..., self).runinfo\_clean\_up()
at the end of the function to ensure that the runinfo dictionary
is clean, i.e., does not contain any empty entries.

\end{fulllineitems}

\index{clear() (omsi.datastructures.run\_info\_data.run\_info\_dict method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.run_info_data.run_info_dict.clear}\pysiglinewithargsret{\bfcode{clear}}{}{}
Clear the dictionary and other internal parameters

Side Effects
\begin{itemize}
\item {} 
Remove all key/value pairs from the dict

\item {} 
Set self.\_\_time\_and\_use\_profiler to None

\item {} 
Set self.\_\_memory\_profiler to None

\item {} 
Set self.\_\_profile\_memory to False if invalid (i.e, if set to True but memory profiling is unavailable)

\item {} 
Set self.\_\_profile\_time\_and\_usage to False if invalid (i.e., if set to True but profiling is unavailable)

\end{itemize}

\end{fulllineitems}

\index{enable\_profile\_memory() (omsi.datastructures.run\_info\_data.run\_info\_dict method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.run_info_data.run_info_dict.enable_profile_memory}\pysiglinewithargsret{\bfcode{enable\_profile\_memory}}{\emph{enable=True}}{}
Enable/disable profiling of memory usage
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{enable}} -- boolean to enable (True) or disable (False) memory profiling

\end{description}\end{quote}

\end{fulllineitems}

\index{enable\_profile\_time\_and\_usage() (omsi.datastructures.run\_info\_data.run\_info\_dict method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.run_info_data.run_info_dict.enable_profile_time_and_usage}\pysiglinewithargsret{\bfcode{enable\_profile\_time\_and\_usage}}{\emph{enable=True}}{}
Enable/disable time and usage profiling
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{enable}} -- boolean to enable (True) or disable (False) time and usage profiling

\end{description}\end{quote}

\end{fulllineitems}

\index{gather() (omsi.datastructures.run\_info\_data.run\_info\_dict method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.run_info_data.run_info_dict.gather}\pysiglinewithargsret{\bfcode{gather}}{}{}
Simple helper function to gather the runtime information---that has been collected on
multiple processes when running using MPI---on a single root process
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
If we have more than one processes then this function returns a
dictionary with the same keys as usual for the run\_info but the
values are now lists with one entry per mpi processes. If we only have
a single process, then the run\_info object will be returned without
changes. NOTE: Similar to mpi gather, the function only collects
information on the root. All other processes will return just their
own private runtime information.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_profile\_memory() (omsi.datastructures.run\_info\_data.run\_info\_dict method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.run_info_data.run_info_dict.get_profile_memory}\pysiglinewithargsret{\bfcode{get\_profile\_memory}}{}{}
Check whether profiling of memory usage is enabled
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Boolean indicating whether memory profiling is enabled

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_profile\_stats\_object() (omsi.datastructures.run\_info\_data.run\_info\_dict method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.run_info_data.run_info_dict.get_profile_stats_object}\pysiglinewithargsret{\bfcode{get\_profile\_stats\_object}}{\emph{consolidate=True}, \emph{stream=None}}{}
Based on the execution profile of the execute\_analysis(..) function get
\code{pstats.Stats} object to help with the interpretation of the data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{consolidate}} -- Boolean flag indicating whether multiple stats (e.g., from multiple cores)
should be consolidated into a single stats object. Default is True.

\item {} 
\textbf{\texttt{stream}} -- The optional stream parameter to be used fo the pstats.Stats object.

\end{itemize}

\item[{Returns}] \leavevmode
A single pstats.Stats object if consolidate is True. Otherwise the function
returns a list of pstats.Stats objects, one per recorded statistic. None is returned
in case that the stats objects cannot be created or no profiling data is available.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_profile\_time\_and\_usage() (omsi.datastructures.run\_info\_data.run\_info\_dict method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.run_info_data.run_info_dict.get_profile_time_and_usage}\pysiglinewithargsret{\bfcode{get\_profile\_time\_and\_usage}}{}{}
Check whether time and usage profiling is enabled
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Boolean indicating whether time and usage profiling is enabled

\end{description}\end{quote}

\end{fulllineitems}

\index{record\_postexecute() (omsi.datastructures.run\_info\_data.run\_info\_dict method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.run_info_data.run_info_dict.record_postexecute}\pysiglinewithargsret{\bfcode{record\_postexecute}}{\emph{execution\_time=None}}{}
Function used to record runtime information after the task we want to track is comleted, e.g.
the \emph{execute\_analysis(...)} function of a standard analysis.

The function may be overwritten in child classes to add recording of
additional runtime information.

When overwriting the function we should call super(...,self).runinfo\_record\_postexecute(execution\_time)
in the custom version to ensure that the execution and end\_time are properly
recorded.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{execution\_time}} -- The total time it took to execute the analysis. May be None, in which
case the function will attempt to compute the execution time based on the start\_time
(if available) and the the current time.

\item {} 
\textbf{\texttt{comm}} -- Used for logging only. The MPI communicator to be used. Default value is None,
in which case MPI.COMM\_WORLD is used.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{record\_preexecute() (omsi.datastructures.run\_info\_data.run\_info\_dict method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.run_info_data.run_info_dict.record_preexecute}\pysiglinewithargsret{\bfcode{record\_preexecute}}{}{}
Record basic runtime information in this dict before the exeuction is started.

Function used to record runtime information prior to executing the process we want to track, e.g.,
the \emph{execute\_analysis(...)} of a standard analysis.

The function may be overwritten in child classes to add recording of
additional runtime information. All runtime data should be recorded in the
main dict (i.e, self). This ensures in the case of standard analysis that
the data is stored in the HDF5 file. Other data should be stored in separate
variables that we may add to the object.

When overwriting the function we should typically call super(...,self).runinfo\_record\_pretexecute()
last in the custom version to ensure that the start\_time is properly recorded right before
the execution of the analysis.

\end{fulllineitems}

\index{string\_to\_structime() (omsi.datastructures.run\_info\_data.run\_info\_dict static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.run_info_data.run_info_dict.string_to_structime}\pysiglinewithargsret{\strong{static }\bfcode{string\_to\_structime}}{\emph{time\_string}, \emph{time\_format=None}}{}
Covert a time string to a time.struct\_time using time.strptime
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{time\_string}} -- String with the time, e.g, with the start time of a program.

\item {} 
\textbf{\texttt{time\_format}} -- The time format to be used or None in which case run\_info\_dict.DEFAULT\_TIME\_FORMAT
will be used.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{string\_to\_time() (omsi.datastructures.run\_info\_data.run\_info\_dict static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures:omsi.datastructures.run_info_data.run_info_dict.string_to_time}\pysiglinewithargsret{\strong{static }\bfcode{string\_to\_time}}{\emph{time\_string}, \emph{time\_format=None}}{}
Convert a time string to local time object using time.mktime.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{time\_string}} -- String with the time, e.g, with the start time of a program.

\item {} 
\textbf{\texttt{time\_format}} -- The time format to be used or None in which case run\_info\_dict.DEFAULT\_TIME\_FORMAT
will be used.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Subpackages}
\label{omsi.datastructures:subpackages}

\paragraph{metadata Package}
\label{omsi.datastructures.metadata:metadata-package}\label{omsi.datastructures.metadata::doc}

\subparagraph{\texttt{metadata} Package}
\label{omsi.datastructures.metadata:id1}\phantomsection\label{omsi.datastructures.metadata:module-omsi.datastructures.metadata}\index{omsi.datastructures.metadata (module)}
Package with metadata datastructures


\subparagraph{\texttt{metadata\_data} Module}
\label{omsi.datastructures.metadata:module-omsi.datastructures.metadata.metadata_data}\label{omsi.datastructures.metadata:metadata-data-module}\index{omsi.datastructures.metadata.metadata\_data (module)}
Define infrastructure for describing metadata (in memory)
\index{metadata\_dict (class in omsi.datastructures.metadata.metadata\_data)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures.metadata:omsi.datastructures.metadata.metadata_data.metadata_dict}\pysigline{\strong{class }\code{omsi.datastructures.metadata.metadata\_data.}\bfcode{metadata\_dict}}
Bases: \code{dict}

Dictionary's for storing metadata information. The values in the dict must be
of type omsi\_metadata\_value and the keys must be strings.
\index{get\_metadata\_descriptions() (omsi.datastructures.metadata.metadata\_data.metadata\_dict method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures.metadata:omsi.datastructures.metadata.metadata_data.metadata_dict.get_metadata_descriptions}\pysiglinewithargsret{\bfcode{get\_metadata\_descriptions}}{}{}
Get a list of all metadata descriptions

\end{fulllineitems}

\index{get\_metadata\_units() (omsi.datastructures.metadata.metadata\_data.metadata\_dict method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures.metadata:omsi.datastructures.metadata.metadata_data.metadata_dict.get_metadata_units}\pysiglinewithargsret{\bfcode{get\_metadata\_units}}{}{}
Get a list of all metadata units

\end{fulllineitems}

\index{get\_metadata\_values() (omsi.datastructures.metadata.metadata\_data.metadata\_dict method)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures.metadata:omsi.datastructures.metadata.metadata_data.metadata_dict.get_metadata_values}\pysiglinewithargsret{\bfcode{get\_metadata\_values}}{}{}
Get a list of all metadata values.

\end{fulllineitems}


\end{fulllineitems}

\index{metadata\_value (class in omsi.datastructures.metadata.metadata\_data)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures.metadata:omsi.datastructures.metadata.metadata_data.metadata_value}\pysiglinewithargsret{\strong{class }\code{omsi.datastructures.metadata.metadata\_data.}\bfcode{metadata\_value}}{\emph{name}, \emph{value}, \emph{description}, \emph{unit=None}, \emph{ontology=None}}{}
Bases: \code{dict}

A single metadata value
\begin{itemize}
\item {} 
\emph{name} The name of the metadata value

\item {} 
\emph{value} The actual value associated with the metadata object

\item {} 
\emph{description} The text description of the metadata object

\item {} 
\emph{unit} The unit string

\item {} 
\emph{ontology} Optional ontology

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- The name of the metadata value. Name may be None if the metadata\_value
is added to a metadata\_dict as it will be set (if missing) when adding it to the
metadata\_dict

\item {} 
\textbf{\texttt{value}} -- The actual value associated with the metadata object

\item {} 
\textbf{\texttt{description}} -- The text description of the metadata object

\item {} 
\textbf{\texttt{unit}} -- The unit string

\item {} 
\textbf{\texttt{ontology}} -- Optional ontology

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{\texttt{metadata\_ontologies} Module}
\label{omsi.datastructures.metadata:module-omsi.datastructures.metadata.metadata_ontologies}\label{omsi.datastructures.metadata:metadata-ontologies-module}\index{omsi.datastructures.metadata.metadata\_ontologies (module)}
Define ontologies for metadata
\begin{quote}\begin{description}
\item[{var METADATA\_ONTOLOGIES}] \leavevmode\begin{description}
\item[{Description of simple ontologies for metadata. This is a dict where the}] \leavevmode
values are the descriptions of the ontologies and the key is the commonly used name of the
variable associated with the ontology, however, in practice an ontology may be associated
with many different metadata values (the purpose of th ontology is to standardize the values
not the names of metadata variables). Available ontologies include:

\end{description}
\begin{itemize}
\item {} 
\emph{polarity} : Description of the polarity of the instrument

\item {} 
\emph{msn\_value\_of\_n} : Numeric level of mass spectrometry used (e.g., 1 for MS1 etc).

\end{itemize}

\end{description}\end{quote}

An ontology can be many things. In general an ontology is a mechanism to formally name and define the
types, properties, and interrelationships of entities. We here refer broadly to the concept of ontologies
as a means to standardize the names of things. To define an ontology we use simple dicts with the
following key/value entries:
\begin{itemize}
\item {} 
\emph{name}: The name of the ontology

\item {} 
\emph{value} : Python dict describing the actual ontology. Often this is simply a dict where the                 the keys are the allowed values and the value is the textual description of the                 meaning of that value. In many cases this may be a more complete description of                 an ontology.

\item {} 
\emph{unit} : The standard unit associated with the values (or None if not unit is available)

\item {} 
\emph{description} : Human-readable textual description of the ontology

\item {} 
\emph{version} : The version of the ontology used

\item {} 
`uri{}` : The Universal Remote Identifier (often a URL) associated with the ontology (or None)

\end{itemize}

Ontologies are stored in the OpenMSI data format as JSON attributes associated with the metadata, i.e.,
one main restriction is that ontologies should be JSON serializable (which in most cases should be a
problem).
\index{metadata\_ontologies (class in omsi.datastructures.metadata.metadata\_ontologies)}

\begin{fulllineitems}
\phantomsection\label{omsi.datastructures.metadata:omsi.datastructures.metadata.metadata_ontologies.metadata_ontologies}\pysigline{\strong{class }\code{omsi.datastructures.metadata.metadata\_ontologies.}\bfcode{metadata\_ontologies}}
Bases: \code{dict}

Helper class for interacting with ontologies

\end{fulllineitems}



\subsection{shared Package}
\label{omsi.shared::doc}\label{omsi.shared:shared-package}
\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


\code{omsi.shared}
 & 
Package used to implement shared functionality and helper functions.
\\
\hline
{\hyperref[omsi.shared:module\string-omsi.shared.data_selection]{\emph{\code{omsi.shared.data\_selection}}}}
 & 
Module for defining and processing data selections.
\\
\hline
{\hyperref[omsi.shared:module\string-omsi.shared.log]{\emph{\code{omsi.shared.log}}}}
 & 
Module providing functionality for logging based on the python logging module.
\\
\hline
{\hyperref[omsi.shared:module\string-omsi.shared.mpi_helper]{\emph{\code{omsi.shared.mpi\_helper}}}}
 & 
Module used to ease the use of MPI and distributed parallel implementations using MPI
\\
\hline
{\hyperref[omsi.shared:module\string-omsi.shared.omsi_web_helper]{\emph{\code{omsi.shared.omsi\_web\_helper}}}}
 & 
Module with helper functions for interactions with the OpenMSI web infrastructure, e.g.
\\
\hline
{\hyperref[omsi.shared:module\string-omsi.shared.spectrum_layout]{\emph{\code{omsi.shared.spectrum\_layout}}}}
 & 
This module provides capabilities for computing different layouts for spectra
\\
\hline
\code{omsi.shared.third\_party}
 & 
Package containing shared third-party code modules included here to reduce the need for external dependencies when only small parts of external code are used.
\\
\hline
\code{omsi.shared.thirs\_party.cloudpickle}
 & 

\\
\hline\end{longtable}



\subsubsection{\texttt{data\_selection} Module}
\label{omsi.shared:module-omsi.shared.data_selection}\label{omsi.shared:data-selection-module}\index{omsi.shared.data\_selection (module)}
Module for defining and processing data selections. This includes the definition of
selections using strings as well as transformation and reduction of data.
\begin{description}
\item[{TODO: We may want to expose some of the following numpy functions currently not yet}] \leavevmode\begin{quote}

supported through the transform and reduce data operations:
\end{quote}
\begin{itemize}
\item {} 
array2string

\item {} 
array\_equal

\item {} 
array\_equiv

\item {} 
array\_repr

\item {} 
array\_split

\item {} 
array\_str

\item {} 
asanyarray

\item {} 
asarray

\item {} 
asarray\_chkfinite

\item {} 
ascontiguousarray

\item {} 
asfarray

\item {} 
asfortranarray

\item {} 
asmatrix

\item {} 
asscalar

\item {} 
atleast\_1d

\item {} 
atleast\_2d

\item {} 
atleast\_3d

\item {} 
binary\_repr

\item {} 
convolve

\item {} 
conjugate

\item {} 
cross

\item {} 
dot

\item {} 
extract

\item {} 
fft.*

\item {} 
histogram, histogram2D, histogramdd

\item {} 
kron

\item {} 
linalg.*

\item {} 
swapaxes(a, axis1, axis2)

\item {} 
transpose

\end{itemize}

\end{description}

\#Simple data transformation and reduction example
from omsi.shared.omsi\_data\_selection import *
import numpy as np
import json
t = {[} \{`transformation':'threshold', `threshold':60\} , \{`reduction':'max', `axis':2\} {]}
tj = json.dumps(t)
tj
a = np.arange(125).reshape((5,5,5))
apro = transform\_and\_reduce\_data(data=a, operations=tj, http\_error=True)
apro

\#Another simple example
from omsi.shared.omsi\_data\_selection import *
import numpy as np
import json
a = np.arange(10)+5
print a
\# 1) substract minimum
\# 2) divide by the maximum value with the maximum value converted to float
\# NOTE: The conversion to float is to avoid division of integers, i.e.,
\#       5/10 = 0, whereas 5/float(10) = 0.5
\# NOTE: The specification of `x1':'data' can be omitted as this is the default.
\#       `x1':'data' simply explicitly specifies that the input data should be
\#       assigned to the first operand of the arithmetic operation.
t = {[}\{`transformation':'dualDataTransform' , `operation':'subtract', `x1':'data', `x2':{[}\{`reduction':'min'\}{]}\} ,
\begin{quote}
\begin{description}
\item[{\{`transformation':'dualDataTransform' , `operation':'divide'  , `x1':'data', `x2':{[}\{`reduction':'max'\} ,}] \leavevmode
\{`transformation':'astype', `dtype':'float'\} {]}\}{]}

\end{description}
\end{quote}

b = transform\_and\_reduce\_data(data=a, operations=t)
print b
t = {[}\{`transformation':'threshold' , `threshold':{[}\{`reduction':'median'\}{]}\}{]}
print t
c = transform\_and\_reduce\_data(data=a, operations=t)
print c

\#Construct a JSON description of a transformation/reduction
from omsi.shared.omsi\_data\_selection import *
\#Construct the different pieces of the transformation and reduction pipeline
\#1) Compute the maximum data value and convert it to float
\#1.1) Compute the maximum value
max\_value = construct\_reduce\_dict( reduction\_type='max' , axis=None)
\#1.2) Convert data to float
value\_as\_float = construct\_transform\_dict( trans\_type='astype' , dtype='float' )
\#1.3) Merge the two steps to compute the maximum data value as float
max\_value\_as\_float = construct\_transform\_reduce\_list( max\_value, value\_as\_float )
\#2) Normalize the data by dividing by the maximum value
divide\_by\_max\_value = construct\_transform\_dict( trans\_type='dualDataTransform',
\begin{quote}

operation='divide' , axes=None , x2=max\_value\_as\_float)
\end{quote}

\#3) Project along the last axis (i.e., the mz axis) to compute a maximum project image
max\_projection = construct\_reduce\_dict( reduction\_type='max' , axis=-1)
\#4) Merge the different steps and construct the json string
json\_string = transform\_reduce\_description\_to\_json( divide\_by\_max\_value , max\_projection )
\#Just copy the result of the following print statement as your JSON description
print json\_string
\index{check\_selection\_string() (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.check_selection_string}\pysiglinewithargsret{\code{omsi.shared.data\_selection.}\bfcode{check\_selection\_string}}{\emph{selection\_string}}{}
Check whether the given selection string is valid, and indicate which type of selection
the string defined. Checking the selection string is meant as a safeguard to prevent
attackers from being able to insert malicious code.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{selection\_string}} -- String given by the user with the desired selection

\item[{Returns}] \leavevmode

String indicating the type of selection as defined in selection\_type:
\begin{itemize}
\item {} 
`indexlist' : Selection of the form {[}1,2,3{]}

\item {} 
`all' : Selection of the form `:'

\item {} 
`range: Selection of the form `a:b'

\item {} 
`index: A single index selection, e.g., `1'

\item {} 
`invalid': An unsupported selection

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{construct\_reduce\_dict() (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.construct_reduce_dict}\pysiglinewithargsret{\code{omsi.shared.data\_selection.}\bfcode{construct\_reduce\_dict}}{\emph{reduction\_type}, \emph{**kwargs}}{}
Helper function used to construct reduction dictionary.

Required Keyword arguments:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{reduction\_type}} -- The reduction type to be used.

\end{description}\end{quote}

Optional Keyword arguments:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{axis}} -- Some reduction functions support the axis parameters,
describing along which axis the reduction should be performed.

\item {} 
\textbf{\texttt{x1}} -- By default the reductions are performed on the output of the
previous data operation (x1='data'). We may reference the output
of, e.g., the fifth data operation by setting x1='data5'. x1
itself may also specify a separate data transformation and
reduction pipeline that operates on `data'.

\item {} 
\textbf{\texttt{min\_dim}} -- Minimum number of dimensions the input data should have in
order for the reduction should be applied.

\end{itemize}

\item[{Returns}] \leavevmode
Dictionary with the description of the reduction operation.

\end{description}\end{quote}

\end{fulllineitems}

\index{construct\_transform\_dict() (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.construct_transform_dict}\pysiglinewithargsret{\code{omsi.shared.data\_selection.}\bfcode{construct\_transform\_dict}}{\emph{trans\_type}, \emph{axes=None}, \emph{**kwargs}}{}
Helper function used to construct a dictionary describing a data transformation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{trans\_type}} -- The transformation type to be used. See transformation\_type dict.

\item {} 
\textbf{\texttt{axes}} -- The axes along which the data should be split. Default is None.

\item {} 
\textbf{\texttt{kwargs}} -- Additional keyword parameters for the transformation functions.

\end{itemize}

\item[{Returns}] \leavevmode
Dictionary with the description of the transformation.

\item[{Raises}] \leavevmode
KeyError is raised in case that a parameter is missing.
ValueError is raised in case that a given parameter value
is invalid.

\end{description}\end{quote}

\end{fulllineitems}

\index{construct\_transform\_reduce\_list() (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.construct_transform_reduce_list}\pysiglinewithargsret{\code{omsi.shared.data\_selection.}\bfcode{construct\_transform\_reduce\_list}}{\emph{*args}}{}
Merge a series of transformations and reductions into a single
list describing a pipeline of transformation and reduction
operations to be performed.
\begin{quote}\begin{description}
\item[{Args}] \leavevmode
Ordered series of dictionaries describing transformation
and reduction operations.

\item[{Returns}] \leavevmode
List of all transformation and reduction operations

\end{description}\end{quote}

\end{fulllineitems}

\index{evaluate\_transform\_parameter() (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.evaluate_transform_parameter}\pysiglinewithargsret{\code{omsi.shared.data\_selection.}\bfcode{evaluate\_transform\_parameter}}{\emph{parameter}, \emph{data=None}, \emph{secondary\_data=None}}{}
Evaluate the given query parameter. This function is used to
enable the use of data transformation and reductions as part
of transformation parameters. E.g., a user may want to substract
the minimum, or divide by the maximum etc.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{parameter}} -- The parameter to be evaluated. This may be
a JSON string or list/dictionary-based description of a
data transformation. Or any other valid data parameter.
If the parameter describes as data reduction or transformation
then the transformation will be evaluated and the result
is returned, otherwise the parameter itself is returned.

\item {} 
\textbf{\texttt{data}} -- The input numpy array that should be transformed.

\item {} 
\textbf{\texttt{secondary\_data}} -- Other data from previous data iterations a user may reference.

\end{itemize}

\item[{Returns}] \leavevmode
The evaluated parameter result.

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_transform\_or\_reduce() (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.is_transform_or_reduce}\pysiglinewithargsret{\code{omsi.shared.data\_selection.}\bfcode{is\_transform\_or\_reduce}}{\emph{parameter}}{}
Check if the given parameter defines a description of a
data transformation or data reduction
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{parameter}} (\emph{\texttt{JSON string, dict or list of dicts with transformation parameter.}}) -- The parameter to be checked.

\item[{Returns}] \leavevmode
Boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{json\_to\_transform\_reduce\_description() (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.json_to_transform_reduce_description}\pysiglinewithargsret{\code{omsi.shared.data\_selection.}\bfcode{json\_to\_transform\_reduce\_description}}{\emph{json\_string}}{}
Convert the json string to the transformation/reduction dict.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{json\_string}} -- The json string to be converted.

\item[{Returns}] \leavevmode
Python list or dict with the description

\end{description}\end{quote}

\end{fulllineitems}

\index{perform\_reduction() (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.perform_reduction}\pysiglinewithargsret{\code{omsi.shared.data\_selection.}\bfcode{perform\_reduction}}{\emph{data}, \emph{reduction}, \emph{secondary\_data}, \emph{min\_dim=None}, \emph{http\_error=False}, \emph{**kwargs}}{}
Helper function used reduce the data of a given numpy array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} -- The input numpy array that should be reduced

\item {} 
\textbf{\texttt{reduction}} (\emph{\texttt{String}}) -- Data reduction to be applied to the input data.
Reduction operations are defined as strings indicating
the numpy function to be used for reduction. Valid
reduction operations include e.g.: mins, max, mean,
median, std, var etc.

\item {} 
\textbf{\texttt{axis}} -- The axis along which the reduction should be applied

\item {} 
\textbf{\texttt{secondary\_data}} -- Other data from previous data iterations a user may reference.

\item {} 
\textbf{\texttt{http\_error}} -- Define which type of error message the function should return.
If false then None is returned in case of error. Otherwise a DJANGO HttpResponse is returned.

\item {} 
\textbf{\texttt{min\_dim}} -- Minimum number of dimensions the input data must have in order for the reduction to be applied.

\item {} 
\textbf{\texttt{kwargs}} -- Additional optional keyword arguments.

\end{itemize}

\item[{Returns}] \leavevmode
Reduced numpy data array or in case of error None or HttpResonse with a
description of the error that occurred (see http\_error option).

\end{description}\end{quote}

\end{fulllineitems}

\index{reduction\_allowed\_numpy\_function (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.reduction_allowed_numpy_function}\pysigline{\code{omsi.shared.data\_selection.}\bfcode{reduction\_allowed\_numpy\_function}\strong{ = {[}'all', `alltrue', `amax', `amin', `angle', `any', `append', `argmax', `argmin', `argwhereaverage', `bincount', `corrcoef', `cumprod', `cumproduct', `cumsum', `count\_nonzero', `diag', `diag\_indices', `diagflat', `diagonal', `diff', `max', `min', `median', `mean', `percentile', `product', `prod', `ptp', `select\_values', `squeeze', `std', `var', `transpose', `sum'{]}}}
List of allowed numpy data reduction operations.
Reduction operations are any single data operations that
may change the shape of the data.
NOTE: Some operations may have additional optional or required keyword arguments.
HELP: For full documentation of the different functions see the numpy documentation.

Additional input parameters are often:
\begin{itemize}
\item {} \begin{description}
\item[{`x1'}] \leavevmode{[}The data operand specifying the data the reduction should be performed on. \textbackslash{}{]}
The input data will be used by default if x1 is not specified. You may also specify `data' to explicitly indicate that the input data should be assigned to x1. You may specify data0 to indicate that the output of another data operation should be used. Note, data0 here refers to the input to the full data operation pipeline. Data from other parts of the pipeline, are then indexed using 1-based indices. E.g,. to access the output of the first data operation set x1='data0'

\end{description}

\item {} \begin{description}
\item[{`axis'}] \leavevmode{[}Integer indicating the axis along which the data should be reduced. \textbackslash{}{]}
The default behavior, if axis is not specified, depends on the behavior of the corresponding numpy function. However, in most cases (if not all cases) the data operation will be applied to the full input data if no axis is specified.

\end{description}

\item {} \begin{description}
\item[{`min\_dim'}] \leavevmode{[}Integer specifying the minimum number of data dimensions the input data \textbackslash{}{]}
must have in order for the reduction operation to be applied.

\end{description}

\end{itemize}

Here the list of allowed data reduction operations.
\begin{quote}
\begin{itemize}
\item {} 
`all'       : out = numpy.all(data, axis)

\item {} 
`amax'      : out = numpy.amax(data, axis)

\item {} 
`amin'      : out = numpy.amin(data, axis)

\item {} 
`alltrue'   : out = numpy.alltrue(data, axis)

\item {} 
`angle'     : out = numpy.angle(z, deg)

\item {} 
`any'       : out = numpy.any(data, axis)

\item {} 
`append'    : out = numpy.append(data, values, axis)

\item {} 
`argmax'    : out = numpy.argmax(data, axis)

\item {} 
`argmin'    : out = numpy.argmin(data, axis)

\item {} 
`argwhere'  : out = numpy.argwhere(data)

\item {} 
`average'   : out = numpy.average(data, axis)

\item {} 
`bincount'  : out = numpy.bincount(x, weights=None, minlength=None)

\item {} 
`corrcoef'  : out = numpy.corrcoef(data)

\item {} 
`count\_nonzero' : out = numpy.count\_nonzero(data)

\item {} 
`cumprod'   : out = numpy.cumprod(data,axis)

\item {} 
`cumproduct': out = numpy.cumproduct(data,axis)

\item {} 
`cumsum'    : out = numpy.cumsum(data,axis)

\item {} 
`diag'      : out = numpy.diag(data,k=0)

\item {} 
`diag\_indices: out = numpu.diag\_indices(data, ndim=2)

\item {} 
`diagflat'  : out = numpy.diagflat(data, k=0)

\item {} 
`diagonal'  : out = numpy.diagonal(data, offset=0, axis1=0, axis2=1)

\item {} 
`diff'      : out = numpy.diff(a, n=1, axis=-1)

\item {} 
`max'       : out = numpy.max(data, axis)

\item {} 
`min'       : out = numpy.min(data, axis)

\item {} 
`median'    : out = numpy.median(data, axis)

\item {} 
`mean'      : out = numpy.mean(data, axis)

\item {} 
`percentile': out = numpy.percentile(data, q, axis)

\item {} 
`product'   : out = numpy.product(data, axis)

\item {} 
`prod'      : out = numpy.prod(data,axis)

\item {} 
`ptp'       : out = numpy.ptp(data,axis)

\item {} 
`squeeze'   : out = numpy.squeeze(data)

\item {} 
`std'       : out = numpy.std(data, axis)

\item {} 
`swapaxes: out = numpy.swapaxes(x1, axis1, axis2)

\item {} 
`var'       : out = numpy.var(data, axis)

\item {} 
`transpose' : out = numpy.transpose(data)

\item {} 
`sum'       : out = numpy.sum(data, axis)

\end{itemize}

None-numpy data reduction operations:
\begin{itemize}
\item {} 
`select\_values' : out = data{[} selection {]}

\end{itemize}
\end{quote}

\end{fulllineitems}

\index{selection\_string\_to\_object() (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.selection_string_to_object}\pysiglinewithargsret{\code{omsi.shared.data\_selection.}\bfcode{selection\_string\_to\_object}}{\emph{selection\_string}, \emph{list\_to\_index=False}}{}
Convert the given selection string to a python selection object, i.e., either a slice, list or integer index.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{selection\_string}} -- A selection string of the type indexlist

\item {} 
\textbf{\texttt{list\_to\_index}} -- Should we turn the list into an index if the list contains only a single value.
Default value is False, i.e., the list is not modified.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
An integer index if an index selection is specified

\item {} 
A python list of indices if a list specified in the string

\item {} 
A python slice object if a slice operation is specified by the string

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{selection\_to\_indexlist() (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.selection_to_indexlist}\pysiglinewithargsret{\code{omsi.shared.data\_selection.}\bfcode{selection\_to\_indexlist}}{\emph{selection\_string}, \emph{axis\_size=0}}{}
Parse the indexlist selection string and return a python list of indices
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{selection\_string}} -- A selection string of the type indexlist

\item {} 
\textbf{\texttt{axis\_size}} -- Size of the dimensions for which the selection is defined.
Only needed in case that a range selection is given. This should be
a list of sizes, in case that a multiaxis selection is given.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
A python list of point indices for the selection.

\item {} 
None in case the list is empty or in case an error occurred.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{selection\_to\_string() (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.selection_to_string}\pysiglinewithargsret{\code{omsi.shared.data\_selection.}\bfcode{selection\_to\_string}}{\emph{selection}}{}
Convert the given selection, which may be either an int, a list of ints, a slice object or
a tuple of the mentioned types which is used to define a selection along multiple axes.
:param selection: The selection to be converted to a string
:type selection: int, list, slice, or a tuple of int, list, slice objects
:return: The selection string

\end{fulllineitems}

\index{selection\_type (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.selection_type}\pysigline{\code{omsi.shared.data\_selection.}\bfcode{selection\_type}\strong{ = \{`index': 0, `all': 3, `indexlist': 2, `invalid': -1, `range': 4, `multiaxis': 5\}}}
This an extended list of types indicated by the check\_selection\_string function.
Indices \textless{}0 are assumed to be invalid selections.

\end{fulllineitems}

\index{transform\_and\_reduce\_data() (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.transform_and_reduce_data}\pysiglinewithargsret{\code{omsi.shared.data\_selection.}\bfcode{transform\_and\_reduce\_data}}{\emph{data}, \emph{operations}, \emph{secondary\_data=None}, \emph{http\_error=False}}{}
Helper function used to apply a series of potentially multiple
operations to a given numpy dataset. This function uses
the transform\_data\_single(...) function to apply each indicated
transformation to the data. This function uses the perform\_reduction function to
perform data reduction operations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} -- The input numpy array that should be transformed.

\item {} 
\textbf{\texttt{operations}} -- 
JSON string with list of dictionaries or a python
list of dictionaries. Each dict specifies a single data
transformation or data reduction. The operations are applied
in order, i.e., operations{[}0{]} is applied first, then operations{[}1{]}
and so on. The dicts must be structured according to one of
the following specifications:
\begin{itemize}
\item {} 
\emph{\{`transformation':\textless{}op\textgreater{}\}} : Single transformation applied to all data at once.

\item {} 
\emph{\{`transformation':\textless{}op\textgreater{}, `axes':{[}..{]}\}} : Apply a single transformation to                              data chunks defined by the axes parameter. The data is split into chunks along                              the dimensions defined by the axes parameter. E.g., if we have a 3D MSI dataset                              and we want to op ion images independently, then we need to set axes={[}2{]}.                              Accordingly,  if we want to op spectra individually, then we need to split                              the two image dimensions into chunks by setting axes={[}0,1{]}.

\item {} 
\emph{\{`reduction':\textless{}reduction\textgreater{}, `axis':int\}} : Define the reduction operations to be                              applied and the axis along which the data should be reduced. If reduction along                              all axis should be done then set axis ot None (in python) or null in JSON.

\end{itemize}


\item {} 
\textbf{\texttt{secondary\_data}} -- Other data from previous data iterations a user may reference.

\item {} 
\textbf{\texttt{http\_error}} -- Define which type of error message the function should return.
If false then None is returned in case of error. Otherwise a DJANGO HttpResponse is returned.

\end{itemize}

\item[{Returns}] \leavevmode
Reduced numpy data array or HttpResonse with a description of the error that occurred.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform\_data\_single() (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.transform_data_single}\pysiglinewithargsret{\code{omsi.shared.data\_selection.}\bfcode{transform\_data\_single}}{\emph{data}, \emph{transformation='minusMinDivideMax'}, \emph{axes=None}, \emph{secondary\_data=None}, \emph{http\_error=False}, \emph{transform\_kwargs=None}}{}
Helper function used to transform data of a numpy array. The function
potentially splits the array into independent chunks that are
normalized separately (depending on how the axes parameter is defined).
The actual data transformations are implemented by transform\_datachunk(...).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} -- The input numpy array that should be transformed.

\item {} 
\textbf{\texttt{transformation}} -- Data transformation option to be used. Available options are:
`minusMinDivideMax' ,...

\item {} 
\textbf{\texttt{axes}} -- List of data axis that should be split into chunks that are treated
independently during the transformation. By default transformation is
applied based on the full dataset (axes=None). E.g, if transformation
should be performed on a per image basis, then we need to split the
m/z dimension into individual chunks and set axes={[}2{]}. If we want
to transform spectra individually, then we need to split the two
image dimensions into chunks by setting axes={[}0,1{]}.

\item {} 
\textbf{\texttt{secondary\_data}} -- Other data from previous data iterations a user may reference.

\item {} 
\textbf{\texttt{http\_error}} -- Define which type of error message the function should return.
If false then None is returned in case of error. Otherwise a DJANGO HttpResponse is returned.

\item {} 
\textbf{\texttt{transform\_kwargs}} -- Dictionary of additional keyword arguments to be passed to the
transform\_datachunk(...) function.

\end{itemize}

\item[{Returns}] \leavevmode
Reduced numpy data array or HttpResonse with a description of the error that occurred.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform\_datachunk() (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.transform_datachunk}\pysiglinewithargsret{\code{omsi.shared.data\_selection.}\bfcode{transform\_datachunk}}{\emph{data}, \emph{transformation='minusMinDivideMax'}, \emph{secondary\_data=None}, \emph{**kwargs}}{}
Helper function used to transform a given data chunk.
In contrast to transform\_data, this function applies the transformation
directly to the data provided, without consideration of axis information.
This function is used by transform\_data(...) to implement the actual
normalization for independent data chunks that need to be normalized.

Required keyword arguments:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} -- The input numpy array that should be transformed.

\item {} 
\textbf{\texttt{transformation}} -- Data transformation option to be used. For available options
see the transformation\_type dictionary.

\item {} 
\textbf{\texttt{secondary\_data}} -- Other data from previous data iterations a user may reference.

\end{itemize}

\end{description}\end{quote}

Additional transformation-dependent keyword arguments:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{kwargs}} -- 
Additional keyword arguments that are specific for different
data transformation. Below a list of additional keyword arguments
used for different transformation options
\begin{itemize}
\item {} \begin{description}
\item[{transformation: `threshold'}] \leavevmode\begin{description}
\item[{** `threshold'}] \leavevmode{[}The threshold parameter to be used for{]}
the thresold operation. If threshold is
not specified, then the 5th \%tile will
be used as threshold value instead, ie.,
the bottom 5\% of the data are set to 0.

\end{description}

\end{description}

\end{itemize}


\item[{Returns}] \leavevmode
This function returns the normalized data array. If an unsupported
transformation option is given, then the function simply return the
unmodified input array.

\end{description}\end{quote}

\end{fulllineitems}

\index{transform\_reduce\_description\_to\_json() (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.transform_reduce_description_to_json}\pysiglinewithargsret{\code{omsi.shared.data\_selection.}\bfcode{transform\_reduce\_description\_to\_json}}{\emph{*args}}{}
Convert the dictionary describing the transformation/reduction operations
to a JSON string.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{args}} -- The list or dictionaries with the description of the transformation
and reduction operations.

\item[{Returns}] \leavevmode
JSON string

\end{description}\end{quote}

\end{fulllineitems}

\index{transformation\_allowed\_numpy\_dual\_data (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.transformation_allowed_numpy_dual_data}\pysigline{\code{omsi.shared.data\_selection.}\bfcode{transformation\_allowed\_numpy\_dual\_data}\strong{ = {[}'add', `arctan2', `bitwise\_and', `bitwise\_not', `bitwise\_or', `bitwise\_xor', `corrcoef', `cov', `divide', `equal', `fmax', `fmin', `fmod', `greater', `greater\_equal', `left\_shift', `less', `less\_equal', `logical\_and', `logical\_or', `logical\_xor', `mod', `multiply', `not\_equal', `power', `right\_shift', `subtract'{]}}}
List of allowed dual data transformations. Dual data transformation,
are operation that operate on a two data input datasets but which do not change
the shape of the data. Below a list of available numpy function options.
NOTE: Some operations may have additional optional or required keyword arguments.
HELP: For full documentation of the different functions see the numpy documentation.
\begin{itemize}
\item {} 
`add'           : out = x1 + x2 = numpy.add(x1,x2)

\item {} 
`arctan2'       : out = numpy.arctan2(x1,x2)

\item {} 
`bitwise\_and'   : out = x1 \&\& x2 = numpy.bitwise\_and(x1,x2)

\item {} 
`bitwise\_not'   : out = numpy.bitwise\_not(x1,x2)

\item {} 
`bitwise\_or',   : out = x1 \textbar{}\textbar{} x2 = numpy.bitwise\_or(x1,x2)

\item {} 
`bitwise\_xor'   : out = numpy.bitwise\_xor(x1,x2)

\item {} 
`corrcoef'      : out = numpy.corrcoef(x1,x2)

\item {} 
`cov'           : out = numpy.cov(x1, x2, rowvar=1, bias=0, ddof=None)

\item {} 
`divide'        : out = x1 / x2 = numpy.divide(x1,x2)

\item {} 
`equal'         : out = x1 == x2 = numpy.equal(x1,x2)

\item {} 
`fmax'          : out = numpy.fmax(x1,x2)

\item {} 
`fmin'          : out = numpy.fmin(x1,x2)

\item {} 
`fmod'          : out = numpy.fmod(x1,x2)

\item {} 
`greater'       : out = x1 \textgreater{} x2 = numpy.greater(x1,x2)

\item {} 
`greater\_equal' : out = x1 \textgreater{}= x2 = numpy.greater\_equal(x1,x2)

\item {} 
`left\_shift'    : out = numpy.left\_shift(x1,x2)

\item {} 
`less'          : out = x1 \textless{} x2 = numpy.less(x1,x2)

\item {} 
`less\_equal'    : out = x1 \textless{}= x2 = numpy.less\_equal(x1,x2)

\item {} 
`logical\_and'   : out = numpy.logical\_and(x1,x2)

\item {} 
`logical\_not'   : See transformation\_allowed\_numpy\_single\_data instead.

\item {} 
`logical\_or'    : out = numpy.logical\_or(x1,x2)

\item {} 
`logical\_xor'   : out = numpy.logical\_xor(x1,x2)

\item {} 
`mod'           : out = numpy.mod(x1,x2)

\item {} 
`multiply'      : out = x1 * x2  = numpy.multiply(x1,x2)

\item {} 
`not\_equal'     : out = x1 != x2 = numpy.not\_equal(x1,x2)

\item {} 
`power'         : out = numpy.power(x1,x2)

\item {} 
`subtract'      : out = x1 - x2  = numpy.subtract(x1,x2)

\item {} 
`right\_shift    : out = np.right\_shift(x1,x2)

\end{itemize}

\end{fulllineitems}

\index{transformation\_allowed\_numpy\_single\_data (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.transformation_allowed_numpy_single_data}\pysigline{\code{omsi.shared.data\_selection.}\bfcode{transformation\_allowed\_numpy\_single\_data}\strong{ = {[}'abs', `arccos', `arccosh', `arcsin', `arcsinh', `arctan', `arctanh', `argsort', `around', `ceil', `clip', `cos', `cosh', `deg2rad', `degrees', `exp', `exp2', `fabs', `floor', `hypot', `invert', `log', `log2', `log10', `logical\_not', `negative', `sign', `round', `sin', `sinc', `sinhsqrt', `sort', `tan', `tanh'{]}}}
List of allowed single data transformations. Single data transformation,
are operations that operate on a single data input and which do not change
the shape of the data. Below a list of available numpy options.
NOTE: Some operations may have additional optional or required keyword arguments.
HELP: For full documentation of the different functions see the numpy documentation.
\begin{itemize}
\item {} 
`abs'    : out = numpy.abs(x1)

\item {} 
`arccos' : out = numpy.arccos(x1)

\item {} 
`arccosh': out = numpy.arccosh(x1)

\item {} 
`arcsin' : out = numpy.arcsin(x1)

\item {} 
`arcsinh': out = numpy.arcsinh(x1)

\item {} 
`arctan' : out = numpy.arctan(x1)

\item {} 
`arctanh': out = numpy.arctanh1(x1)

\item {} 
`argsort'   : out = numpy.argsort(data, axis, kind='quicksort', order=None)

\item {} 
`around' : out = numpy.around(x1, decimals)

\item {} 
`ceil'   : out = numpy.ceil(x1)

\item {} 
`cos'    : out = numpy.cos(x1)

\item {} 
`cosh'   : out = numpy.cosh(x1)

\item {} 
`clip'   : out = numpy.clip(x1, a\_min, a\_max)

\item {} 
`deg2rad': out = numpy.deg2rad(x1)

\item {} 
`degrees : out = numpy.degrees(x1)

\item {} 
`exp'    : out = numpy.exp(x1)

\item {} 
`exp2'   : out = numpy.exp2(x1)

\item {} 
`fabs'   : out = numpy.fabs(x1)

\item {} 
`floor'  : out = numpy.floor(x1)

\item {} 
`hypot'  : out = numpy.hypot(x1)

\item {} 
`invert' : out = numpy.invert(x1)

\item {} \begin{description}
\item[{`log'}] \leavevmode{[}out{[}x1\textgreater{}0{]} = log(x1{[}x1\textgreater{}0{]}) \textbackslash{}{]}
out{[}x1\textless{}0{]} = log(x1{[}x1\textless{}0{]}*-1)*-1 out{[}x1==0{]} = 0

\end{description}

\item {} \begin{description}
\item[{`log2 `: out{[}x1\textgreater{}0{]} = log2(x1{[}x1\textgreater{}0{]}) }] \leavevmode
out{[}x1\textless{}0{]} = log2(x1{[}x1\textless{}0{]}*-1)*-1 out{[}x1==0{]} = 0

\end{description}

\item {} \begin{description}
\item[{`log10': out{[}x1\textgreater{}0{]} = log10(x1{[}x1\textgreater{}0{]}) }] \leavevmode
out{[}x1\textless{}0{]} = log10(x1{[}x1\textless{}0{]}*-1)*-1 out{[}x1==0{]} = 0

\end{description}

\item {} 
`logical\_not' : out = numpy.logical\_not(x1)

\item {} 
`negative' : out = np.negative(x1)

\item {} 
`round' : out = numpy.round(x1, decimals)

\item {} \begin{description}
\item[{`sqrt'}] \leavevmode{[}out{[}x1\textgreater{}0{]} = sqrt(x1{[}x1\textgreater{}0{]}) \textbackslash{}{]}
out{[}x1\textless{}0{]} = sqrt(x1{[}x1\textless{}0{]}*-1)*-1 out{[}x1==0{]} = 0

\end{description}

\item {} 
`sign' : out = numpy.sign(x1)

\item {} 
`sin'  : out = numpy.sin(x1)

\item {} 
`sinc' : out = numpy.sinc(x1)

\item {} 
`sinh' : out = numpy.sinh(x1)

\item {} 
`sort' : out = numpy.sort(x1, axis=-1, kind='quicksort', order=None)

\item {} 
`swapaxes: out = numpy.swapaxes(x1, axis1, axis2)

\item {} 
`tan'  : out = numpy.tan(x1)

\item {} 
`tanh' : out = numpy.tanh(x1)

\end{itemize}

\end{fulllineitems}

\index{transformation\_type (in module omsi.shared.data\_selection)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.data_selection.transformation_type}\pysigline{\code{omsi.shared.data\_selection.}\bfcode{transformation\_type}\strong{ = \{`singleDataTransform': `singleDataTransform', `scale': `scale', `divideMax': `divideMax', `astype': `astype', `threshold': `threshold', `minusMinDivideMax': `minusMinDivideMax', `dualDataTransform': `dualDataTransform', `arithmetic': `arithmetic'\}}}
Dictionary of available data transformation options. Available options are:
\begin{itemize}
\item {} 
`arithmetic' : Same as `dualDataTransform'. See `dualDataTransform' below for details.

\item {} 
`divideMax' : Divide the data by the current maximum value.

\item {} \begin{description}
\item[{`minusMinDivideMax'}] \leavevmode{[}Substract the minimum value from the data and \textbackslash{}{]}
then divide the data by maximum of the data (with the minimum already substracted.

\end{description}

\item {} \begin{description}
\item[{`dualDataTransform'}] \leavevmode{[}Apply arbitrary arithmetic operation to the data. Additional parameter \textbackslash{}{]}
required for this option are:
\begin{itemize}
\item {} 
\emph{operation} : String defining the arithmetic operations to be applied. Supported operations are: `add', `divide', `greater', `greater\_equal', `multiply', `subtract'

\item {} \begin{description}
\item[{`x1'}] \leavevmode{[}The first data operand of the arithmetic operation. \textbackslash{}{]}
The input data will be used by default if x1 is not specified. You may also specify `data' to explicitly indicate that the input data should be assigned to x1. You may specify data0 to indicate that the output of another data operation should be used. Note, data0 here refers to the input to the full data operation pipeline. Data from other parts of the pipeline, are then indexed using 1-based indices. E.g,. to access the output of the first data operation set x1='data0'

\end{description}

\item {} \begin{description}
\item[{`x2'}] \leavevmode{[}The second data operand of the arithmetic operation. \textbackslash{}{]}
The input data will be used by default if x2 is not specified. You may also specify `data' to explicitly indicate that the input data should be assigned to x2. You may specify data0 to indicate that the output of another data operation should be used. Note, data0 here refers to the input to the full data operation pipeline. Data from other parts of the pipeline, are then indexed using 1-based indices. E.g,. to access the output of the first data operation set x2='data0'

\end{description}

\item {} 
... any additional parameters needed for the numpy function.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{`singleDataTransform'}] \leavevmode{[}Apply scaling transformation to the data.  Additional parameters \textbackslash{}{]}
required for this options are. NOTE: operation=='log or operation=='sqrt': If the minimum value is 0 then the transformation is applied topositive values only and 0 values remain as is. If the minimum value is larger then 0, then the log-scale is applied as is, i.e., np.log(data). If the minimum data value is negative, then the log scale is applied independently to the positive values and the negative values, ie., outdata{[}posvalues{]} = np.log(data{[}posvalues{]}) outdata{[}negvalues{]} = np.log(data{[}negvalues{]}*-1.)*-1.
\begin{itemize}
\item {} 
`operation' : String defining the scaling operations to be applied. See the transformation\_allowed\_numpy\_single\_data list for a complete list
of allowed scaling operations. Some of the more commonly used scalingoperations include: `abs', `log', `sqrt', `around' etc.

\item {} \begin{description}
\item[{`x1'}] \leavevmode{[}The first data operand for the scaling.{]}
The input data will be used by default if x1 is not specified. You may also specify `data' to explicitly indicate that the input data should be assigned to x1.

\end{description}

\end{itemize}

Additional optional keyword arguments depending on the used operation:
\begin{itemize}
\item {} \begin{description}
\item[{`decimals'}] \leavevmode{[}Number of decimal places to round to when using numpy.around or numpy.round \textbackslash{}{]}
(default: 0).  If decimals is negative, it specifies the
number of positions to the left of the decimal point.

\end{description}

\item {} 
`a\_min', `a\_max' : Lower and upper bound when using numpy.clip.

\item {} 
`axis', `kind', `order' : Additional optional arguments for numpy.argsort and numpy.sort.

\item {} 
...

\end{itemize}

\end{description}

\end{itemize}
\begin{itemize}
\item {} 
`scale' : Same as `singleDataTransform'. See `singleDataTransform' for details.

\item {} \begin{description}
\item[{`threshold'}] \leavevmode{[}Threshold the data. Set all values that are smaller than threshold \textbackslash{}{]}
to 0. Additional parameters required for this option are:
\begin{quote}
\begin{itemize}
\item {} 
`threshold'. If threshold is missing, then the threshold will be 

\end{itemize}
\begin{quote}

set ot the 5\%'ile so that the bottom 5\% of the data will be set to 0.
\end{quote}
\end{quote}

\end{description}

\item {} 
`astype' : Change the type of the data. Additional required parameters are: 
\begin{itemize}
\item {} 
`dtype' : The numpy data type to be used. Default dtype='float'.

\end{itemize}

\end{itemize}

\end{fulllineitems}



\subsubsection{\texttt{omsi\_web\_helper} Module}
\label{omsi.shared:omsi-web-helper-module}\label{omsi.shared:module-omsi.shared.omsi_web_helper}\index{omsi.shared.omsi\_web\_helper (module)}
Module with helper functions for interactions with the OpenMSI web infrastructure,
e.g. update job status, explicitly add a file to the OpenMSI database,
update file permissions so that Apache can access it etc.
\index{UserInput (class in omsi.shared.omsi\_web\_helper)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.omsi_web_helper.UserInput}\pysigline{\strong{class }\code{omsi.shared.omsi\_web\_helper.}\bfcode{UserInput}}
Bases: \code{object}

Collection of helper functions used to collect user input
\index{userinput\_with\_timeout() (omsi.shared.omsi\_web\_helper.UserInput static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.omsi_web_helper.UserInput.userinput_with_timeout}\pysiglinewithargsret{\strong{static }\bfcode{userinput\_with\_timeout}}{\emph{timeout}, \emph{default='`}}{}
Read user input. Return default value given after timeout.
This function decides which platform-dependent version should
be used to retrieve the user input.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{timeout}} -- Number of seconds till timeout

\item {} 
\textbf{\texttt{default}} (\emph{\texttt{String}}) -- Default string to be returned after timeout

\end{itemize}

\item[{Returns}] \leavevmode
String

\end{description}\end{quote}

\end{fulllineitems}

\index{userinput\_with\_timeout\_default() (omsi.shared.omsi\_web\_helper.UserInput static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.omsi_web_helper.UserInput.userinput_with_timeout_default}\pysiglinewithargsret{\strong{static }\bfcode{userinput\_with\_timeout\_default}}{\emph{timeout}, \emph{default='`}}{}
Read user input. Return default value given after timeout.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{timeout}} -- Number of seconds till timeout

\item {} 
\textbf{\texttt{default}} (\emph{\texttt{String}}) -- Default string to be returned after timeout

\end{itemize}

\item[{Returns}] \leavevmode
String

\end{description}\end{quote}

\end{fulllineitems}

\index{userinput\_with\_timeout\_windows() (omsi.shared.omsi\_web\_helper.UserInput static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.omsi_web_helper.UserInput.userinput_with_timeout_windows}\pysiglinewithargsret{\strong{static }\bfcode{userinput\_with\_timeout\_windows}}{\emph{timeout}, \emph{default='`}}{}~\begin{description}
\item[{Read user input. Return default value given after timeout.}] \leavevmode
This function is used when running on windows-based systems.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{timeout}} -- Number of seconds till timeout

\item {} 
\textbf{\texttt{default}} (\emph{\texttt{String}}) -- Default string to be returned after timeout

\end{itemize}

\item[{Returns}] \leavevmode
String

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{WebHelper (class in omsi.shared.omsi\_web\_helper)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.omsi_web_helper.WebHelper}\pysigline{\strong{class }\code{omsi.shared.omsi\_web\_helper.}\bfcode{WebHelper}}
Bases: \code{object}

Class providing a collection of functions for web-related file conversion
tasks, e.g, : i) adding files to the web database, ii) notifying users via email,
iii) setting file permissions for web-access.
\index{allowed\_nersc\_locations (omsi.shared.omsi\_web\_helper.WebHelper attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.omsi_web_helper.WebHelper.allowed_nersc_locations}\pysigline{\bfcode{allowed\_nersc\_locations}\strong{ = {[}'/project/projectdirs/openmsi/omsi\_data\_private', `/global/project/projectdirs/openmsi/omsi\_data\_private', `/data/openmsi/omsi\_data'{]}}}
\end{fulllineitems}

\index{default\_db\_server\_url (omsi.shared.omsi\_web\_helper.WebHelper attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.omsi_web_helper.WebHelper.default_db_server_url}\pysigline{\bfcode{default\_db\_server\_url}\strong{ = `https://openmsi.nersc.gov/'}}
\end{fulllineitems}

\index{register\_file\_with\_db() (omsi.shared.omsi\_web\_helper.WebHelper static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.omsi_web_helper.WebHelper.register_file_with_db}\pysiglinewithargsret{\strong{static }\bfcode{register\_file\_with\_db}}{\emph{filepath}, \emph{db\_server}, \emph{file\_user\_name}, \emph{jobid=None}, \emph{check\_add\_nersc=True}}{}
Function used to register a given file with the database
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filepath}} -- Path of the file to be added to the database

\item {} 
\textbf{\texttt{db\_server}} -- The database server url

\item {} 
\textbf{\texttt{file\_user\_name}} -- The user to be used, or None if the user should
be determined based on the file URL.

\item {} 
\textbf{\texttt{jobid}} -- Optional input parameter defining the jobid to be updated.
If the jobid is given then the job will be updated with the
database instead of adding the file explicitly. I.e.,
instead of register\_filer\_with\_db the update\_job\_status call
is executed.

\end{itemize}

\item[{Returns}] \leavevmode
Boolean indicating whether the operation was successful

\end{description}\end{quote}

\end{fulllineitems}

\index{send\_email() (omsi.shared.omsi\_web\_helper.WebHelper static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.omsi_web_helper.WebHelper.send_email}\pysiglinewithargsret{\strong{static }\bfcode{send\_email}}{\emph{subject}, \emph{body}, \emph{sender='convert@openmsi.nersc.gov'}, \emph{email\_type='success'}, \emph{email\_success\_recipients=None}, \emph{email\_error\_recipients=None}}{}
Send email notification to users.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{subject}} -- Subject line of the email

\item {} 
\textbf{\texttt{body}} -- Body text of the email.

\item {} 
\textbf{\texttt{sender}} -- The originating email address

\item {} 
\textbf{\texttt{email\_type}} -- One of `success, `error', `warning'. Error messages are sent
to ConvertSettings.email\_error\_recipients, success messages to
ConvertSettings.email\_success\_recipients and warning messages are sent to both lists.

\item {} 
\textbf{\texttt{email\_success\_recipients}} -- List of user that should receive an email if the status is success
or warning.

\item {} 
\textbf{\texttt{email\_error\_recipients}} -- List of users that should receive an email if the status is error
or warning.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_apache\_acl() (omsi.shared.omsi\_web\_helper.WebHelper static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.omsi_web_helper.WebHelper.set_apache_acl}\pysiglinewithargsret{\strong{static }\bfcode{set\_apache\_acl}}{\emph{filepath}}{}
Helper function used to set acl permissions for apache to make the given file accesible
to Apache at NERSC. This necessary to make the file readable for adding it to the
database.

\end{fulllineitems}

\index{super\_users (omsi.shared.omsi\_web\_helper.WebHelper attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.omsi_web_helper.WebHelper.super_users}\pysigline{\bfcode{super\_users}\strong{ = {[}'bpb', `oruebel'{]}}}
\end{fulllineitems}

\index{update\_job\_status() (omsi.shared.omsi\_web\_helper.WebHelper static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.omsi_web_helper.WebHelper.update_job_status}\pysiglinewithargsret{\strong{static }\bfcode{update\_job\_status}}{\emph{filepath}, \emph{db\_server}, \emph{jobid}, \emph{status='complete'}}{}
Function used to update the status of the job on the server
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filepath}} -- Path of the file to be added to the database (only needed update file permissions)

\item {} 
\textbf{\texttt{db\_server}} -- The database server url

\item {} 
\textbf{\texttt{jobid}} -- The id of the current job.

\item {} 
\textbf{\texttt{status}} -- One of `running', `complete' or `error'

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{\texttt{spectrum\_layout} Module}
\label{omsi.shared:module-omsi.shared.spectrum_layout}\label{omsi.shared:spectrum-layout-module}\index{omsi.shared.spectrum\_layout (module)}
This module provides capabilities for computing different layouts for spectra
\index{compute\_hilbert\_spectrum() (in module omsi.shared.spectrum\_layout)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.spectrum_layout.compute_hilbert_spectrum}\pysiglinewithargsret{\code{omsi.shared.spectrum\_layout.}\bfcode{compute\_hilbert\_spectrum}}{\emph{original\_coords}, \emph{original\_intensities}, \emph{left=0}, \emph{right=0}}{}
Given a 1D spectrum, interpolate the spectrum onto the closest 2D hilbert curve.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{original\_coords}} (\emph{\texttt{1D numpy array in increasing order.}}) -- The original coordinate values (m/z). Values must be increasing.

\item {} 
\textbf{\texttt{original\_intensities}} (\emph{\texttt{1D numpy array of same length as original\_coords}}) -- The original intensity values. Same length as original\_coords.

\item {} 
\textbf{\texttt{left}} -- Optional. Value to be used for padding data at the lower bound during interpolation

\item {} 
\textbf{\texttt{right}} -- Optional. Value to be used for padding data at the upper bound during interpolation

\end{itemize}

\item[{Type}] \leavevmode
float

\item[{Type}] \leavevmode
float

\item[{Returns}] \leavevmode
2D numpy array with the coordinate (m/z) values for the hilbert spectrum and separate
2D numpy array for the interpolated intensity values.

\item[{Raises}] \leavevmode
ValueError If original\_coords and original\_intensities have different length.

\end{description}\end{quote}

\end{fulllineitems}

\index{hilbert\_curve() (in module omsi.shared.spectrum\_layout)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.spectrum_layout.hilbert_curve}\pysiglinewithargsret{\code{omsi.shared.spectrum\_layout.}\bfcode{hilbert\_curve}}{\emph{order=2}}{}
Compute  a 2D hilbert curve.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{order}} (\emph{\texttt{Integer that defines a power of 2 (\textgreater{}=2)}}) -- The order of the hilber curve. This is the length of the sides of the square, i.e.,
the number of points in x and y.

\item[{Returns}] \leavevmode
Returns two numpy arrays of integers x,y, indicating the locations of the
vertices of the hilbert curve.

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_2d\_spectrum\_as\_image() (in module omsi.shared.spectrum\_layout)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.spectrum_layout.plot_2d_spectrum_as_image}\pysiglinewithargsret{\code{omsi.shared.spectrum\_layout.}\bfcode{plot\_2d\_spectrum\_as\_image}}{\emph{hilbert\_intensities}, \emph{show\_plot=False}, \emph{show\_axis=False}}{}
Plot image with pixels colored according to hilbert\_intensities.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{hilbert\_intensities}} (\emph{\texttt{2D numpy array.}}) -- 2D numpy array with the intensity values for the spectrum.

\item {} 
\textbf{\texttt{show\_plot}} (\emph{\texttt{Boolean}}) -- Show the generated plot in a window.

\item {} 
\textbf{\texttt{show\_axis}} (\emph{\texttt{Boolean}}) -- Show x,y axis for the plot. Default is False.

\end{itemize}

\item[{Returns}] \leavevmode
matplotlib image plot or None in case that the plotting failed.

\end{description}\end{quote}

\end{fulllineitems}

\index{reinterpolate\_spectrum() (in module omsi.shared.spectrum\_layout)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.spectrum_layout.reinterpolate_spectrum}\pysiglinewithargsret{\code{omsi.shared.spectrum\_layout.}\bfcode{reinterpolate\_spectrum}}{\emph{coords}, \emph{original\_coords}, \emph{original\_intensitities}, \emph{left=0}, \emph{right=0}}{}
Given a 1D spectrum, interpolate the spectrum onto a new axis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{coords}} -- The coordinate values (m/z) for which intensities should be computed.

\item {} 
\textbf{\texttt{original\_coords}} -- The original coordinate values (m/z). Values must be increasing.

\item {} 
\textbf{\texttt{original\_intensitities}} -- The original intensity values. Same length as original\_coords.

\item {} 
\textbf{\texttt{left}} -- Optional. Value to be used if coords \textless{} orignal\_coords

\item {} 
\textbf{\texttt{right}} -- Optional. Value to be used if coords \textgreater{} orignal\_coords

\end{itemize}

\item[{Returns}] \leavevmode
y : \{float, ndarray\} The interpolated values, same shape as coords.

\item[{Raises}] \leavevmode
ValueError If original\_coords and original\_intensities have different length.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{\texttt{log} Module}
\label{omsi.shared:module-omsi.shared.log}\label{omsi.shared:log-module}\index{omsi.shared.log (module)}
Module providing functionality for logging based on the python logging module.
The module is intended toease the use of logging while a developer
can still access the standard python logging mechanism if needed.
\index{log\_helper (class in omsi.shared.log)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.log.log_helper}\pysigline{\strong{class }\code{omsi.shared.log.}\bfcode{log\_helper}}
Bases: \code{object}

BASTet helper module to ease the use of logging

Class Variables:
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
{\hyperref[omsi.shared:omsi.shared.log.log_helper.log_levels]{\emph{\textbf{\texttt{log\_levels}}}}} -- Dictionary describing the different available logging levels.

\end{description}\end{quote}
\index{critical() (omsi.shared.log.log\_helper class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.log.log_helper.critical}\pysiglinewithargsret{\strong{classmethod }\bfcode{critical}}{\emph{module\_name}, \emph{message}, \emph{root=0}, \emph{comm=None}, \emph{*args}, \emph{**kwargs}}{}
Create a critical log entry. This function is typically called as:

log\_helper.critical(module\_name=\_\_name\_\_, message=''your message'')
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{module\_name}} -- \_\_name\_\_ of the calling module or None in case the ROOT logger should be used.

\item {} 
\textbf{\texttt{message}} -- The message to be added to the log

\item {} 
\textbf{\texttt{root}} -- The root process to be used for output when running in parallel. If None, then all
calling ranks will perform logging. Default is 0.

\item {} 
\textbf{\texttt{comm}} -- The MPI communicator to be used to determin the MPI rank. None by default, in which case
mpi.comm\_world is used.

\item {} 
\textbf{\texttt{args}} -- Additional positional arguments for the python logger.debug function. See the python docs.

\item {} 
\textbf{\texttt{kwargs}} -- Additional keyword arguments for the python logger.debug function. See the python docs.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{debug() (omsi.shared.log.log\_helper class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.log.log_helper.debug}\pysiglinewithargsret{\strong{classmethod }\bfcode{debug}}{\emph{module\_name}, \emph{message}, \emph{root=0}, \emph{comm=None}, \emph{*args}, \emph{**kwargs}}{}
Create a debug log entry. This function is typically called as:

log\_helper.debug(module\_name=\_\_name\_\_, message=''your message'')
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{module\_name}} -- \_\_name\_\_ of the calling module or None in case the ROOT logger should be used.

\item {} 
\textbf{\texttt{message}} -- The message to be added to the log

\item {} 
\textbf{\texttt{root}} -- The root process to be used for output when running in parallel. If None, then all
calling ranks will perform logging. Default is 0.

\item {} 
\textbf{\texttt{comm}} -- The MPI communicator to be used to determin the MPI rank. None by default, in which case
mpi.comm\_world is used.

\item {} 
\textbf{\texttt{args}} -- Additional positional arguments for the python logger.debug function. See the python docs.

\item {} 
\textbf{\texttt{kwargs}} -- Additional keyword arguments for the python logger.debug function. See the python docs.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{error() (omsi.shared.log.log\_helper class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.log.log_helper.error}\pysiglinewithargsret{\strong{classmethod }\bfcode{error}}{\emph{module\_name}, \emph{message}, \emph{root=0}, \emph{comm=None}, \emph{*args}, \emph{**kwargs}}{}
Create a error log entry. This function is typically called as:

log\_helper.error(module\_name=\_\_name\_\_, message=''your message'')
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{module\_name}} -- \_\_name\_\_ of the calling module or None in case the ROOT logger should be used.

\item {} 
\textbf{\texttt{message}} -- The message to be added to the log

\item {} 
\textbf{\texttt{root}} -- The root process to be used for output when running in parallel. If None, then all
calling ranks will perform logging. Default is 0.

\item {} 
\textbf{\texttt{comm}} -- The MPI communicator to be used to determin the MPI rank. None by default, in which case
mpi.comm\_world is used.

\item {} 
\textbf{\texttt{args}} -- Additional positional arguments for the python logger.debug function. See the python docs.

\item {} 
\textbf{\texttt{kwargs}} -- Additional keyword arguments for the python logger.debug function. See the python docs.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{exception() (omsi.shared.log.log\_helper class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.log.log_helper.exception}\pysiglinewithargsret{\strong{classmethod }\bfcode{exception}}{\emph{module\_name}, \emph{message}, \emph{root=0}, \emph{comm=None}, \emph{*args}, \emph{**kwargs}}{}
Create a exception log entry. This function is typically called as:

log\_helper.exception(module\_name=\_\_name\_\_, message=''your message'')
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{module\_name}} -- \_\_name\_\_ of the calling module or None in case the ROOT logger should be used.

\item {} 
\textbf{\texttt{message}} -- The message to be added to the log

\item {} 
\textbf{\texttt{root}} -- The root process to be used for output when running in parallel. If None, then all
calling ranks will perform logging. Default is 0.

\item {} 
\textbf{\texttt{comm}} -- The MPI communicator to be used to determin the MPI rank. None by default, in which case
mpi.comm\_world is used.

\item {} 
\textbf{\texttt{args}} -- Additional positional arguments for the python logger.debug function. See the python docs.

\item {} 
\textbf{\texttt{kwargs}} -- Additional keyword arguments for the python logger.debug function. See the python docs.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_default\_format() (omsi.shared.log.log\_helper class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.log.log_helper.get_default_format}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_default\_format}}{}{}
Get default formatting string.

\end{fulllineitems}

\index{get\_logger() (omsi.shared.log.log\_helper class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.log.log_helper.get_logger}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_logger}}{\emph{module\_name}}{}
Get the logger for a particular module. The module\_name
should always be set to the \_\_name\_\_ variable of the calling module.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{module\_name}} -- \_\_name\_\_ of the calling module or None in case the ROOT logger should be used.

\item[{Returns}] \leavevmode
Python logging.Logger retrieved via logging.getLogger.

\end{description}\end{quote}

\end{fulllineitems}

\index{global\_log\_level (omsi.shared.log.log\_helper attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.log.log_helper.global_log_level}\pysigline{\bfcode{global\_log\_level}\strong{ = 20}}
\end{fulllineitems}

\index{info() (omsi.shared.log.log\_helper class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.log.log_helper.info}\pysiglinewithargsret{\strong{classmethod }\bfcode{info}}{\emph{module\_name}, \emph{message}, \emph{root=0}, \emph{comm=None}, \emph{*args}, \emph{**kwargs}}{}
Create a info log entry. This function is typically called as:

log\_helper.info(module\_name=\_\_name\_\_, message=''your message'')
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{module\_name}} -- \_\_name\_\_ of the calling module or None in case the ROOT logger should be used.

\item {} 
\textbf{\texttt{message}} -- The message to be added to the log

\item {} 
\textbf{\texttt{root}} -- The root process to be used for output when running in parallel. If None, then all
calling ranks will perform logging. Default is 0.

\item {} 
\textbf{\texttt{comm}} -- The MPI communicator to be used to determin the MPI rank. None by default, in which case
mpi.comm\_world is used.

\item {} 
\textbf{\texttt{args}} -- Additional positional arguments for the python logger.debug function. See the python docs.

\item {} 
\textbf{\texttt{kwargs}} -- Additional keyword arguments for the python logger.debug function. See the python docs.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{initialized (omsi.shared.log.log\_helper attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.log.log_helper.initialized}\pysigline{\bfcode{initialized}\strong{ = False}}
\end{fulllineitems}

\index{log() (omsi.shared.log.log\_helper class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.log.log_helper.log}\pysiglinewithargsret{\strong{classmethod }\bfcode{log}}{\emph{module\_name}, \emph{message}, \emph{root=0}, \emph{comm=None}, \emph{level=None}, \emph{*args}, \emph{**kwargs}}{}
Convenience function used to select the log message level using an input parameter
rathern than by selecting the approbriate function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{module\_name}} -- \_\_name\_\_ of the calling module or None in case the ROOT logger should be used.

\item {} 
\textbf{\texttt{message}} -- The message to be added to the log

\item {} 
\textbf{\texttt{root}} -- The root process to be used for output when running in parallel. If None, then all
calling ranks will perform logging. Default is 0.

\item {} 
\textbf{\texttt{comm}} -- The MPI communicator to be used to determine the MPI rank. None by default, in which case
mpi.comm\_world is used.

\item {} 
\textbf{\texttt{level}} -- To which logging level should we send the message

\item {} 
\textbf{\texttt{args}} -- Additional positional arguments for the python logger.debug function. See the python docs.

\item {} 
\textbf{\texttt{kwargs}} -- Additional keyword arguments for the python logger.debug function. See the python docs.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{log\_levels (omsi.shared.log.log\_helper attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.log.log_helper.log_levels}\pysigline{\bfcode{log\_levels}\strong{ = \{`INFO': 20, `WARNING': 30, `CRITICAL': 50, `ERROR': 40, `DEBUG': 10, `NOTSET': 0\}}}
\end{fulllineitems}

\index{log\_var() (omsi.shared.log.log\_helper class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.log.log_helper.log_var}\pysiglinewithargsret{\strong{classmethod }\bfcode{log\_var}}{\emph{module\_name}, \emph{root=0}, \emph{comm=None}, \emph{level=None}, \emph{**kwargs}}{}
Log one or more variable values
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{module\_name}} -- \_\_name\_\_ of the calling module or None in case the ROOT logger should be used.

\item {} 
\textbf{\texttt{message}} -- The message to be added to the log

\item {} 
\textbf{\texttt{root}} -- The root process to be used for output when running in parallel. If None, then all
calling ranks will perform logging. Default is 0.

\item {} 
\textbf{\texttt{comm}} -- The MPI communicator to be used to determin the MPI rank. None by default, in which case
mpi.comm\_world is used.

\item {} 
\textbf{\texttt{kwargs}} -- Variables+values to be logged

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_log\_level() (omsi.shared.log.log\_helper class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.log.log_helper.set_log_level}\pysiglinewithargsret{\strong{classmethod }\bfcode{set\_log\_level}}{\emph{level}}{}
Set the logging level for all BASTet loggers
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{level}} -- The logging levels to be used, one of the values specified in log\_helper.log\_levels.

\end{description}\end{quote}

\end{fulllineitems}

\index{setup\_logging() (omsi.shared.log.log\_helper class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.log.log_helper.setup_logging}\pysiglinewithargsret{\strong{classmethod }\bfcode{setup\_logging}}{\emph{level=None}}{}
Call this function at the beginning of your code to initiate logging.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{level}} -- The default log level to be used. One of \code{log\_helper.log\_level}.

\end{description}\end{quote}

\end{fulllineitems}

\index{warning() (omsi.shared.log.log\_helper class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.log.log_helper.warning}\pysiglinewithargsret{\strong{classmethod }\bfcode{warning}}{\emph{module\_name}, \emph{message}, \emph{root=0}, \emph{comm=None}, \emph{*args}, \emph{**kwargs}}{}
Create a warning log entry. This function is typically called as:

log\_helper.warning(module\_name=\_\_name\_\_, message=''your message'')
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{module\_name}} -- \_\_name\_\_ of the calling module or None in case the ROOT logger should be used.

\item {} 
\textbf{\texttt{message}} -- The message to be added to the log

\item {} 
\textbf{\texttt{root}} -- The root process to be used for output when running in parallel. If None, then all
calling ranks will perform logging. Default is 0.

\item {} 
\textbf{\texttt{comm}} -- The MPI communicator to be used to determin the MPI rank. None by default, in which case
mpi.comm\_world is used.

\item {} 
\textbf{\texttt{args}} -- Additional positional arguments for the python logger.debug function. See the python docs.

\item {} 
\textbf{\texttt{kwargs}} -- Additional keyword arguments for the python logger.debug function. See the python docs.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{\texttt{mpi\_helper} Module}
\label{omsi.shared:module-omsi.shared.mpi_helper}\label{omsi.shared:mpi-helper-module}\index{omsi.shared.mpi\_helper (module)}
Module used to ease the use of MPI and distributed parallel implementations using MPI
\index{barrier() (in module omsi.shared.mpi\_helper)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.mpi_helper.barrier}\pysiglinewithargsret{\code{omsi.shared.mpi\_helper.}\bfcode{barrier}}{\emph{comm=None}}{}
MPI barrier operation or no-op when running without MPI
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{comm}} -- MPI communicator. If None, then MPI.COMM\_WORLD will be used.

\end{description}\end{quote}

\end{fulllineitems}

\index{broadcast() (in module omsi.shared.mpi\_helper)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.mpi_helper.broadcast}\pysiglinewithargsret{\code{omsi.shared.mpi\_helper.}\bfcode{broadcast}}{\emph{data}, \emph{comm=None}, \emph{root=0}}{}
MPI broadcast operation to broadcast data from one rank to all other ranks
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} -- The data to be gathered

\item {} 
\textbf{\texttt{comm}} -- MPI communicator. If None, then MPI.COMM\_WORLD will be used.

\item {} 
\textbf{\texttt{root}} -- The rank where the data is sned from

\end{itemize}

\item[{Returns}] \leavevmode
The data object

\end{description}\end{quote}

\end{fulllineitems}

\index{gather() (in module omsi.shared.mpi\_helper)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.mpi_helper.gather}\pysiglinewithargsret{\code{omsi.shared.mpi\_helper.}\bfcode{gather}}{\emph{data}, \emph{comm=None}, \emph{root=0}}{}
MPI gather operation or return a list with just {[}data,{]} if MPI is not available
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} -- The data to be gathered

\item {} 
\textbf{\texttt{comm}} -- MPI communicator. If None, then MPI.COMM\_WORLD will be used.

\item {} 
\textbf{\texttt{root}} -- The rank where the data should be collected to. Default value is 0

\end{itemize}

\item[{Returns}] \leavevmode
List of data objects from all the ranks

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_comm\_world() (in module omsi.shared.mpi\_helper)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.mpi_helper.get_comm_world}\pysiglinewithargsret{\code{omsi.shared.mpi\_helper.}\bfcode{get\_comm\_world}}{}{}
Get MPI.COMM\_WORLD
:return: mpi communicator or None if MPI is not available

\end{fulllineitems}

\index{get\_rank() (in module omsi.shared.mpi\_helper)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.mpi_helper.get_rank}\pysiglinewithargsret{\code{omsi.shared.mpi\_helper.}\bfcode{get\_rank}}{\emph{comm=None}}{}
Get the current process rank
:param comm: MPI communicator. If None, then MPI.COMM\_WORLD will be used.
:return: The integer index of the rank

\end{fulllineitems}

\index{get\_size() (in module omsi.shared.mpi\_helper)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.mpi_helper.get_size}\pysiglinewithargsret{\code{omsi.shared.mpi\_helper.}\bfcode{get\_size}}{\emph{comm=None}}{}
Get the size of the current communication domain/
:param comm: MPI communicator. If None, then MPI.COMM\_WORLD will be used.
:return: The integer index of the rank

\end{fulllineitems}

\index{imports\_mpi() (in module omsi.shared.mpi\_helper)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.mpi_helper.imports_mpi}\pysiglinewithargsret{\code{omsi.shared.mpi\_helper.}\bfcode{imports\_mpi}}{\emph{python\_object}}{}
Check whether the given class import mpi

The implementation inspects the source code of the
analysis to see if MPI is imported by the code.

\end{fulllineitems}

\index{is\_mpi\_available() (in module omsi.shared.mpi\_helper)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.mpi_helper.is_mpi_available}\pysiglinewithargsret{\code{omsi.shared.mpi\_helper.}\bfcode{is\_mpi\_available}}{}{}
Check if MPI is available. Same as MPI\_AVAILABLE
:return: bool indicating whether MPI is available

\end{fulllineitems}

\index{mpi\_type\_from\_dtype() (in module omsi.shared.mpi\_helper)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.mpi_helper.mpi_type_from_dtype}\pysiglinewithargsret{\code{omsi.shared.mpi\_helper.}\bfcode{mpi\_type\_from\_dtype}}{\emph{dtype}}{}
Ge the the corresponding MPI type for the given basic numpy dtype
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{dtype}} -- Basic numpy dtype to be mapped to the MPI type

\item[{Returns}] \leavevmode
The MPI type or None if not found

\end{description}\end{quote}

\end{fulllineitems}

\index{parallel\_over\_axes (class in omsi.shared.mpi\_helper)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.mpi_helper.parallel_over_axes}\pysiglinewithargsret{\strong{class }\code{omsi.shared.mpi\_helper.}\bfcode{parallel\_over\_axes}}{\emph{task\_function}, \emph{task\_function\_params}, \emph{main\_data}, \emph{split\_axes}, \emph{main\_data\_param\_name}, \emph{schedule='STATIC\_1D'}, \emph{root=0}, \emph{comm=None}}{}
Bases: \code{object}

Helper class used to parallelize the execution of a function using MPI by splitting the
input data into sub-blocks along a given set of axes.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{task\_function}} -- The function we should run.

\item {} 
\textbf{\texttt{task\_function\_params}} -- Dict with the input parameters for the function.
may be None or \{\} if no parameters are needed.

\item {} 
\textbf{\texttt{main\_data}} -- Dataset over which we should parallelize

\item {} 
\textbf{\texttt{split\_axes}} -- List of integer axis indicies over which we should parallelize

\item {} 
\textbf{\texttt{main\_data\_param\_name}} -- The name of data input parameter of the task function

\item {} 
\textbf{\texttt{root}} -- The master MPI rank (Default=0)

\item {} 
\textbf{\texttt{schedule}} -- The task scheduling schema to be used (see parallel\_over\_axes.SCHEDULES

\item {} 
\textbf{\texttt{collect\_output}} -- Should we collect all the output from the ranks on the master rank?

\item {} 
\textbf{\texttt{schedule}} -- The parallelization schedule to be used. See also parallel\_over\_axes.schedule

\item {} 
\textbf{\texttt{result}} -- The result form the task\_function. If self.\_\_data\_collected  is set and we are the root
then this will a list with the the output of all tasks

\item {} 
\textbf{\texttt{blocks}} -- List with tuples describing the selected subset of data processed by the given block task.
If self.\_\_data\_collected is set and we are the root rank then this is a list of all the blocks
processed by each rank.

\item {} 
\textbf{\texttt{block\_times}} -- List of times in seconds used to process the data block with the given index.
NOTE: The block times include also any required communications and other operations to initialize
and complete the task, and not just the execution of the task function itself.

\item {} 
\textbf{\texttt{run\_time}} -- Float time in seconds for executing the run function.

\item {} 
\textbf{\texttt{comm}} -- The MPI communicator used for the parallelization. Default value is MPI.COMM\_WORLD

\end{itemize}

\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{task\_function}} -- The function we should run.

\item {} 
\textbf{\texttt{task\_function\_params}} -- Dict with the input parameters for the function.
May be None or \{\} if no parameters are needed.

\item {} 
\textbf{\texttt{main\_data}} -- Dataset over which we should parallelize

\item {} 
\textbf{\texttt{split\_axes}} -- List of integer axis indicies over which we should parallelize

\item {} 
\textbf{\texttt{main\_data\_param\_name}} -- The name of data input parameter of the task function

\item {} 
\textbf{\texttt{root}} -- The master MPI rank (Default=0)

\item {} 
\textbf{\texttt{schedule}} -- The task scheduling schema to be used (see parallel\_over\_axes.SCHEDULES

\item {} 
\textbf{\texttt{comm}} -- The MPI communicator used for the parallelization. Default value is None, in which case
MPI.COMM\_WORLD is used

\end{itemize}

\end{description}\end{quote}
\index{MPI\_MESSAGE\_TAGS (omsi.shared.mpi\_helper.parallel\_over\_axes attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.mpi_helper.parallel_over_axes.MPI_MESSAGE_TAGS}\pysigline{\bfcode{MPI\_MESSAGE\_TAGS}\strong{ = \{`BLOCK\_MSG': 12, `COLLECT\_MSG': 13, `RANK\_MSG': 11\}}}
\end{fulllineitems}

\index{SCHEDULES (omsi.shared.mpi\_helper.parallel\_over\_axes attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.mpi_helper.parallel_over_axes.SCHEDULES}\pysigline{\bfcode{SCHEDULES}\strong{ = \{`DYNAMIC': `DYNAMIC', `STATIC\_1D': `STATIC\_1D', `STATIC': `STATIC'\}}}
\end{fulllineitems}

\index{collect\_data() (omsi.shared.mpi\_helper.parallel\_over\_axes method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.mpi_helper.parallel_over_axes.collect_data}\pysiglinewithargsret{\bfcode{collect\_data}}{\emph{force\_collect=False}}{}
Collect the results from the parallel execution to the self.root rank.
\begin{description}
\item[{NOTE: On the root the self.result, self.blocks, and self.block\_times variables are}] \leavevmode
updated with the collected data as well and self.\_\_data\_collected will be set

\item[{NOTE: If the data has already been collected previously (ie., collect\_data has been called}] \leavevmode
before), then the collection will not be performed again, unless force\_collect is set.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{force\_collect}} -- Set this parameter to force that data collection is performed again.
By default the collect\_data is performed only once for each time the run(..) function
is called and the results are reused to ensure consistent data structures. We can
force that collect will be reexecuted anyways by setting force\_collect.

\item[{Returns}] \leavevmode
On worker ranks (i.e., MPI\_RANK!=self.root) this is simply the
self.result and self.blocks containing the result created by run function.
On the root rank (i.e., MPI\_RANK!=self.root) this is a tuple of two lists
containing the combined data of all  self.result and self.blocks from all ranks respectively.

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (omsi.shared.mpi\_helper.parallel\_over\_axes method)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.mpi_helper.parallel_over_axes.run}\pysiglinewithargsret{\bfcode{run}}{}{}
Call this function to run the function in parallel.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode

Tuple with the following elements:
\begin{enumerate}
\item {} 
List with the results from the local execution of the task\_function. Each
entry is the result from one return of the task\_function. In the case of static
execution, this is always a list of length 1.

\item {} 
List of block\_indexes. Each block\_index is a tuple with the selection used to
divide the data into sub-blocks. In the case of static decomposition we have
a range slice object along the axes used for decomposition whereas in the
case of dynamic scheduling we usually have single integer point selections
for each task.

\end{enumerate}


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{test\_mpi\_available() (in module omsi.shared.mpi\_helper)}

\begin{fulllineitems}
\phantomsection\label{omsi.shared:omsi.shared.mpi_helper.test_mpi_available}\pysiglinewithargsret{\code{omsi.shared.mpi\_helper.}\bfcode{test\_mpi\_available}}{}{}
This function import MPI in a seperate process to safely check if
MPI is available. This precaution is necessary as on Cray systems
importing MPI can lead to a crash on, e.g., login nodes where the
use of MPI is not permitted. By executing the import in a separate
process we avoid crashing the main process and we can safely check
whether the process aborted or not.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
False if the import failed, otherwise return True

\end{description}\end{quote}

\end{fulllineitems}



\subsection{workflow Package}
\label{omsi.workflow:workflow-package}\label{omsi.workflow::doc}
\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


{\hyperref[omsi.workflow:module\string-omsi.workflow]{\emph{\code{omsi.workflow}}}}
 & 
Package with modules for specification and execution of analysis tasks and complex analysis workflows.
\\
\hline
{\hyperref[omsi.workflow:module\string-omsi.workflow.common]{\emph{\code{omsi.workflow.common}}}}
 & 
Module defining basic data structures used by workflows.
\\
\hline
{\hyperref[omsi.workflow.driver:module\string-omsi.workflow.driver]{\emph{\code{omsi.workflow.driver}}}}
 & 
Package with drivers for analyses and workflows.
\\
\hline
{\hyperref[omsi.workflow.driver:module\string-omsi.workflow.driver.base]{\emph{\code{omsi.workflow.driver.base}}}}
 & 
Module with base classes for workflow drivers.
\\
\hline
{\hyperref[omsi.workflow.driver:module\string-omsi.workflow.driver.cl_analysis_driver]{\emph{\code{omsi.workflow.driver.cl\_analysis\_driver}}}}
 & 
Module used to help with driving the execution of omsi-based analyses.
\\
\hline
{\hyperref[omsi.workflow.driver:module\string-omsi.workflow.driver.cl_workflow_driver]{\emph{\code{omsi.workflow.driver.cl\_workflow\_driver}}}}
 & 
Module used to help with driving the execution of analysis workflows
\\
\hline
{\hyperref[omsi.workflow.executor:module\string-omsi.workflow.executor]{\emph{\code{omsi.workflow.executor}}}}
 & 
Package with executors of analysis workflows.
\\
\hline
{\hyperref[omsi.workflow.executor:module\string-omsi.workflow.executor.base]{\emph{\code{omsi.workflow.executor.base}}}}
 & 
Module containing base classes for workflow executors.
\\
\hline
{\hyperref[omsi.workflow.executor:module\string-omsi.workflow.executor.greedy_executor]{\emph{\code{omsi.workflow.executor.greedy\_executor}}}}
 & 
Module used to help with the execution of complex analyses workflows
\\
\hline\end{longtable}



\subsubsection{\texttt{workflow} Package}
\label{omsi.workflow:id1}\phantomsection\label{omsi.workflow:module-omsi.workflow}\index{omsi.workflow (module)}
Package with modules for specification and execution of analysis tasks and complex analysis workflows.


\subsubsection{\texttt{common} Module}
\label{omsi.workflow:common-module}\label{omsi.workflow:module-omsi.workflow.common}\index{omsi.workflow.common (module)}
Module defining basic data structures used by workflows.
\index{RawDescriptionDefaultHelpArgParseFormatter (class in omsi.workflow.common)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.RawDescriptionDefaultHelpArgParseFormatter}\pysiglinewithargsret{\strong{class }\code{omsi.workflow.common.}\bfcode{RawDescriptionDefaultHelpArgParseFormatter}}{\emph{prog}, \emph{indent\_increment=2}, \emph{max\_help\_position=24}, \emph{width=None}}{}
Bases: \code{argparse.ArgumentDefaultsHelpFormatter}, \code{argparse.RawDescriptionHelpFormatter}

Simple derived formatter class for use with argparse used by the
cl\_analysis\_driver class. This formatter combines the default
argparse.ArgumentDefaultsHelpFormatter and
argparse.RawDescriptionHelpFormatter
for formatting arguments and help descriptions.

\end{fulllineitems}

\index{analysis\_task\_list (class in omsi.workflow.common)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list}\pysiglinewithargsret{\strong{class }\code{omsi.workflow.common.}\bfcode{analysis\_task\_list}}{\emph{analysis\_objects=None}}{}
Bases: \code{list}

Define a python list of analyses to be executed as a workflow. The list allows only for
storage of analysis\_base objects and ensures uniqueness of elements in the list.

Initialize the set of analysis tasks to be performed as part of the workflow
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_objects}} -- Set or list of unique analysis objects to be added.
Duplicates will be removed.

\end{description}\end{quote}
\index{add() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.add}\pysiglinewithargsret{\bfcode{add}}{\emph{analysis\_object}}{}
Same as append

\end{fulllineitems}

\index{add\_all() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.add_all}\pysiglinewithargsret{\bfcode{add\_all}}{}{}
Add all known analyses to the workflow list
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The updated analysis\_task\_list with all analyses added

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_analysis\_dependencies() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.add_analysis_dependencies}\pysiglinewithargsret{\bfcode{add\_analysis\_dependencies}}{}{}
Add the dependencies of all analyses to the workflow list in case they are missing.

This function is recursive, step-by-step adding all dependencies of the workflow to the list of
tasks to be executed, until no more dependencies are found.

Usually this function is called by the workflow executor itself before running the analysis and
should not need to be called by the user.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Integer indicating the number of dependencies added to the list of tasks

\end{description}\end{quote}

\end{fulllineitems}

\index{all() (omsi.workflow.common.analysis\_task\_list class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.all}\pysiglinewithargsret{\strong{classmethod }\bfcode{all}}{}{}
Get an analysis\_task\_list of all current analysis\_base objects
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
New analysis\_task\_list of all current analysis objects

\end{description}\end{quote}

\end{fulllineitems}

\index{analysis\_identifiers\_unique() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.analysis_identifiers_unique}\pysiglinewithargsret{\bfcode{analysis\_identifiers\_unique}}{}{}
Check whether all identifiers of the analyses in the this list are unique.
:return: bool

\end{fulllineitems}

\index{append() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.append}\pysiglinewithargsret{\bfcode{append}}{\emph{analysis\_object}}{}
Add a given analysis to the set of object to be executed by the workflow

This is the same as set.add() but we ensure that only analysis\_base objects
are added.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} ({\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\emph{\texttt{omsi.analysis.base.analysis\_base}}}}}) -- Analysis object to be added to the execution.
All dependencies of the analysis will also be executed as part of the
execution.

\item[{Raises}] \leavevmode
ValueError is raised if the given analysis\_object is invalid

\end{description}\end{quote}

\end{fulllineitems}

\index{clear() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.clear}\pysiglinewithargsret{\bfcode{clear}}{}{}
Remove all elements from the list

\end{fulllineitems}

\index{enable\_memory\_profiling() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.enable_memory_profiling}\pysiglinewithargsret{\bfcode{enable\_memory\_profiling}}{\emph{enable=True}}{}
Enable or disable line-by-line profiling of memory usage of execute\_analysis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{enable\_memory}} (\emph{\texttt{bool}}) -- Enable (True) or disable (False) line-by-line profiling of memory usage

\item[{Raises}] \leavevmode
ImportError is raised if a required package for profiling is not available.

\end{description}\end{quote}

\end{fulllineitems}

\index{enable\_time\_and\_usage\_profiling() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.enable_time_and_usage_profiling}\pysiglinewithargsret{\bfcode{enable\_time\_and\_usage\_profiling}}{\emph{enable=True}}{}
Enable or disable profiling of time and usage of code parts of execute\_analysis for all analyses.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{enable}} (\emph{\texttt{bool}}) -- Enable (True) or disable (False) profiling

\item[{Raises}] \leavevmode
ImportError is raised if a required package for profiling is not available.

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_script\_files() (omsi.workflow.common.analysis\_task\_list class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.from_script_files}\pysiglinewithargsret{\strong{classmethod }\bfcode{from\_script\_files}}{\emph{script\_files}}{}
Same as from\_script, but the script is read from the given files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{script\_files}} -- List of strings with the paths to the script files. If only a single
script is used, then a single string may be used as well.

\item[{Returns}] \leavevmode
An instance of workflow\_base with the specification of the workflow to be executed

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_scripts() (omsi.workflow.common.analysis\_task\_list class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.from_scripts}\pysiglinewithargsret{\strong{classmethod }\bfcode{from\_scripts}}{\emph{scripts}}{}
Evaluate the workflow script to extract all analyses to be run.

NOTE: This function executes using eval(..), i.e., there are NO safeguards against malicious codes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{scripts}} -- The script with the setup of the workflow. This should only include
the definition of analyses and their inputs.

\item[{Returns}] \leavevmode
An instance of workflow\_base with the specification of the workflow to be executed

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_additional\_analysis\_dependencies() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.get_additional_analysis_dependencies}\pysiglinewithargsret{\bfcode{get\_additional\_analysis\_dependencies}}{}{}
Compute a list of all dependencies of the current list of analyses (excluding analyses that
are already in the the list of tasks.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
analysis\_task\_list of all analysis dependencies

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_analysis\_data() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.get_all_analysis_data}\pysiglinewithargsret{\bfcode{get\_all\_analysis\_data}}{}{}
Get a list of all output data objects for all analysis
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of omsi.analysis.analysis\_data.analysis\_data objects, one for each analysis

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_analysis\_identifiers() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.get_all_analysis_identifiers}\pysiglinewithargsret{\bfcode{get\_all\_analysis\_identifiers}}{}{}
Get a list of all analysis identifiers
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of strings with the analysis identifier of each analysis

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_dependency\_data() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.get_all_dependency_data}\pysiglinewithargsret{\bfcode{get\_all\_dependency\_data}}{}{}
Get the complete list of all direct and indirect dependencies of all analysis tasks.

NOTE: These are only the direct dependencies as specified by the analysis itself.
Use  get\_all\_dependency\_data\_recursive(..) to also get the indirect dependencies of
the analysis due to dependencies of the dependencies themselves.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of parameter\_data objects that define dependencies.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_parameter\_data() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.get_all_parameter_data}\pysiglinewithargsret{\bfcode{get\_all\_parameter\_data}}{\emph{exclude\_dependencies=False}}{}
Get the complete list of all parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{exclude\_dependencies}} -- Boolean indicating whether we should exclude parameters
that define dependencies from the list

\item[{Returns}] \leavevmode
List of omsi.analysis.analysis\_data.parameter\_data objects with the description of the parameters

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_all\_run\_info() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.get_all_run_info}\pysiglinewithargsret{\bfcode{get\_all\_run\_info}}{}{}
Get a list of dict with the complete info about the last run of each of the analysis analysis
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
List of run\_info\_dict objects, one for each analysis

\end{description}\end{quote}

\end{fulllineitems}

\index{insert() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.insert}\pysiglinewithargsret{\bfcode{insert}}{\emph{index}, \emph{analysis\_object}}{}
Insert a given analysis object at the given location
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{index}} -- Location where the obejct should be inserted

\item {} 
\textbf{\texttt{analysis\_object}} -- The analysis object to be inserted

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{make\_analysis\_identifiers\_unique() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.make_analysis_identifiers_unique}\pysiglinewithargsret{\bfcode{make\_analysis\_identifiers\_unique}}{}{}
Update analysis identifiers to be unique.

Side effects: This function updates the analysis tasks stored in the set
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
self, i.e., the modified object with identifiers updated

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_undefined\_analysis\_identifiers() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.set_undefined_analysis_identifiers}\pysiglinewithargsret{\bfcode{set\_undefined\_analysis\_identifiers}}{}{}
Check that all analysis descriptors are set to a value different than ``undefined'' and
set the descriptor based on their index in the list if necessary.

\end{fulllineitems}

\index{update() (omsi.workflow.common.analysis\_task\_list method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow:omsi.workflow.common.analysis_task_list.update}\pysiglinewithargsret{\bfcode{update}}{\emph{analysis\_objects}}{}
Return the set with elements added from the given set of analysis\_objects.

This is the same as set.update() but we ensure that only analysis\_base objects
are added.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_objects}} -- List or set of analysis\_base objects to be added to workflow set

\item[{Raise}] \leavevmode
ValueError is raised in case that objects that are not instances of analysis\_base are to be added.

\item[{Returns}] \leavevmode
self with elements added to self.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Subpackages}
\label{omsi.workflow:subpackages}

\paragraph{driver Package}
\label{omsi.workflow.driver:driver-package}\label{omsi.workflow.driver::doc}

\subparagraph{\texttt{driver} Package}
\label{omsi.workflow.driver:id1}\phantomsection\label{omsi.workflow.driver:module-omsi.workflow.driver}\index{omsi.workflow.driver (module)}
Package with drivers for analyses and workflows. Drivers are intented to control the set up
---i.e., creation and initialization---of workflows. The execution of workflows itself is typically
performed by a workflow executor.


\subparagraph{\texttt{base} Module}
\label{omsi.workflow.driver:module-omsi.workflow.driver.base}\label{omsi.workflow.driver:base-module}\index{omsi.workflow.driver.base (module)}
Module with base classes for workflow drivers.

Workflow drivers are responsible for the creation and initialization of workflows. The execution
of workflows is then controlled by the workflow executor.
\index{analysis\_driver\_base (class in omsi.workflow.driver.base)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.base.analysis_driver_base}\pysiglinewithargsret{\strong{class }\code{omsi.workflow.driver.base.}\bfcode{analysis\_driver\_base}}{\emph{analysis\_class}}{}
Bases: {\hyperref[omsi.workflow.driver:omsi.workflow.driver.base.driver_base]{\emph{\code{omsi.workflow.driver.base.driver\_base}}}}

Base class defining the minimal interface for drivers of a single analysis based on the type/class of the analysis.

This is a class-based execution, i.e, the user defines only the type of analysis and inputs but does not actually
create the analysis.

Derived classes must implement the main(...) function where the analysis is created and executed.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{analysis\_class}} -- The analysis class for which we want to execute the analysis.
The analysis class must derive from omsi.analysis.analysis\_base. May be None
in case that we use other means to set the analysis\_class, e.g., via the
command-line.

\end{description}\end{quote}

Initialize the analysis driver
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{analysis\_class}} -- The analysis class for which we want to execute the analysis.
The analysis class must derive from omsi.analysis.analysis\_base. May be None
in case that we use other means to set the analysis\_class, e.g., via the
command-line.

\end{description}\end{quote}
\index{main() (omsi.workflow.driver.base.analysis\_driver\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.base.analysis_driver_base.main}\pysiglinewithargsret{\bfcode{main}}{}{}
The main function for running the analysis.

\end{fulllineitems}


\end{fulllineitems}

\index{driver\_base (class in omsi.workflow.driver.base)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.base.driver_base}\pysigline{\strong{class }\code{omsi.workflow.driver.base.}\bfcode{driver\_base}}
Bases: \code{object}

Primitve base class for driving the execution of an object
\index{execute() (omsi.workflow.driver.base.driver\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.base.driver_base.execute}\pysiglinewithargsret{\bfcode{execute}}{}{}
Same as main

\end{fulllineitems}

\index{main() (omsi.workflow.driver.base.driver\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.base.driver_base.main}\pysiglinewithargsret{\bfcode{main}}{}{}
The main function for running the analysis.

\end{fulllineitems}


\end{fulllineitems}

\index{workflow\_driver\_base (class in omsi.workflow.driver.base)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.base.workflow_driver_base}\pysiglinewithargsret{\strong{class }\code{omsi.workflow.driver.base.}\bfcode{workflow\_driver\_base}}{\emph{workflow\_executor}}{}
Bases: \code{object}

Base class defining the minimal interface for drivers of complex analysis workflows.

Workflows may be specified via scripts or given via a set of analysis objects.

Derived classes must implement the main(...) function where the analysis is created and executed.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{workflow\_executor}} -- The executor of the workflow.

\end{description}\end{quote}

Initalize the workflow driver
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{workflow\_executor}} -- The executor of the workflow we want to drive.

\end{description}\end{quote}
\index{main() (omsi.workflow.driver.base.workflow\_driver\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.base.workflow_driver_base.main}\pysiglinewithargsret{\bfcode{main}}{}{}
The main function for running the analysis.

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{\texttt{cl\_analysis\_driver} Module}
\label{omsi.workflow.driver:module-omsi.workflow.driver.cl_analysis_driver}\label{omsi.workflow.driver:cl-analysis-driver-module}\index{omsi.workflow.driver.cl\_analysis\_driver (module)}
Module used to help with driving the execution of omsi-based analyses.
\index{cl\_analysis\_driver (class in omsi.workflow.driver.cl\_analysis\_driver)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver}\pysiglinewithargsret{\strong{class }\code{omsi.workflow.driver.cl\_analysis\_driver.}\bfcode{cl\_analysis\_driver}}{\emph{analysis\_class}, \emph{add\_analysis\_class\_arg=False}, \emph{add\_output\_arg=True}, \emph{add\_log\_level\_arg=True}}{}
Bases: {\hyperref[omsi.workflow.driver:omsi.workflow.driver.base.analysis_driver_base]{\emph{\code{omsi.workflow.driver.base.analysis\_driver\_base}}}}

Command-line analysis driver.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver.analysis_class_arg_name]{\emph{\textbf{\texttt{analysis\_class\_arg\_name}}}}} -- The name for the argument where the positional argument for defining the
analysis class should be stored.

\item {} 
{\hyperref[omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver.output_save_arg_name]{\emph{\textbf{\texttt{output\_save\_arg\_name}}}}} -- Name of the optional keyword argument for specifying the name
and target for the analysis

\item {} 
{\hyperref[omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver.analysis_class_arg_name]{\emph{\textbf{\texttt{analysis\_class\_arg\_name}}}}} -- Name of the optional first positional argument to be used
to define the analysis class to be used.

\item {} 
{\hyperref[omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.log_level_arg_name]{\emph{\textbf{\texttt{log\_level\_arg\_name}}}}} -- Name of the keyword cl argument to define the level of logging ot be used.

\item {} 
\textbf{\texttt{analysis\_class}} -- The class (subclass of analysis\_base) defining the analysis to be executed

\item {} 
\textbf{\texttt{analysis\_object}} -- Instance of the analysis object to be executed

\item {} 
\textbf{\texttt{add\_analysis\_class\_arg}} -- Boolean indicating whether an optional positional command line argument
should be used to determine the analysis class (or whether the analysis class will be set explicitly)

\item {} 
\textbf{\texttt{add\_output\_arg}} -- Boolean indicating whether an optional keyword argument should be added to define
the output target for the analysis.

\item {} 
\textbf{\texttt{add\_log\_level\_arg}} -- Boolean indicating whether the --loglevel argument should be added to the command line

\item {} 
\textbf{\texttt{parser}} -- The argparse.ArgumentParser instance used for defining command-line arguments

\item {} 
\textbf{\texttt{required\_argument\_group}} -- argparse.ArgumentParser argument group used to define required command line arguments

\item {} 
\textbf{\texttt{custom\_argument\_groups}} -- Dict of custom argparse.ArgumentParser argument groups specified by the analysis

\item {} 
\textbf{\texttt{output\_target}} -- Specification of the output target where the analysis result should be stored

\item {} 
\textbf{\texttt{analysis\_arguments}} -- Dictionary defining the input arguments to be used for the analysis

\item {} 
\textbf{\texttt{mpi\_root}} -- Integer indicating the root rank when running using MPI

\item {} 
\textbf{\texttt{mpi\_comm}} -- Integer indicating the MPI communicator to be used when running in parallel using MPI

\end{itemize}

\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_class}} ({\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\emph{\texttt{omsi.analysis.base.analysis\_base}}}}}) -- The analysis class for which we want to execute the analysis.
The analysis class must derive from omsi.analysis.analysis\_base. May be None
in case that we use the command-line to define the analysis class via the optional
positional argument for the command class (i.e., set add\_analysis\_class\_arg to True).

\item {} 
\textbf{\texttt{add\_analysis\_class\_arg}} -- Boolean indicating whether we will use the positional
command-line argument to determine the analysis class name

\item {} 
\textbf{\texttt{add\_output\_arg}} -- Boolean indicating whether we should add the optional keyword
argument for defining the output target for the analysis.

\item {} 
\textbf{\texttt{add\_log\_level\_arg}} -- Boolean indicating wither we should add the option keyword argument to specify the
logging level via the command line.

\end{itemize}

\item[{Raises}] \leavevmode
A ValueError is raised in the case of conflicting inputs, i.e., if
i) analysis\_class==None and add\_analysis\_class\_arg=False, i.e., the analysis class is not determined or
ii) analysis\_class!=None and add\_analysis\_class\_arg=False, i.e, the analysis class is determined
via two separate mechanisms.

\end{description}\end{quote}
\index{add\_and\_parse\_analysis\_arguments() (omsi.workflow.driver.cl\_analysis\_driver.cl\_analysis\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver.add_and_parse_analysis_arguments}\pysiglinewithargsret{\bfcode{add\_and\_parse\_analysis\_arguments}}{}{}
The function assumes that the command line parser has been setup using the initialize\_argument\_parser(..)

This function is responsible for adding all command line arguments that are specific to the analysis and
to then parse those argument and save the relevant data in the self.analysis\_arguments dictionary.
Command-line arguments that are specific to the command line driver are removed, so that only
arguments that can be consumed by the analysis are handed to the analysis.

\emph{Side effects:} The function sets \code{self.analysis\_arguments}

\end{fulllineitems}

\index{analysis\_class\_arg\_name (omsi.workflow.driver.cl\_analysis\_driver.cl\_analysis\_driver attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver.analysis_class_arg_name}\pysigline{\bfcode{analysis\_class\_arg\_name}\strong{ = `\_\_analysis\_class'}}
The name where the positional argument for defining the analysis class will be stored.

\end{fulllineitems}

\index{create\_analysis\_object() (omsi.workflow.driver.cl\_analysis\_driver.cl\_analysis\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver.create_analysis_object}\pysiglinewithargsret{\bfcode{create\_analysis\_object}}{}{}
Initialize the analysis object, i.e., set self.analysis\_object

\end{fulllineitems}

\index{get\_analysis\_class\_from\_cl() (omsi.workflow.driver.cl\_analysis\_driver.cl\_analysis\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver.get_analysis_class_from_cl}\pysiglinewithargsret{\bfcode{get\_analysis\_class\_from\_cl}}{}{}
Internal helper function used to get the analysis class object based on the
analysis\_class\_arg\_name positional argument from the command line.

\emph{Side effects:} The function sets {\color{red}\bfseries{}{}`{}`}self.analysis\_class{}`
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
ImportError in case that the analysis module cannot be loaded

\item[{Raises}] \leavevmode
AttributeError in case that the analysis class cannot be extracted from the module

\end{description}\end{quote}

\end{fulllineitems}

\index{initialize\_argument\_parser() (omsi.workflow.driver.cl\_analysis\_driver.cl\_analysis\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver.initialize_argument_parser}\pysiglinewithargsret{\bfcode{initialize\_argument\_parser}}{}{}
Internal helper function used to initialize the argument parser.
NOTE: self.analysis\_class must be set before calling this function.

\emph{Side effects:} The function sets \code{self.parser} and \code{self.required\_argument\_group}

\end{fulllineitems}

\index{log\_level\_arg\_name (omsi.workflow.driver.cl\_analysis\_driver.cl\_analysis\_driver attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver.log_level_arg_name}\pysigline{\bfcode{log\_level\_arg\_name}\strong{ = `loglevel'}}
Name of the keyword argument used to specify the level of logging to be used

\end{fulllineitems}

\index{main() (omsi.workflow.driver.cl\_analysis\_driver.cl\_analysis\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver.main}\pysiglinewithargsret{\bfcode{main}}{}{}
Default main function for running an analysis from the command line.
The default implementation exposes all specified analysis parameters as command
line options to the user. The default implementation also provides means to
print a help text for the function.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
ValueError is raised in case that the analysis class is unknown

\end{description}\end{quote}

\end{fulllineitems}

\index{output\_save\_arg\_name (omsi.workflow.driver.cl\_analysis\_driver.cl\_analysis\_driver attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver.output_save_arg_name}\pysigline{\bfcode{output\_save\_arg\_name}\strong{ = `save'}}
Name of the key-word argument used to define

\end{fulllineitems}

\index{parse\_cl\_arguments() (omsi.workflow.driver.cl\_analysis\_driver.cl\_analysis\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver.parse_cl_arguments}\pysiglinewithargsret{\bfcode{parse\_cl\_arguments}}{}{}
The function assumes that the command line parser has been setup using the initialize\_argument\_parser(..)

This function parses all arguments that are specific to the command-line parser itself. Analysis
arguments are added and parsed later by the add\_and\_parse\_analysis\_arguments(...) function.
The reason for this is two-fold: i) to separate the parsing of analysis arguments and arguments of the
command-line driver and ii) if the same HDF5 file is used as input and output target, then we need to
open it first here in append mode before it gets opened in read mode later by the arguments.

\emph{Side effects:} The function sets \code{self.output\_target} and \code{self.profile\_analysis}

\end{fulllineitems}

\index{print\_settings() (omsi.workflow.driver.cl\_analysis\_driver.cl\_analysis\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver.print_settings}\pysiglinewithargsret{\bfcode{print\_settings}}{}{}
Print the analysis settings.

\end{fulllineitems}

\index{remove\_output\_target() (omsi.workflow.driver.cl\_analysis\_driver.cl\_analysis\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver.remove_output_target}\pysiglinewithargsret{\bfcode{remove\_output\_target}}{}{}
This function is used to delete any output target files created by the
command line driver. This is done in case that an error occurred and
we do not want to leave garbage files left over.

\emph{Side effects} The function modifies \code{self.output\_target}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Boolean indicating whether we succesfully cleaned up the output

\end{description}\end{quote}

\end{fulllineitems}

\index{reset\_analysis\_object() (omsi.workflow.driver.cl\_analysis\_driver.cl\_analysis\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver.reset_analysis_object}\pysiglinewithargsret{\bfcode{reset\_analysis\_object}}{}{}
Clear the analysis object and recreate it, i.e., delete self.analysis\_object and set it again.

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{\texttt{cl\_workflow\_driver} Module}
\label{omsi.workflow.driver:cl-workflow-driver-module}\label{omsi.workflow.driver:module-omsi.workflow.driver.cl_workflow_driver}\index{omsi.workflow.driver.cl\_workflow\_driver (module)}
Module used to help with driving the execution of analysis workflows
\index{cl\_workflow\_driver (class in omsi.workflow.driver.cl\_workflow\_driver)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver}\pysiglinewithargsret{\strong{class }\code{omsi.workflow.driver.cl\_workflow\_driver.}\bfcode{cl\_workflow\_driver}}{\emph{workflow\_executor=None}, \emph{add\_script\_arg=False}, \emph{add\_output\_arg=True}, \emph{add\_log\_level\_arg=True}, \emph{add\_profile\_arg=False}, \emph{add\_mem\_profile\_arg=False}}{}
Bases: {\hyperref[omsi.workflow.driver:omsi.workflow.driver.base.workflow_driver_base]{\emph{\code{omsi.workflow.driver.base.workflow\_driver\_base}}}}

Command-line workflow driver.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.script_arg_name]{\emph{\textbf{\texttt{script\_arg\_name}}}}} -- Name of the optional keyword cl argument for defining workflow scripts to be executed

\item {} 
{\hyperref[omsi.workflow.driver:omsi.workflow.driver.cl_analysis_driver.cl_analysis_driver.output_save_arg_name]{\emph{\textbf{\texttt{output\_save\_arg\_name}}}}} -- Name of the optional keyword argument for specifying the name
and target for the workflow. This may be a folder or an HDF5 file ending with .h5

\item {} 
{\hyperref[omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.profile_arg_name]{\emph{\textbf{\texttt{profile\_arg\_name}}}}} -- Name of the keyword argument used to enable profiling of the analysis

\item {} 
{\hyperref[omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.profile_mem_arg_name]{\emph{\textbf{\texttt{profile\_mem\_arg\_name}}}}} -- Name of the keyword argument used to enable profiling of memory usage of an analysis

\item {} 
{\hyperref[omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.log_level_arg_name]{\emph{\textbf{\texttt{log\_level\_arg\_name}}}}} -- Name of the keyword cl argument to define the level of logging ot be used.

\item {} 
\textbf{\texttt{workflow\_executor}} -- The workflow executor object used to execute the analysis workflow.
The workflow executor must derive from omsi.workflow.executor.base.workflow\_executor\_base.
May be None in case that we use the command-line to define workflow executor or if the
default executor should be used. The default executur class is defined by
omsi.workflow.executor.base.workflow\_executor\_base.

\item {} 
\textbf{\texttt{script\_files}} -- List of strings with the paths to files with workflow scripts to be executed.

\item {} 
\textbf{\texttt{add\_script\_arg}} -- Boolean indicating whether the --script keyword argument should be added to the
command-line, to define the workflow scripts via the CL (or whether the scripts will be set explicitly)

\item {} 
\textbf{\texttt{add\_output\_arg}} -- Boolean indicating whether an optional keyword argument should be added to define
the output target for the analysis.

\item {} 
\textbf{\texttt{add\_profile\_arg}} -- Add the optional --profile keyword argument for profiling the analysis

\item {} 
\textbf{\texttt{add\_mem\_profile\_arg}} -- Boolean indicating whether we should add the optional
keyword argument for enabling memory profiling of the analysis.

\item {} 
\textbf{\texttt{add\_log\_level\_arg}} -- Boolean indicating wither we should add the option keyword argument to specify the
logging level via the command line.

\item {} 
\textbf{\texttt{parser}} -- The argparse.ArgumentParser instance used for defining command-line arguments

\item {} 
\textbf{\texttt{required\_argument\_group}} -- argparse.ArgumentParser argument group used to define required command line arguments

\item {} 
\textbf{\texttt{optional\_argument\_group}} -- argparse.ArgumentParser argument group used to define optional command line arguments

\item {} 
\textbf{\texttt{custom\_argument\_groups}} -- Dict of custom argparse.ArgumentParser argument groups specified by the analysis

\item {} 
\textbf{\texttt{identifier\_argname\_seperator}} -- String used to seperate the analysis identifier and argument name when
creating custom command-line options for the individual analyses of the workflow

\item {} 
\textbf{\texttt{output\_target}} -- Specification of the output target where the analysis result should be stored

\item {} 
\textbf{\texttt{profile\_analyses}} -- Boolean indicating whether we should profile the analysis for time and usage

\item {} 
\textbf{\texttt{profile\_analyses\_mem}} -- Boolean indicating whether we should profile the memory usage of the individual analyses

\item {} 
\textbf{\texttt{analysis\_arguments}} -- Dictionary defining the custom input arguments to be used for the analysis

\item {} 
\textbf{\texttt{workflow\_executor\_arguments}} -- Dictionary defining the custom input arguments routed to the workflow executor

\item {} 
\textbf{\texttt{\_\_output\_target\_self}} -- Private member variable used to store the output files created by this object.

\item {} 
\textbf{\texttt{user\_log\_level}} -- The custom logging level specified by the user (or None)

\item {} 
\textbf{\texttt{mpi\_root}} -- The root rank used when running in parallel

\item {} 
\textbf{\texttt{mpi\_comm}} -- The mpit communicator to be used when running in parallel

\end{itemize}

\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{workflow\_executor}} ({\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\emph{\texttt{omsi.analysis.base.analysis\_base}}}}}) -- The workflow executor object used to execute the analysis workflow.
The workflow executor must derive from omsi.workflow.executor.base.workflow\_executor\_base.
May be None in case that we use the command-line to define workflow executor or if the
default executor should be used. The default executur class is defined by
omsi.workflow.executor.base.workflow\_executor\_base.

\item {} 
\textbf{\texttt{add\_script\_arg}} -- Boolean indicating whether the --script keyword argument should be added to the
command-line, to define the workflow scripts via the CL (or whether the scripts will be set explicitly)

\item {} 
\textbf{\texttt{add\_output\_arg}} -- Boolean indicating whether we should add the optional keyword
argument for defining the output target for the analysis.

\item {} 
\textbf{\texttt{add\_log\_level\_arg}} -- Boolean indicating wither we should add the option keyword argument to specify the

\end{itemize}

\end{description}\end{quote}

logging level via the command line.
:param add\_profile\_arg: Boolean indicating whether we should add the optional keyword
\begin{quote}

argument for enabling profiling of the analysis.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{add\_mem\_profile\_arg}} -- Boolean indicating whether we should add the optional
keyword argument for enabling memory profiling of the analysis.

\item[{Raises}] \leavevmode
A ValueError is raised in the case of conflicting inputs, i.e., if
i) workflow\_executor==None and add\_script\_arg=False, i.e., the analysis class is not determined or
ii) workflow\_executor!=None and add\_script\_arg=False, i.e, the analysis class is determined
via two separate mechanisms.

\end{description}\end{quote}
\index{add\_and\_parse\_workflow\_arguments() (omsi.workflow.driver.cl\_workflow\_driver.cl\_workflow\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.add_and_parse_workflow_arguments}\pysiglinewithargsret{\bfcode{add\_and\_parse\_workflow\_arguments}}{}{}
The function assumes that the command line parser has been setup using the initialize\_argument\_parser(..)

This function is responsible for adding all command line arguments that are specific to the workflow and
to then parse those arguments and save the relevant data in the self.analysis\_arguments dictionary.
Command-line arguments that are specific to the command line driver are removed, so that only
arguments that can be consumed by the analysis are handed to the analysis.
\begin{description}
\item[{\emph{Side effects:} The function sets \code{self.analysis\_arguments} and updates the analysis parameters of the}] \leavevmode
analyses stored in \code{self.workflow\_executor.analysis\_tasks}

\end{description}

\end{fulllineitems}

\index{create\_workflow\_executor\_object() (omsi.workflow.driver.cl\_workflow\_driver.cl\_workflow\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.create_workflow_executor_object}\pysiglinewithargsret{\bfcode{create\_workflow\_executor\_object}}{}{}
Initialize the workflow executor object, i.e., set self.workflow\_executor

\emph{Side effects} This function potentially modifies self.workflow\_executor

\end{fulllineitems}

\index{initialize\_argument\_parser() (omsi.workflow.driver.cl\_workflow\_driver.cl\_workflow\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.initialize_argument_parser}\pysiglinewithargsret{\bfcode{initialize\_argument\_parser}}{}{}
Internal helper function used to initialize the argument parser.

\emph{Side effects:} The function sets:
\begin{itemize}
\item {} 
\code{self.parser}

\item {} 
\code{self.required\_argument\_group}

\item {} 
\code{self.opitonal\_argument\_group}

\end{itemize}

\end{fulllineitems}

\index{log\_level\_arg\_name (omsi.workflow.driver.cl\_workflow\_driver.cl\_workflow\_driver attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.log_level_arg_name}\pysigline{\bfcode{log\_level\_arg\_name}\strong{ = `loglevel'}}
Name of the keyword argument used to specify the level of logging to be used

\end{fulllineitems}

\index{main() (omsi.workflow.driver.cl\_workflow\_driver.cl\_workflow\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.main}\pysiglinewithargsret{\bfcode{main}}{}{}
Default main function for running an analysis from the command line.
The default implementation exposes all specified analysis parameters as command
line options to the user. The default implementation also provides means to
print a help text for the function.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
ValueError is raised in case that the analysis class is unknown

\end{description}\end{quote}

\end{fulllineitems}

\index{output\_save\_arg\_name (omsi.workflow.driver.cl\_workflow\_driver.cl\_workflow\_driver attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.output_save_arg_name}\pysigline{\bfcode{output\_save\_arg\_name}\strong{ = `save'}}
Name of the key-word argument used to define

\end{fulllineitems}

\index{parse\_cl\_arguments() (omsi.workflow.driver.cl\_workflow\_driver.cl\_workflow\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.parse_cl_arguments}\pysiglinewithargsret{\bfcode{parse\_cl\_arguments}}{}{}
The function assumes that the command line parser has been setup using the initialize\_argument\_parser(..)

This function parses all arguments that are specific to the command-line parser itself. Analysis workflow
arguments are added and parsed later by the add\_and\_parse\_workflow\_arguments(...) function.
The reason for this is two-fold: i) to separate the parsing of analysis arguments and arguments of the
command-line driver and ii) if the same HDF5 file is used as input and output target, then we need to
open it first here in append mode before it gets opened in read mode later by the arguments.

\emph{Side effects:} The function sets:
\begin{itemize}
\item {} 
\code{self.output\_target}

\item {} 
\code{self.profile\_analyses}

\end{itemize}

\end{fulllineitems}

\index{print\_memory\_profiles() (omsi.workflow.driver.cl\_workflow\_driver.cl\_workflow\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.print_memory_profiles}\pysiglinewithargsret{\bfcode{print\_memory\_profiles}}{}{}
Print the memory profiles if available

\end{fulllineitems}

\index{print\_settings() (omsi.workflow.driver.cl\_workflow\_driver.cl\_workflow\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.print_settings}\pysiglinewithargsret{\bfcode{print\_settings}}{}{}
Print the analysis settings.

\end{fulllineitems}

\index{print\_time\_and\_usage\_profiles() (omsi.workflow.driver.cl\_workflow\_driver.cl\_workflow\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.print_time_and_usage_profiles}\pysiglinewithargsret{\bfcode{print\_time\_and\_usage\_profiles}}{}{}
Print the profiling data for time and usage if available

\end{fulllineitems}

\index{profile\_arg\_name (omsi.workflow.driver.cl\_workflow\_driver.cl\_workflow\_driver attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.profile_arg_name}\pysigline{\bfcode{profile\_arg\_name}\strong{ = `profile'}}
Name of the keyword argument used to enable profiling of the analysis

\end{fulllineitems}

\index{profile\_mem\_arg\_name (omsi.workflow.driver.cl\_workflow\_driver.cl\_workflow\_driver attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.profile_mem_arg_name}\pysigline{\bfcode{profile\_mem\_arg\_name}\strong{ = `memprofile'}}
Name of the keyword argument used to enable profiling of memory usage of an analysis

\end{fulllineitems}

\index{remove\_output\_target() (omsi.workflow.driver.cl\_workflow\_driver.cl\_workflow\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.remove_output_target}\pysiglinewithargsret{\bfcode{remove\_output\_target}}{}{}
This function is used to delete any output target files created by the
command line driver. This is done in case that an error occurred and
we do not want to leave garbage files left over.

\emph{Side effects} The function modifies \code{self.output\_target}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Boolean indicating whether we succesfully cleaned up the output

\end{description}\end{quote}

\end{fulllineitems}

\index{reset\_workflow\_executor\_object() (omsi.workflow.driver.cl\_workflow\_driver.cl\_workflow\_driver method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.reset_workflow_executor_object}\pysiglinewithargsret{\bfcode{reset\_workflow\_executor\_object}}{}{}
Remove and recreate the workflow executor object

\end{fulllineitems}

\index{script\_arg\_name (omsi.workflow.driver.cl\_workflow\_driver.cl\_workflow\_driver attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.driver:omsi.workflow.driver.cl_workflow_driver.cl_workflow_driver.script_arg_name}\pysigline{\bfcode{script\_arg\_name}\strong{ = `script'}}
The name where the positional argument for defining the analysis class will be stored.

\end{fulllineitems}


\end{fulllineitems}



\paragraph{executor Package}
\label{omsi.workflow.executor:executor-package}\label{omsi.workflow.executor::doc}

\subparagraph{\texttt{executor} Package}
\label{omsi.workflow.executor:id1}\phantomsection\label{omsi.workflow.executor:module-omsi.workflow.executor}\index{omsi.workflow.executor (module)}
Package with executors of analysis workflows. Executors perform and control the execution of workflows.
The setup of workflows is often performed by the user or via dedicated workflow drivers.


\subparagraph{\texttt{base} Module}
\label{omsi.workflow.executor:module-omsi.workflow.executor.base}\label{omsi.workflow.executor:base-module}\index{omsi.workflow.executor.base (module)}
Module containing base classes for workflow executors.

Workflow executors control the execution of workflows. The setup of workflows is often controlled
either by a workflow driver or the user.
\index{workflow\_executor\_base (class in omsi.workflow.executor.base)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base}\pysiglinewithargsret{\strong{class }\code{omsi.workflow.executor.base.}\bfcode{workflow\_executor\_base}}{\emph{analysis\_objects=None}}{}
Bases: {\hyperref[omsi.datastructures:omsi.datastructures.analysis_data.parameter_manager]{\emph{\code{omsi.datastructures.analysis\_data.parameter\_manager}}}}

Base class used to execute a workflow of one or many analyses. This is an object-based execution,
i.e., the user defines a set of analyses to be executed.

We are given a set of existing analysis objects for which we need to coordinate the execution.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_objects}} -- Private set of analysis objects to be executed

\item {} 
{\hyperref[omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base.DEFAULT_EXECUTOR_CLASS]{\emph{\textbf{\texttt{DEFAULT\_EXECUTOR\_CLASS}}}}} -- Define the derived workflow\_executor\_base class to be used as default executor
The default value is None, in which case the greedy\_workflow\_executor is used. This variable is used
by the get\_default\_executor function to instantiate a  default workflow executor on request. Using this
variable we can change the default executor to our own preferred executor, e.g., to change the executor
used by the omsi.analysis.base.analysis\_base functions execute\_all(...) and execute\_recursive(...)

\end{itemize}

\end{description}\end{quote}

To implement a derived workflow executor, we need to implement a derived class that implements the main()
function.

Initialize the workflow executor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_objects}} -- A list of analysis objects to be executed

\end{description}\end{quote}
\index{DEFAULT\_EXECUTOR\_CLASS (omsi.workflow.executor.base.workflow\_executor\_base attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base.DEFAULT_EXECUTOR_CLASS}\pysigline{\bfcode{DEFAULT\_EXECUTOR\_CLASS}\strong{ = None}}
The default executor class to be used

\end{fulllineitems}

\index{add\_analysis() (omsi.workflow.executor.base.workflow\_executor\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base.add_analysis}\pysiglinewithargsret{\bfcode{add\_analysis}}{\emph{analysis\_object}}{}
Add a given analysis to the set of object to be executed by the workflow

Shorthand for: self.analysis\_tasks.add(analysis\_object)

\end{fulllineitems}

\index{add\_analysis\_all() (omsi.workflow.executor.base.workflow\_executor\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base.add_analysis_all}\pysiglinewithargsret{\bfcode{add\_analysis\_all}}{}{}
Add all known analyses to the workflow.

Shorthand for: self.analysis\_tasks.add\_analysis\_all()

\end{fulllineitems}

\index{add\_analysis\_dependencies() (omsi.workflow.executor.base.workflow\_executor\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base.add_analysis_dependencies}\pysiglinewithargsret{\bfcode{add\_analysis\_dependencies}}{}{}
Add the dependencies of all analyses to the workflow in case they are missing.

This function is recursive, step-by-step adding all dependencies of the workflow to the list of
tasks to be executed, until no more dependencies are found.

Usually this function is called by the workflow executor itself before running the analysis and
should not need to be called by the user.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Integer indicating the number of dependencies added to the list of tasks

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_analysis\_from\_scripts() (omsi.workflow.executor.base.workflow\_executor\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base.add_analysis_from_scripts}\pysiglinewithargsret{\bfcode{add\_analysis\_from\_scripts}}{\emph{script\_files}}{}
Evaluate the list of scripts and add all (i.e., zero, one, or multiple) analyses to this workflow

NOTE: This function executes scripts using exec(..), i.e., there are NO safeguards against malicious codes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{script\_files}} -- List of strings with the paths to the script files. If only a single
script is used, then a single string may be used as well.

\end{description}\end{quote}

\end{fulllineitems}

\index{clear() (omsi.workflow.executor.base.workflow\_executor\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base.clear}\pysiglinewithargsret{\bfcode{clear}}{}{}
Remove all analyses from the workflow.

Shorthand for: self.analysis\_tasks.clear()

\end{fulllineitems}

\index{execute() (omsi.workflow.executor.base.workflow\_executor\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base.execute}\pysiglinewithargsret{\bfcode{execute}}{}{}
Execute the workflow. This uses the main() function to run the actual workflow.

\end{fulllineitems}

\index{from\_script\_files() (omsi.workflow.executor.base.workflow\_executor\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base.from_script_files}\pysiglinewithargsret{\strong{classmethod }\bfcode{from\_script\_files}}{\emph{script\_files}}{}
Same as from\_script, but the scripts are read from the given list of files.

NOTE: This function executes scripts using exec(..), i.e., there are NO safeguards against malicious codes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{script\_files}} -- List of strings with the paths to the script files. If only a single
script is used, then a single string may be used as well.

\item[{Returns}] \leavevmode
Instance of the current workflow executor class for running the given workflow

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_scripts() (omsi.workflow.executor.base.workflow\_executor\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base.from_scripts}\pysiglinewithargsret{\strong{classmethod }\bfcode{from\_scripts}}{\emph{scripts}}{}
Create and initalize a worklflow executor of the current class type to execute the workflow defined
in the given set of scripts.

This function using analysis\_task\_list.from\_scripts to evaluate the workflow scripts to extract all
analyses to be created.

NOTE: This function executes scripts using exec(..), i.e., there are NO safeguards against malicious codes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{scripts}} -- The script with the setup of the workflow. This should only include
the definition of analyses and their inputs.

\item[{Returns}] \leavevmode
Instance of the current workflow executor class for running the given workflow

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_analyses() (omsi.workflow.executor.base.workflow\_executor\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base.get_analyses}\pysiglinewithargsret{\bfcode{get\_analyses}}{}{}
Get the list of analyses to be run.

Shorthand for: self.analysis\_tasks

\end{fulllineitems}

\index{get\_analysis() (omsi.workflow.executor.base.workflow\_executor\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base.get_analysis}\pysiglinewithargsret{\bfcode{get\_analysis}}{\emph{index}}{}
Get the analysis with the given index
\begin{quote}

Shorthand for: self.analysis\_tasks{[}index{]}
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{index}} -- Integer index of the analysis

\item[{Returns}] \leavevmode
omsi.analysis.base.analysis\_base object

\item[{Raises}] \leavevmode
IndexError in case that the index is invalid

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_default\_executor() (omsi.workflow.executor.base.workflow\_executor\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base.get_default_executor}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_default\_executor}}{\emph{analysis\_objects=None}}{}
Create an instance of the default workflow executor to be used.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_objects}} -- A set or unique list of analysis objects to be executed by the workflow

\item[{Returns}] \leavevmode
Instance of the default workflow executor

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_default\_executor\_class() (omsi.workflow.executor.base.workflow\_executor\_base class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base.get_default_executor_class}\pysiglinewithargsret{\strong{classmethod }\bfcode{get\_default\_executor\_class}}{}{}
Get the default executor class
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Derived class of workflow\_executor\_base

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (omsi.workflow.executor.base.workflow\_executor\_base method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base.main}\pysiglinewithargsret{\bfcode{main}}{}{}
Implement the execution of the workflow. We should always call execute(..) or \_\_call\_\_(..) to run
the workflow. This function is intended to implementd the executor-specific exeuction behavior and
must be implemented in child classes.

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{\texttt{greedy\_executor} Module}
\label{omsi.workflow.executor:greedy-executor-module}\label{omsi.workflow.executor:module-omsi.workflow.executor.greedy_executor}\index{omsi.workflow.executor.greedy\_executor (module)}
Module used to help with the execution of complex analyses workflows
\index{greedy\_executor (class in omsi.workflow.executor.greedy\_executor)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.greedy_executor.greedy_executor}\pysiglinewithargsret{\strong{class }\code{omsi.workflow.executor.greedy\_executor.}\bfcode{greedy\_executor}}{\emph{analysis\_objects=None}}{}
Bases: {\hyperref[omsi.workflow.executor:omsi.workflow.executor.base.workflow_executor_base]{\emph{\code{omsi.workflow.executor.base.workflow\_executor\_base}}}}

Execute a set of analysis objects and their dependencies
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{run\_info}} -- The runtime information dictionary for the overall workflow

\item {} 
\textbf{\texttt{mpi\_comm}} -- The MPI communicator to be used when running in parallel

\item {} 
\textbf{\texttt{mpi\_root}} -- The MPI root rank when running in parallel

\end{itemize}

\end{description}\end{quote}

Additional parameters:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{reduce\_memory\_usage}} -- Boolean indicating whether we should reduce memory usage by pushing analysis
data to file after an analysis has been completed. This reduces the amount of data we keep in memory
but results in additional overhead for I/O and temporary disk storage.

\end{description}\end{quote}

Initalize the workflow driver
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_objects}} -- A list of analysis objects to be executed

\end{description}\end{quote}
\index{main() (omsi.workflow.executor.greedy\_executor.greedy\_executor method)}

\begin{fulllineitems}
\phantomsection\label{omsi.workflow.executor:omsi.workflow.executor.greedy_executor.greedy_executor.main}\pysiglinewithargsret{\bfcode{main}}{}{}
Execute the analysis workflow

\end{fulllineitems}


\end{fulllineitems}



\subsection{tools Package}
\label{omsi.tools:tools-package}\label{omsi.tools::doc}
\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


\code{omsi.tools}
 & 
Package for collecting tools (e.g,.
\\
\hline
{\hyperref[omsi.tools:module\string-omsi.tools.convertToOMSI]{\emph{\code{omsi.tools.convertToOMSI}}}}
 & 
Tool used to convert img files to OpenMSI HDF5 files.
\\
\hline
{\hyperref[omsi.tools:module\string-omsi.tools.run_analysis]{\emph{\code{omsi.tools.run\_analysis}}}}
 & 
Simple helper tool to run an analysis.
\\
\hline
\code{omsi.tools.run\_workflow}
 & 
Simple helper tool to run a workflow.
\\
\hline
{\hyperref[omsi.tools.misc:module\string-omsi.tools.misc]{\emph{\code{omsi.tools.misc}}}}
 & 
Collection of miscellaneous tools.
\\
\hline
{\hyperref[omsi.tools.misc:module\string-omsi.tools.misc.create_peak_cube_overview]{\emph{\code{omsi.tools.misc.create\_peak\_cube\_overview}}}}
 & 
Simple helper tool used to generate a set of PNG images for a global peak analysis (one per global peak) as well as a LaTeX document that summarizes all the images in a single document.
\\
\hline
{\hyperref[omsi.tools.misc:module\string-omsi.tools.misc.make_thumb]{\emph{\code{omsi.tools.misc.make\_thumb}}}}
 & 
Simple script to generate thumbnail images
\\
\hline
{\hyperref[omsi.tools.experimental:module\string-omsi.tools.experimental]{\emph{\code{omsi.tools.experimental}}}}
 & 
Collection of experimental tools and tools under development.
\\
\hline\end{longtable}



\subsubsection{\texttt{convertToOMSI} Module}
\label{omsi.tools:converttoomsi-module}\label{omsi.tools:module-omsi.tools.convertToOMSI}\index{omsi.tools.convertToOMSI (module)}
Tool used to convert img files to OpenMSI HDF5 files.

For usage information execute: python convertToOMSI --help
\index{ConvertFiles (class in omsi.tools.convertToOMSI)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertFiles}\pysigline{\strong{class }\code{omsi.tools.convertToOMSI.}\bfcode{ConvertFiles}}
Bases: \code{object}

Class providing a number of functions for converting various file types to OMSI,
including a number of helper functions related to the data conversion.
\index{check\_format() (omsi.tools.convertToOMSI.ConvertFiles static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertFiles.check_format}\pysiglinewithargsret{\strong{static }\bfcode{check\_format}}{\emph{name}, \emph{format\_type}}{}
Helper function used to determine the file format that should be used
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} -- Name of the folder/file that we should read

\item {} 
\textbf{\texttt{format\_type}} -- String indicating the format-option given by the user.
If the format is not determined (i.e., ``auto'') then this function
tries to determine the appropriate format. Otherwise this option
is returned as is, as the user explicitly said which format should
be used.

\end{itemize}

\item[{Returns}] \leavevmode
String indicating the appropriate format. Returns None in case no valid option was found.

\end{description}\end{quote}

\end{fulllineitems}

\index{convert\_files() (omsi.tools.convertToOMSI.ConvertFiles static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertFiles.convert_files}\pysiglinewithargsret{\strong{static }\bfcode{convert\_files}}{}{}
Convert all files in the given list of files with their approbriate conversion options

\end{fulllineitems}

\index{create\_dataset\_list() (omsi.tools.convertToOMSI.ConvertFiles static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertFiles.create_dataset_list}\pysiglinewithargsret{\strong{static }\bfcode{create\_dataset\_list}}{\emph{input\_filenames}, \emph{format\_type=None}, \emph{data\_region\_option='split+merge'}}{}
Based on the list of input\_filenames, generate the ConvertSettings.dataset\_list, which contains a
dictionary describing each conversion job
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{input\_filenames}} -- List of names of files to be converted.

\item {} 
\textbf{\texttt{format\_type}} -- Define which file-format should be used. Default value is `auto' indicating the
function should determine for each file the format to be used.
See also ConvertSettings.available\_formats parameter.

\item {} 
\textbf{\texttt{data\_region\_option}} -- Define how different regions defined for a file should be handled. E.g., one may
want to split all regions into indiviudal datasets (`split'), merge all regions into a single
dataset (`merge'), or do both (`split+merge'). See also the
ConvertSettings.available\_region\_options parameter for details. By default the function will
do `split+merge'.

\end{itemize}

\item[{Returns}] \leavevmode

List of dictionaries describing the various conversion jobs. Each job is described by a dict
with the following keys:
\begin{itemize}
\item {} 
`basename' : The base name of the file or directory with the data

\item {} 
`format' : The data format to be used

\item {} 
`dataset' : The index of the dataset to be converted if the input stores multiple data cubes

\item {} 
`region' : The index of the region to be converted if the input defines multiple regions

\item {} 
`exp' : One of `previous' or `new', defining whether a new experiment should be created or whether                           the experiment from the previous conversion(s) should be reused.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{suggest\_chunking() (omsi.tools.convertToOMSI.ConvertFiles static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertFiles.suggest_chunking}\pysiglinewithargsret{\strong{static }\bfcode{suggest\_chunking}}{\emph{xsize}, \emph{ysize}, \emph{mzsize}, \emph{dtype}, \emph{print\_results=False}}{}
Helper function used to suggest god chunking strategies for a given data cube
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{xsize}} -- Size of the dataset in x.

\item {} 
\textbf{\texttt{ysize}} -- Size o the dataset in y.

\item {} 
\textbf{\texttt{mzsize}} -- Size of the dataset in mz.

\item {} 
\textbf{\texttt{print\_results}} -- Print the results to the console.

\end{itemize}

\item[{Returns}] \leavevmode

Three tuples:
\begin{itemize}
\item {} 
\code{spectrum\_chunk} : The chunking to be used to optimize selection of spectra.

\item {} 
\code{slice\_chunk} : The chunking to be used to optimize selection of image slices.

\item {} 
\code{balanced\_chunk} : The chunking that would provide a good balance in performance for                                 different selection strategies.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{suggest\_chunkings\_for\_files() (omsi.tools.convertToOMSI.ConvertFiles static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertFiles.suggest_chunkings_for_files}\pysiglinewithargsret{\strong{static }\bfcode{suggest\_chunkings\_for\_files}}{\emph{in\_dataset\_list}}{}
Helper function used to suggest good chunking strategies for a given set of files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{in\_dataset\_list}} -- Python list of dictionaries describing the settings to be used
for the file conversion

\item[{Returns}] \leavevmode
This function simply prints results to standard-out but does not return anything.

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_data() (omsi.tools.convertToOMSI.ConvertFiles static method)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertFiles.write_data}\pysiglinewithargsret{\strong{static }\bfcode{write\_data}}{\emph{input\_file}, \emph{data}, \emph{data\_io\_option='spectrum'}, \emph{chunk\_shape=None}, \emph{write\_progress=True}}{}
Helper function used to implement different data write options.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{input\_file}} -- The input data file

\item {} 
\textbf{\texttt{data}} -- The output dataset (either an h5py dataset or omsi\_file\_msidata object.

\item {} 
\textbf{\texttt{data\_io\_option}} -- 
String indicating the data write method to be used. One of:
\begin{itemize}
\item {} 
\code{spectrum}: Write the data one spectrum at a time

\item {} 
\code{all} : Write the complete dataset at once.

\item {} 
\code{chunk} : Write the data one chunk at a time.

\end{itemize}


\item {} 
\textbf{\texttt{chunk\_shape}} -- The chunking used by the data. Needed to decide how the data should                                 be written when a chunk-aligned write is requested.

\item {} 
\textbf{\texttt{write\_progress}} (\emph{\texttt{bool}}) -- Write progress in \% to standard out while data is being written.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ConvertSettings (class in omsi.tools.convertToOMSI)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings}\pysigline{\strong{class }\code{omsi.tools.convertToOMSI.}\bfcode{ConvertSettings}}
Bases: \code{object}

This class is used specify the settings for the data conversion
\index{add\_file\_to\_db (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.add_file_to_db}\pysigline{\bfcode{add\_file\_to\_db}\strong{ = True}}
\end{fulllineitems}

\index{auto\_chunk (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.auto_chunk}\pysigline{\bfcode{auto\_chunk}\strong{ = True}}
\end{fulllineitems}

\index{available\_error\_options (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.available_error_options}\pysigline{\bfcode{available\_error\_options}\strong{ = {[}'terminate-and-cleanup', `terminate-only', `continue-on-error'{]}}}
\end{fulllineitems}

\index{available\_formats (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.available_formats}\pysigline{\bfcode{available\_formats}\strong{ = \{`bruckerflex\_file': \textless{}class `omsi.dataformat.bruckerflex\_file.bruckerflex\_file'\textgreater{}, `img\_file': \textless{}class `omsi.dataformat.img\_file.img\_file'\textgreater{}\}}}
\end{fulllineitems}

\index{available\_io\_options (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.available_io_options}\pysigline{\bfcode{available\_io\_options}\strong{ = {[}'chunk', `spectrum', `all'{]}}}
\end{fulllineitems}

\index{available\_region\_options (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.available_region_options}\pysigline{\bfcode{available\_region\_options}\strong{ = {[}'split', `merge', `split+merge'{]}}}
\end{fulllineitems}

\index{check\_add\_nersc (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.check_add_nersc}\pysigline{\bfcode{check\_add\_nersc}\strong{ = True}}
\end{fulllineitems}

\index{chunks (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.chunks}\pysigline{\bfcode{chunks}\strong{ = (4, 4, 2048)}}
\end{fulllineitems}

\index{compression (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.compression}\pysigline{\bfcode{compression}\strong{ = `gzip'}}
\end{fulllineitems}

\index{compression\_opts (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.compression_opts}\pysigline{\bfcode{compression\_opts}\strong{ = 4}}
\end{fulllineitems}

\index{dataset\_list (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.dataset_list}\pysigline{\bfcode{dataset\_list}\strong{ = {[}{]}}}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{dataList}} -- 
List of python dictionaries describing specific conversion settings for each conversion task. Each dictionary contains the following keys:
\begin{itemize}
\item {} 
`basename' : Name of the file to be converted

\item {} 
`format' : File format to be used (see ConvertSettings.available\_formats)

\item {} 
`exp' : Indicate the experiment the dataset should be stored with. Valid values are 
\begin{itemize}
\item {} 
`new' : Generate a new experiment for the dataset

\item {} 
`previous' : Use the same experiment as used for the previous dataset

\item {} 
1, 2,3...   : Integer value indicating the index of the experiment to be used.

\end{itemize}

\end{itemize}


\end{description}\end{quote}
\begin{itemize}
\item {} 
`region' : Optional key with index of the region to be converted. None to merge all regions.

\item {} 
`dataset' : Optional key with index of the dataset to be converted.

\item {} 
`omsi\_object': Optional key used to save a pointer to the omsi data object with the converted data

\item {} 
`dependencies': Additional dependencies that should be added for the dataset

\end{itemize}

\end{fulllineitems}

\index{db\_server\_url (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.db_server_url}\pysigline{\bfcode{db\_server\_url}\strong{ = `https://openmsi.nersc.gov/'}}
\end{fulllineitems}

\index{email\_error\_recipients (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.email_error_recipients}\pysigline{\bfcode{email\_error\_recipients}\strong{ = {[}{]}}}
\end{fulllineitems}

\index{email\_success\_recipients (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.email_success_recipients}\pysigline{\bfcode{email\_success\_recipients}\strong{ = {[}{]}}}
\end{fulllineitems}

\index{error\_handling (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.error_handling}\pysigline{\bfcode{error\_handling}\strong{ = `terminate-and-cleanup'}}
\end{fulllineitems}

\index{execute\_fpg (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.execute_fpg}\pysigline{\bfcode{execute\_fpg}\strong{ = True}}
\end{fulllineitems}

\index{execute\_fpl (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.execute_fpl}\pysigline{\bfcode{execute\_fpl}\strong{ = False}}
\end{fulllineitems}

\index{execute\_nmf (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.execute_nmf}\pysigline{\bfcode{execute\_nmf}\strong{ = True}}
\end{fulllineitems}

\index{execute\_ticnorm (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.execute_ticnorm}\pysigline{\bfcode{execute\_ticnorm}\strong{ = False}}
\end{fulllineitems}

\index{file\_user (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.file_user}\pysigline{\bfcode{file\_user}\strong{ = `oruebel'}}
\end{fulllineitems}

\index{format\_option (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.format_option}\pysigline{\bfcode{format\_option}\strong{ = None}}
\end{fulllineitems}

\index{generate\_thumbnail (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.generate_thumbnail}\pysigline{\bfcode{generate\_thumbnail}\strong{ = False}}
\end{fulllineitems}

\index{generate\_xdmf (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.generate_xdmf}\pysigline{\bfcode{generate\_xdmf}\strong{ = False}}
\end{fulllineitems}

\index{io\_block\_size\_limit (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.io_block_size_limit}\pysigline{\bfcode{io\_block\_size\_limit}\strong{ = 524288000}}
\end{fulllineitems}

\index{io\_option (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.io_option}\pysigline{\bfcode{io\_option}\strong{ = `spectrum\_to\_image'}}
\end{fulllineitems}

\index{job\_id (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.job_id}\pysigline{\bfcode{job\_id}\strong{ = None}}
\end{fulllineitems}

\index{metadata (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.metadata}\pysigline{\bfcode{metadata}\strong{ = \{\}}}
\end{fulllineitems}

\index{nmf\_num\_component (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.nmf_num_component}\pysigline{\bfcode{nmf\_num\_component}\strong{ = 20}}
\end{fulllineitems}

\index{nmf\_num\_iter (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.nmf_num_iter}\pysigline{\bfcode{nmf\_num\_iter}\strong{ = 2000}}
\end{fulllineitems}

\index{nmf\_timeout (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.nmf_timeout}\pysigline{\bfcode{nmf\_timeout}\strong{ = 600}}
\end{fulllineitems}

\index{nmf\_tolerance (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.nmf_tolerance}\pysigline{\bfcode{nmf\_tolerance}\strong{ = 0.0001}}
\end{fulllineitems}

\index{nmf\_use\_raw\_data (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.nmf_use_raw_data}\pysigline{\bfcode{nmf\_use\_raw\_data}\strong{ = False}}
\end{fulllineitems}

\index{omsi\_output\_file (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.omsi_output_file}\pysigline{\bfcode{omsi\_output\_file}\strong{ = None}}
\end{fulllineitems}

\index{parse\_input\_args() (omsi.tools.convertToOMSI.ConvertSettings class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.parse_input_args}\pysiglinewithargsret{\strong{classmethod }\bfcode{parse\_input\_args}}{\emph{argv}}{}
Process input parameters and define the script settings.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{argv}} -- The list of input arguments

\item[{Returns}] \leavevmode

This function returns the following four values:
\begin{itemize}
\item {} 
`input\_error' : Boolean indicating whether an error has occurred during the processing of the inputs

\item {} 
`inputWarning' : Boolean indicating whether a warning occurred during the processing of the inputs

\item {} 
`output\_filename' : Name for the output HDF5 file

\item {} 
`input\_filenames' : List of strings indicating the list of input filenames

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{print\_help() (omsi.tools.convertToOMSI.ConvertSettings class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.print_help}\pysiglinewithargsret{\strong{classmethod }\bfcode{print\_help}}{}{}
Function used to print the help for this script

\end{fulllineitems}

\index{recorded\_warnings (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.recorded_warnings}\pysigline{\bfcode{recorded\_warnings}\strong{ = {[}{]}}}
\end{fulllineitems}

\index{region\_option (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.region_option}\pysigline{\bfcode{region\_option}\strong{ = `split+merge'}}
\end{fulllineitems}

\index{suggest\_file\_chunkings (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.suggest_file_chunkings}\pysigline{\bfcode{suggest\_file\_chunkings}\strong{ = False}}
\end{fulllineitems}

\index{user\_additional\_chunks (omsi.tools.convertToOMSI.ConvertSettings attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.ConvertSettings.user_additional_chunks}\pysigline{\bfcode{user\_additional\_chunks}\strong{ = {[}{]}}}
\end{fulllineitems}


\end{fulllineitems}

\index{main() (in module omsi.tools.convertToOMSI)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools:omsi.tools.convertToOMSI.main}\pysiglinewithargsret{\code{omsi.tools.convertToOMSI.}\bfcode{main}}{\emph{argv=None}}{}
The main function defining the control flow for the conversion

\end{fulllineitems}



\subsubsection{\texttt{run\_analysis} Module}
\label{omsi.tools:run-analysis-module}\label{omsi.tools:module-omsi.tools.run_analysis}\index{omsi.tools.run\_analysis (module)}
Simple helper tool to run an analysis. This is essentially just a short-cut
to the omsi/workflow/analysis\_driver/omsi\_cl\_diver module


\subsubsection{\texttt{run\_workflow} Module}
\label{omsi.tools:run-workflow-module}\label{omsi.tools:module-omsi.tools.run_analysis}\index{omsi.tools.run\_analysis (module)}
Simple helper tool to run an analysis. This is essentially just a short-cut
to the omsi/workflow/analysis\_driver/omsi\_cl\_diver module


\subsubsection{Subpackages}
\label{omsi.tools:subpackages}

\paragraph{tools.experimental Package}
\label{omsi.tools.experimental::doc}\label{omsi.tools.experimental:tools-experimental-package}

\subparagraph{\texttt{tools.experimental} Package}
\label{omsi.tools.experimental:id1}\phantomsection\label{omsi.tools.experimental:module-omsi.tools.experimental}\index{omsi.tools.experimental (module)}
Collection of experimental tools and tools under development.


\paragraph{tools.misc Package}
\label{omsi.tools.misc:tools-misc-package}\label{omsi.tools.misc::doc}

\subparagraph{\texttt{tools.misc} Package}
\label{omsi.tools.misc:id1}\phantomsection\label{omsi.tools.misc:module-omsi.tools.misc}\index{omsi.tools.misc (module)}
Collection of miscellaneous tools.


\subparagraph{\texttt{make\_thumb} Module}
\label{omsi.tools.misc:make-thumb-module}\label{omsi.tools.misc:module-omsi.tools.misc.make_thumb}\index{omsi.tools.misc.make\_thumb (module)}
Simple script to generate thumbnail images
\index{main() (in module omsi.tools.misc.make\_thumb)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools.misc:omsi.tools.misc.make_thumb.main}\pysiglinewithargsret{\code{omsi.tools.misc.make\_thumb.}\bfcode{main}}{\emph{argv=None}}{}
Then main function

\end{fulllineitems}



\subparagraph{\texttt{create\_peak\_cube\_overview} Module}
\label{omsi.tools.misc:create-peak-cube-overview-module}\label{omsi.tools.misc:module-omsi.tools.misc.create_peak_cube_overview}\index{omsi.tools.misc.create\_peak\_cube\_overview (module)}
Simple helper tool used to generate a set of PNG images for a global peak
analysis (one per global peak) as well as a LaTeX document that summarizes
all the images in a single document.
\begin{description}
\item[{NOTE: The module will try to build the LaTeX document using pdflatex, i.e,}] \leavevmode
it is assumed that pdflatex is available.

\end{description}
\index{main() (in module omsi.tools.misc.create\_peak\_cube\_overview)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools.misc:omsi.tools.misc.create_peak_cube_overview.main}\pysiglinewithargsret{\code{omsi.tools.misc.create\_peak\_cube\_overview.}\bfcode{main}}{\emph{argv=None}}{}
Then main function

\end{fulllineitems}

\index{print\_help() (in module omsi.tools.misc.create\_peak\_cube\_overview)}

\begin{fulllineitems}
\phantomsection\label{omsi.tools.misc:omsi.tools.misc.create_peak_cube_overview.print_help}\pysiglinewithargsret{\code{omsi.tools.misc.create\_peak\_cube\_overview.}\bfcode{print\_help}}{}{}
Print the user help information to standard out.

\end{fulllineitems}



\subsection{examples Package}
\label{omsi.examples:examples-package}\label{omsi.examples::doc}
\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


\code{omsi.examples}
 & 
Package with a collection of various misc.
\\
\hline\end{longtable}



\subsubsection{\texttt{simple\_viewer} Module}
\label{omsi.examples:simple-viewer-module}\label{omsi.examples:module-omsi.examples.simple_viewer}\index{omsi.examples.simple\_viewer (module)}
Simple viewer for OpenMSI data
\index{MyViewer (class in omsi.examples.simple\_viewer)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.simple_viewer.MyViewer}\pysiglinewithargsret{\strong{class }\code{omsi.examples.simple\_viewer.}\bfcode{MyViewer}}{\emph{data}, \emph{mzdata}}{}
Create a simple viewer with image of the data and a cruve plot for a spectrum.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{data}} -- Reference to the hdf5 dataset of the image

\item {} 
\textbf{\texttt{mzdata}} -- mz values of the instrument to be displayed as axis in the curve plot.                           may be None in case the mz data is unknown

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{main() (in module omsi.examples.simple\_viewer)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.simple_viewer.main}\pysiglinewithargsret{\code{omsi.examples.simple\_viewer.}\bfcode{main}}{\emph{argv=None}}{}
Then main function

\end{fulllineitems}



\subsubsection{\texttt{testHDF5Optimization} Module}
\label{omsi.examples:module-omsi.examples.testHDF5Optimization}\label{omsi.examples:testhdf5optimization-module}\index{omsi.examples.testHDF5Optimization (module)}
Simple test script used to test the performance of different HDF5 
optimizations (using chunking) to improve the performance of 
hyperslap selections
\index{generateTestFile() (in module omsi.examples.testHDF5Optimization)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.testHDF5Optimization.generateTestFile}\pysiglinewithargsret{\code{omsi.examples.testHDF5Optimization.}\bfcode{generateTestFile}}{\emph{omsiOutFile}, \emph{xdim}, \emph{ydim}, \emph{zdim}, \emph{xchunk}, \emph{ychunk}, \emph{zchunk}}{}
\end{fulllineitems}

\index{main() (in module omsi.examples.testHDF5Optimization)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.testHDF5Optimization.main}\pysiglinewithargsret{\code{omsi.examples.testHDF5Optimization.}\bfcode{main}}{\emph{argv=None}}{}
Then main function

\end{fulllineitems}

\index{printHelp() (in module omsi.examples.testHDF5Optimization)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.testHDF5Optimization.printHelp}\pysiglinewithargsret{\code{omsi.examples.testHDF5Optimization.}\bfcode{printHelp}}{}{}
Print the help explaining the usage of testHDF5Optimiation

\end{fulllineitems}



\subsubsection{\texttt{testHDF5Optimization\_alignedWrite} Module}
\label{omsi.examples:testhdf5optimization-alignedwrite-module}\label{omsi.examples:module-omsi.examples.testHDF5Optimization_alignedWrite}\index{omsi.examples.testHDF5Optimization\_alignedWrite (module)}\index{generateTestFile() (in module omsi.examples.testHDF5Optimization\_alignedWrite)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.testHDF5Optimization_alignedWrite.generateTestFile}\pysiglinewithargsret{\code{omsi.examples.testHDF5Optimization\_alignedWrite.}\bfcode{generateTestFile}}{\emph{omsiOutFile}, \emph{xdim}, \emph{ydim}, \emph{zdim}, \emph{xchunk}, \emph{ychunk}, \emph{zchunk}}{}
\end{fulllineitems}

\index{main() (in module omsi.examples.testHDF5Optimization\_alignedWrite)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.testHDF5Optimization_alignedWrite.main}\pysiglinewithargsret{\code{omsi.examples.testHDF5Optimization\_alignedWrite.}\bfcode{main}}{\emph{argv=None}}{}
Then main function

\end{fulllineitems}

\index{printHelp() (in module omsi.examples.testHDF5Optimization\_alignedWrite)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.testHDF5Optimization_alignedWrite.printHelp}\pysiglinewithargsret{\code{omsi.examples.testHDF5Optimization\_alignedWrite.}\bfcode{printHelp}}{}{}
Print the help explaining the usage of testHDF5Optimiation

\end{fulllineitems}



\subsubsection{\texttt{test\_multiprocess\_slice} Module}
\label{omsi.examples:module-omsi.examples.test_multiprocess_slice}\label{omsi.examples:test-multiprocess-slice-module}\index{omsi.examples.test\_multiprocess\_slice (module)}\index{create\_process() (in module omsi.examples.test\_multiprocess\_slice)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.test_multiprocess_slice.create_process}\pysiglinewithargsret{\code{omsi.examples.test\_multiprocess\_slice.}\bfcode{create\_process}}{\emph{argv}}{}
\end{fulllineitems}

\index{generateBaseTestFile() (in module omsi.examples.test\_multiprocess\_slice)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.test_multiprocess_slice.generateBaseTestFile}\pysiglinewithargsret{\code{omsi.examples.test\_multiprocess\_slice.}\bfcode{generateBaseTestFile}}{\emph{omsiOutFile}, \emph{xdim}, \emph{ydim}, \emph{zdim}}{}
\end{fulllineitems}

\index{generateChunkedTestFile() (in module omsi.examples.test\_multiprocess\_slice)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.test_multiprocess_slice.generateChunkedTestFile}\pysiglinewithargsret{\code{omsi.examples.test\_multiprocess\_slice.}\bfcode{generateChunkedTestFile}}{\emph{omsiOutFile}, \emph{xdim}, \emph{ydim}, \emph{zdim}, \emph{xchunk}, \emph{ychunk}, \emph{zchunk}, \emph{compress=False}, \emph{donorFile='/project/projectdirs/openmsi/omsi\_data/old/TEST.h5'}}{}
\end{fulllineitems}

\index{main() (in module omsi.examples.test\_multiprocess\_slice)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.test_multiprocess_slice.main}\pysiglinewithargsret{\code{omsi.examples.test\_multiprocess\_slice.}\bfcode{main}}{\emph{argv=None}}{}
Then main function

\end{fulllineitems}

\index{sliceSelect() (in module omsi.examples.test\_multiprocess\_slice)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.test_multiprocess_slice.sliceSelect}\pysiglinewithargsret{\code{omsi.examples.test\_multiprocess\_slice.}\bfcode{sliceSelect}}{\emph{args}}{}
\end{fulllineitems}

\index{spectraSelect() (in module omsi.examples.test\_multiprocess\_slice)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.test_multiprocess_slice.spectraSelect}\pysiglinewithargsret{\code{omsi.examples.test\_multiprocess\_slice.}\bfcode{spectraSelect}}{\emph{args}}{}
\end{fulllineitems}



\subsubsection{\texttt{test\_par} Module}
\label{omsi.examples:module-omsi.examples.test_par}\label{omsi.examples:test-par-module}\index{omsi.examples.test\_par (module)}\index{create\_process() (in module omsi.examples.test\_par)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.test_par.create_process}\pysiglinewithargsret{\code{omsi.examples.test\_par.}\bfcode{create\_process}}{\emph{argv}}{}
\end{fulllineitems}

\index{generateBaseTestFile() (in module omsi.examples.test\_par)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.test_par.generateBaseTestFile}\pysiglinewithargsret{\code{omsi.examples.test\_par.}\bfcode{generateBaseTestFile}}{\emph{omsiOutFile}, \emph{xdim}, \emph{ydim}, \emph{zdim}}{}
\end{fulllineitems}

\index{generateChunkedTestFile() (in module omsi.examples.test\_par)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.test_par.generateChunkedTestFile}\pysiglinewithargsret{\code{omsi.examples.test\_par.}\bfcode{generateChunkedTestFile}}{\emph{omsiOutFile}, \emph{xdim}, \emph{ydim}, \emph{zdim}, \emph{xchunk}, \emph{ychunk}, \emph{zchunk}, \emph{compress=False}, \emph{donorFile='/project/projectdirs/openmsi/omsi\_data/old/TEST.h5'}}{}
\end{fulllineitems}

\index{main() (in module omsi.examples.test\_par)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.test_par.main}\pysiglinewithargsret{\code{omsi.examples.test\_par.}\bfcode{main}}{\emph{argv=None}}{}
Then main function

\end{fulllineitems}

\index{sliceSelect() (in module omsi.examples.test\_par)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.test_par.sliceSelect}\pysiglinewithargsret{\code{omsi.examples.test\_par.}\bfcode{sliceSelect}}{\emph{args}}{}
\end{fulllineitems}

\index{spectraSelect() (in module omsi.examples.test\_par)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.test_par.spectraSelect}\pysiglinewithargsret{\code{omsi.examples.test\_par.}\bfcode{spectraSelect}}{\emph{args}}{}
\end{fulllineitems}



\subsubsection{\texttt{test\_peakcube} Module}
\label{omsi.examples:test-peakcube-module}\label{omsi.examples:module-omsi.examples.test_peakcube}\index{omsi.examples.test\_peakcube (module)}\index{main() (in module omsi.examples.test\_peakcube)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.test_peakcube.main}\pysiglinewithargsret{\code{omsi.examples.test\_peakcube.}\bfcode{main}}{\emph{argv=None}}{}
Then main function

\end{fulllineitems}

\index{printHelp() (in module omsi.examples.test\_peakcube)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.test_peakcube.printHelp}\pysiglinewithargsret{\code{omsi.examples.test\_peakcube.}\bfcode{printHelp}}{}{}
\end{fulllineitems}



\subsubsection{\texttt{testhdf5\_file\_read} Module}
\label{omsi.examples:module-omsi.examples.testhdf5_file_read}\label{omsi.examples:testhdf5-file-read-module}\index{omsi.examples.testhdf5\_file\_read (module)}
Simple test script used to test the performance of different HDF5 
optimizations (using chunking) to improve the performance of 
hyperslap selections
\index{main() (in module omsi.examples.testhdf5\_file\_read)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.testhdf5_file_read.main}\pysiglinewithargsret{\code{omsi.examples.testhdf5\_file\_read.}\bfcode{main}}{\emph{argv=None}}{}
Then main function

\end{fulllineitems}

\index{printHelp() (in module omsi.examples.testhdf5\_file\_read)}

\begin{fulllineitems}
\phantomsection\label{omsi.examples:omsi.examples.testhdf5_file_read.printHelp}\pysiglinewithargsret{\code{omsi.examples.testhdf5\_file\_read.}\bfcode{printHelp}}{}{}
Print the help explaining the usage of testHDF5Optimiation

\end{fulllineitems}



\subsection{templates Package}
\label{omsi.templates::doc}\label{omsi.templates:templates-package}
\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


{\hyperref[omsi.templates:module\string-omsi.templates]{\emph{\code{omsi.templates}}}}
 & 
This package provides a collection of code templates to ease the development of additional components, e.g., analysis modules.
\\
\hline
{\hyperref[omsi.templates:module\string-omsi.templates.analysis_template]{\emph{\code{omsi.templates.analysis\_template}}}}
 & 
Template intended to help with the development of new analysis modules.
\\
\hline\end{longtable}



\subsubsection{\texttt{templates} Package}
\label{omsi.templates:id1}\phantomsection\label{omsi.templates:module-omsi.templates}\index{omsi.templates (module)}
This package provides a collection of code templates to ease the development of additional components, e.g.,
analysis modules. As such, this package is NOT intended for direct usage but is rather just a library of code templates.


\subsubsection{\texttt{analysis\_template} Module}
\label{omsi.templates:module-omsi.templates.analysis_template}\label{omsi.templates:analysis-template-module}\index{omsi.templates.analysis\_template (module)}
Template intended to help with the development of new analysis modules.
\index{analysis\_template (class in omsi.templates.analysis\_template)}

\begin{fulllineitems}
\phantomsection\label{omsi.templates:omsi.templates.analysis_template.analysis_template}\pysiglinewithargsret{\strong{class }\code{omsi.templates.analysis\_template.}\bfcode{analysis\_template}}{\emph{name\_key='undefined'}}{}
Bases: {\hyperref[omsi.analysis:omsi.analysis.base.analysis_base]{\emph{\code{omsi.analysis.base.analysis\_base}}}}

Template intended to help with the development of new analysis classes.

Search for EDIT\_ME to find locations that need to be changed.

EDIT\_ME Search for analysis\_template and replace it with your classname throughout

EDIT\_ME Replace this doc-string with your class documentation

Initalize the basic data members
\index{execute\_analysis() (omsi.templates.analysis\_template.analysis\_template method)}

\begin{fulllineitems}
\phantomsection\label{omsi.templates:omsi.templates.analysis_template.analysis_template.execute_analysis}\pysiglinewithargsret{\bfcode{execute\_analysis}}{}{}
EDIT\_ME
Implement this function to implement the execution of the actual analysis.

This function may not require any input parameters. All input parameters are
recoded in the parameters and dependencies lists and should be retrieved
from there, e.g, using basic slicing self{[} paramName {]}

EDIT\_ME
Remove this comment and replace it with your own documentation.
Describe what your analysis does and how a user can use it. Note, a user will
call the function execute(...) which takes care of storing parameters, collecting
execution data etc., so that you only need to implement your analysis, the rest
is taken care of by analysis\_base.

Keyword Arguments:
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{mydata}} -- 
...


\item[{Returns}] \leavevmode
This function may return any developer-defined data. Note, all
output that should be recorded must be put into the data list.

\end{description}\end{quote}

\end{fulllineitems}

\index{groups (omsi.templates.analysis\_template.analysis\_template attribute)}

\begin{fulllineitems}
\phantomsection\label{omsi.templates:omsi.templates.analysis_template.analysis_template.groups}\pysigline{\bfcode{groups}\strong{ = None}}
EDIT\_ME

Add a list of names of input parameters for your analysis
using the self.add\_add\_parameter.

For parameters that define n-dimension arrays you should specify the
dtypes{[}'ndarray'{]} as dtype. This will allow discovery
of dependencies and proper function with the analysis drivers.
Other available dtypes include standard built-ins, e.g,
int, float etc. See self.get\_default\_dtypes() for details.

It is also recommended to organize parameters into groups using
the default set of groups, e.g., groups{[}'input'{]}, groups{[}'settings'{]},
groups{[}'stop'{]}.

\end{fulllineitems}

\index{v\_qmz() (omsi.templates.analysis\_template.analysis\_template class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.templates:omsi.templates.analysis_template.analysis_template.v_qmz}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qmz}}{\emph{analysis\_object}, \emph{qslice\_viewer\_option=0}, \emph{qspectrum\_viewer\_option=0}}{}
Get the mz axes for the analysis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{qslice\_viewer\_option}} -- If multiple default viewer behaviors are available for a
given analysis then this option is used to switch between them for the qslice URL pattern.

\item {} 
\textbf{\texttt{qspectrum\_viewer\_option}} -- If multiple default viewer behaviors are available for a
given analysis then this option is used to switch between them for the qspectrum URL pattern.

\end{itemize}

\item[{Returns}] \leavevmode

The following four arrays are returned by the analysis:
\begin{itemize}
\item {} 
mz\_spectra : Array with the static mz values for the spectra.

\item {} 
label\_spectra : Lable for the spectral mz axis

\item {} 
mz\_slice : Array of the static mz values for the slices or None if identical to the mz\_spectra.

\item {} 
label\_slice : Lable for the slice mz axis or None if identical to label\_spectra.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice() (omsi.templates.analysis\_template.analysis\_template class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.templates:omsi.templates.analysis_template.analysis_template.v_qslice}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice}}{\emph{analysis\_object}, \emph{z}, \emph{viewer\_option=0}}{}
Get 3D analysis dataset for which z-slices should be extracted for presentation in the OMSI viewer
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{z}} -- Selection string indicting which z values should be selected.

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for
a given analysis then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode
numpy array with the data to be displayed in the image slice viewer.
Slicing will be performed typically like {[}:,:,zmin:zmax{]}.

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qslice\_viewer\_options() (omsi.templates.analysis\_template.analysis\_template class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.templates:omsi.templates.analysis_template.analysis_template.v_qslice_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qslice\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qslice.
The default implementation tries to take care of handling the spectra retrieval for all the depencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed.
For most cases this is not needed here as the support for slice operations is usually a
static decision based on the class type, however, in some cases additional checks may be
needed (e.g., ensure that the required data is available).

\item[{Returns}] \leavevmode
List of strings indicating the different available viewer options. The list should be
empty if the analysis does not support qslice requests (i.e., v\_qslice(...) is not available).

\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum() (omsi.templates.analysis\_template.analysis\_template class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.templates:omsi.templates.analysis_template.analysis_template.v_qspectrum}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum}}{\emph{analysis\_object}, \emph{x}, \emph{y}, \emph{viewer\_option=0}}{}
Get from which 3D analysis spectra in x/y should be extracted for presentation in the OMSI viewer
\begin{description}
\item[{Developer Note: h5py currently supports only a single index list. If the user provides an index-list for both}] \leavevmode
x and y, then we need to construct the proper merged list and load the data manually, or if
the data is small enough, one can load the full data into a numpy array which supports
mulitple lists in the selection.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{analysis\_object}} -- The omsi\_file\_analysis object for which slicing should be performed

\item {} 
\textbf{\texttt{x}} -- x selection string

\item {} 
\textbf{\texttt{y}} -- y selection string

\item {} 
\textbf{\texttt{viewer\_option}} -- If multiple default viewer behaviors are available for a given
analysis then this option is used to switch between them.

\end{itemize}

\item[{Returns}] \leavevmode

The following two elemnts are expected to be returned by this function :
\begin{enumerate}
\item {} 
1D, 2D or 3D numpy array of the requested spectra. NOTE: The mass (m/z) axis must be the last axis.                For index selection x=1,y=1 a 1D array is usually expected. For indexList selections x={[}0{]}\&y={[}1{]}                usually a 2D array is expected. For ragne selections x=0:1\&y=1:2 we one usually expects a 3D array.

\item {} 
None in case that the spectra axis returned by v\_qmz are valid for the returned spectrum. Otherwise,                return a 1D numpy array with the m/z values for the spectrum (i.e., if custom m/z values are needed                for interpretation of the returned spectrum).This may be needed, e.g., in cases where a per-spectrum                peak analysis is performed and the peaks for each spectrum appear at different m/z values.

\end{enumerate}


\end{description}\end{quote}

\end{fulllineitems}

\index{v\_qspectrum\_viewer\_options() (omsi.templates.analysis\_template.analysis\_template class method)}

\begin{fulllineitems}
\phantomsection\label{omsi.templates:omsi.templates.analysis_template.analysis_template.v_qspectrum_viewer_options}\pysiglinewithargsret{\strong{classmethod }\bfcode{v\_qspectrum\_viewer\_options}}{\emph{analysis\_object}}{}
Get a list of strings describing the different default viewer options for the analysis for qspectrum.
The default implementation tries to take care of handling the spectra retrieval for all the dependencies
but can naturally not decide how the qspectrum should be handled by a derived class. However, this
implementation is often called at the end of custom implementations to also allow access to data from
other dependencies.
\begin{quote}
\begin{quote}\begin{description}
\item[{param analysis\_object}] \leavevmode
The omsi\_file\_analysis object for which slicing should be performed.
For most cases this is not needed here as the support for slice operations is usually a
static decission based on the class type, however, in some cases additional checks
may be needed (e.g., ensure that the required data is available).

\item[{returns}] \leavevmode
List of strings indicating the different available viewer options. The list should
be empty if the analysis does not support qspectrum requests
(i.e., v\_qspectrum(...) is not available).

\end{description}\end{quote}
\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{o}
\item {\texttt{omsi.analysis}}, \pageref{omsi.analysis:module-omsi.analysis}
\item {\texttt{omsi.analysis.analysis\_views}}, \pageref{omsi.analysis:module-omsi.analysis.analysis_views}
\item {\texttt{omsi.analysis.base}}, \pageref{omsi.analysis:module-omsi.analysis.base}
\item {\texttt{omsi.analysis.compound\_stats}}, \pageref{omsi.analysis.compound_stats:module-omsi.analysis.compound_stats}
\item {\texttt{omsi.analysis.compound\_stats.experimental}}, \pageref{omsi.analysis.compound_stats:module-omsi.analysis.compound_stats.experimental}
\item {\texttt{omsi.analysis.compound\_stats.omsi\_score\_midas}}, \pageref{omsi.analysis.compound_stats:module-omsi.analysis.compound_stats.omsi_score_midas}
\item {\texttt{omsi.analysis.compound\_stats.omsi\_score\_pactolus}}, \pageref{omsi.analysis.compound_stats:module-omsi.analysis.compound_stats.omsi_score_pactolus}
\item {\texttt{omsi.analysis.compound\_stats.third\_party}}, \pageref{omsi.analysis.compound_stats:module-omsi.analysis.compound_stats.third_party}
\item {\texttt{omsi.analysis.findpeaks}}, \pageref{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks}
\item {\texttt{omsi.analysis.findpeaks.experimental}}, \pageref{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.experimental}
\item {\texttt{omsi.analysis.findpeaks.experimental.mypeakfinder}}, \pageref{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.experimental.mypeakfinder}
\item {\texttt{omsi.analysis.findpeaks.experimental.omsi\_lpf}}, \pageref{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.experimental.omsi_lpf}
\item {\texttt{omsi.analysis.findpeaks.experimental.omsi\_npg}}, \pageref{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.experimental.omsi_npg}
\item {\texttt{omsi.analysis.findpeaks.experimental.omsi\_peakcube}}, \pageref{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.experimental.omsi_peakcube}
\item {\texttt{omsi.analysis.findpeaks.experimental.pfrun}}, \pageref{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.experimental.pfrun}
\item {\texttt{omsi.analysis.findpeaks.omsi\_findpeaks\_global}}, \pageref{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.omsi_findpeaks_global}
\item {\texttt{omsi.analysis.findpeaks.omsi\_findpeaks\_local}}, \pageref{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.omsi_findpeaks_local}
\item {\texttt{omsi.analysis.findpeaks.third\_party}}, \pageref{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.third_party}
\item {\texttt{omsi.analysis.findpeaks.third\_party.findpeaks}}, \pageref{omsi.analysis.findpeaks:module-omsi.analysis.findpeaks.third_party.findpeaks}
\item {\texttt{omsi.analysis.generic}}, \pageref{omsi.analysis:module-omsi.analysis.generic}
\item {\texttt{omsi.analysis.msi\_filtering}}, \pageref{omsi.analysis.msi_filtering:module-omsi.analysis.msi_filtering}
\item {\texttt{omsi.analysis.msi\_filtering.experimental}}, \pageref{omsi.analysis.msi_filtering:module-omsi.analysis.msi_filtering.experimental}
\item {\texttt{omsi.analysis.msi\_filtering.experimental.omsi\_filter\_by\_mask}}, \pageref{omsi.analysis.msi_filtering:module-omsi.analysis.msi_filtering.experimental.omsi_filter_by_mask}
\item {\texttt{omsi.analysis.msi\_filtering.experimental.omsi\_mask\_by\_cluster}}, \pageref{omsi.analysis.msi_filtering:module-omsi.analysis.msi_filtering.experimental.omsi_mask_by_cluster}
\item {\texttt{omsi.analysis.msi\_filtering.omsi\_tic\_norm}}, \pageref{omsi.analysis.msi_filtering:module-omsi.analysis.msi_filtering.omsi_tic_norm}
\item {\texttt{omsi.analysis.msi\_filtering.third\_party}}, \pageref{omsi.analysis.msi_filtering:module-omsi.analysis.msi_filtering.third_party}
\item {\texttt{omsi.analysis.multivariate\_stats}}, \pageref{omsi.analysis.multivariate_stats:module-omsi.analysis.multivariate_stats}
\item {\texttt{omsi.analysis.multivariate\_stats.experimental}}, \pageref{omsi.analysis.multivariate_stats:module-omsi.analysis.multivariate_stats.experimental}
\item {\texttt{omsi.analysis.multivariate\_stats.omsi\_nmf}}, \pageref{omsi.analysis.multivariate_stats:module-omsi.analysis.multivariate_stats.omsi_nmf}
\item {\texttt{omsi.analysis.multivariate\_stats.third\_party}}, \pageref{omsi.analysis.multivariate_stats:module-omsi.analysis.multivariate_stats.third_party}
\item {\texttt{omsi.analysis.multivariate\_stats.third\_party.nmf}}, \pageref{omsi.analysis.multivariate_stats:module-omsi.analysis.multivariate_stats.third_party.nmf}
\item {\texttt{omsi.dataformat.bruckerflex\_file}}, \pageref{omsi.dataformat:module-omsi.dataformat.bruckerflex_file}
\item {\texttt{omsi.dataformat.file\_reader\_base}}, \pageref{omsi.dataformat:module-omsi.dataformat.file_reader_base}
\item {\texttt{omsi.dataformat.img\_file}}, \pageref{omsi.dataformat:module-omsi.dataformat.img_file}
\item {\texttt{omsi.dataformat.omsi\_file}}, \pageref{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file}
\item {\texttt{omsi.dataformat.omsi\_file.analysis}}, \pageref{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.analysis}
\item {\texttt{omsi.dataformat.omsi\_file.common}}, \pageref{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.common}
\item {\texttt{omsi.dataformat.omsi\_file.dependencies}}, \pageref{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.dependencies}
\item {\texttt{omsi.dataformat.omsi\_file.experiment}}, \pageref{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.experiment}
\item {\texttt{omsi.dataformat.omsi\_file.format}}, \pageref{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.format}
\item {\texttt{omsi.dataformat.omsi\_file.instrument}}, \pageref{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.instrument}
\item {\texttt{omsi.dataformat.omsi\_file.main\_file}}, \pageref{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.main_file}
\item {\texttt{omsi.dataformat.omsi\_file.metadata\_collection}}, \pageref{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.metadata_collection}
\item {\texttt{omsi.dataformat.omsi\_file.methods}}, \pageref{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.methods}
\item {\texttt{omsi.dataformat.omsi\_file.msidata}}, \pageref{omsi.dataformat.omsi_file:module-omsi.dataformat.omsi_file.msidata}
\item {\texttt{omsi.datastructures}}, \pageref{omsi.datastructures:module-omsi.datastructures}
\item {\texttt{omsi.datastructures.analysis\_data}}, \pageref{omsi.datastructures:module-omsi.datastructures.analysis_data}
\item {\texttt{omsi.datastructures.dependency\_data}}, \pageref{omsi.datastructures:module-omsi.datastructures.dependency_data}
\item {\texttt{omsi.datastructures.metadata}}, \pageref{omsi.datastructures.metadata:module-omsi.datastructures.metadata}
\item {\texttt{omsi.datastructures.metadata.metadata\_data}}, \pageref{omsi.datastructures.metadata:module-omsi.datastructures.metadata.metadata_data}
\item {\texttt{omsi.datastructures.metadata.metadata\_ontologies}}, \pageref{omsi.datastructures.metadata:module-omsi.datastructures.metadata.metadata_ontologies}
\item {\texttt{omsi.datastructures.run\_info\_data}}, \pageref{omsi.datastructures:module-omsi.datastructures.run_info_data}
\item {\texttt{omsi.examples.simple\_viewer}}, \pageref{omsi.examples:module-omsi.examples.simple_viewer}
\item {\texttt{omsi.examples.test\_multiprocess\_slice}}, \pageref{omsi.examples:module-omsi.examples.test_multiprocess_slice}
\item {\texttt{omsi.examples.test\_par}}, \pageref{omsi.examples:module-omsi.examples.test_par}
\item {\texttt{omsi.examples.test\_peakcube}}, \pageref{omsi.examples:module-omsi.examples.test_peakcube}
\item {\texttt{omsi.examples.testhdf5\_file\_read}}, \pageref{omsi.examples:module-omsi.examples.testhdf5_file_read}
\item {\texttt{omsi.examples.testHDF5Optimization}}, \pageref{omsi.examples:module-omsi.examples.testHDF5Optimization}
\item {\texttt{omsi.examples.testHDF5Optimization\_alignedWrite}}, \pageref{omsi.examples:module-omsi.examples.testHDF5Optimization_alignedWrite}
\item {\texttt{omsi.shared.data\_selection}}, \pageref{omsi.shared:module-omsi.shared.data_selection}
\item {\texttt{omsi.shared.log}}, \pageref{omsi.shared:module-omsi.shared.log}
\item {\texttt{omsi.shared.mpi\_helper}}, \pageref{omsi.shared:module-omsi.shared.mpi_helper}
\item {\texttt{omsi.shared.omsi\_web\_helper}}, \pageref{omsi.shared:module-omsi.shared.omsi_web_helper}
\item {\texttt{omsi.shared.spectrum\_layout}}, \pageref{omsi.shared:module-omsi.shared.spectrum_layout}
\item {\texttt{omsi.templates}}, \pageref{omsi.templates:module-omsi.templates}
\item {\texttt{omsi.templates.analysis\_template}}, \pageref{omsi.templates:module-omsi.templates.analysis_template}
\item {\texttt{omsi.tools.convertToOMSI}}, \pageref{omsi.tools:module-omsi.tools.convertToOMSI}
\item {\texttt{omsi.tools.experimental}}, \pageref{omsi.tools.experimental:module-omsi.tools.experimental}
\item {\texttt{omsi.tools.misc}}, \pageref{omsi.tools.misc:module-omsi.tools.misc}
\item {\texttt{omsi.tools.misc.create\_peak\_cube\_overview}}, \pageref{omsi.tools.misc:module-omsi.tools.misc.create_peak_cube_overview}
\item {\texttt{omsi.tools.misc.make\_thumb}}, \pageref{omsi.tools.misc:module-omsi.tools.misc.make_thumb}
\item {\texttt{omsi.tools.run\_analysis}}, \pageref{omsi.tools:module-omsi.tools.run_analysis}
\item {\texttt{omsi.workflow}}, \pageref{omsi.workflow:module-omsi.workflow}
\item {\texttt{omsi.workflow.common}}, \pageref{omsi.workflow:module-omsi.workflow.common}
\item {\texttt{omsi.workflow.driver}}, \pageref{omsi.workflow.driver:module-omsi.workflow.driver}
\item {\texttt{omsi.workflow.driver.base}}, \pageref{omsi.workflow.driver:module-omsi.workflow.driver.base}
\item {\texttt{omsi.workflow.driver.cl\_analysis\_driver}}, \pageref{omsi.workflow.driver:module-omsi.workflow.driver.cl_analysis_driver}
\item {\texttt{omsi.workflow.driver.cl\_workflow\_driver}}, \pageref{omsi.workflow.driver:module-omsi.workflow.driver.cl_workflow_driver}
\item {\texttt{omsi.workflow.executor}}, \pageref{omsi.workflow.executor:module-omsi.workflow.executor}
\item {\texttt{omsi.workflow.executor.base}}, \pageref{omsi.workflow.executor:module-omsi.workflow.executor.base}
\item {\texttt{omsi.workflow.executor.greedy\_executor}}, \pageref{omsi.workflow.executor:module-omsi.workflow.executor.greedy_executor}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
