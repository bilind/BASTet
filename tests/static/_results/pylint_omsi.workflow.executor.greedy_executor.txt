************* Module omsi.workflow.executor.greedy_executor
C: 36, 0: Wrong continued indentation.
                                'complete, processing dependencies out-of-core.',
                           |    ^ (bad-continuation)
C: 42, 0: Wrong continued indentation.
                                'This can be useful when we require that all MPI ranks are fully initalized.',
                           |    ^ (bad-continuation)
R: 10, 0: Too many public methods (25/20) (too-many-public-methods)
R: 53, 0: Abstract class not referenced (abstract-class-not-used)
R:203, 0: Abstract class is only referenced 1 times (abstract-class-little-used)
R:285, 0: Abstract class is only referenced 1 times (abstract-class-little-used)
R:277, 0: Abstract class not referenced (abstract-class-not-used)
R: 37, 0: Abstract class is only referenced 1 times (abstract-class-little-used)
R: 73, 0: Abstract class is only referenced 1 times (abstract-class-little-used)
R: 16, 0: Abstract class is only referenced 1 times (abstract-class-little-used)
R:  1, 0: Cyclic import (omsi.dataformat.omsi_file.common -> omsi.dataformat.omsi_file.metadata_collection) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.base -> omsi.workflow.executor.base -> omsi.workflow.common -> omsi.dataformat.omsi_file.common -> omsi.dataformat.omsi_file.analysis -> omsi.datastructures.dependency_data) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.base -> omsi.workflow.executor.base -> omsi.workflow.common -> omsi.dataformat.omsi_file.common -> omsi.dataformat.omsi_file.experiment -> omsi.dataformat.omsi_file.msidata -> omsi.dataformat.omsi_file.dependencies -> omsi.datastructures.dependency_data) (cyclic-import)
R:  1, 0: Cyclic import (omsi.shared.log -> omsi.shared.mpi_helper) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.base -> omsi.workflow.executor.base -> omsi.workflow.common) (cyclic-import)
R:  1, 0: Cyclic import (omsi.workflow.executor.base -> omsi.workflow.executor.greedy_executor) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.base -> omsi.workflow.executor.base -> omsi.datastructures.analysis_data -> omsi.dataformat.omsi_file.analysis -> omsi.datastructures.dependency_data) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.base -> omsi.workflow.executor.base -> omsi.datastructures.analysis_data -> omsi.datastructures.dependency_data) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.base -> omsi.workflow.executor.base -> omsi.datastructures.analysis_data -> omsi.dataformat.omsi_file.msidata -> omsi.dataformat.omsi_file.metadata_collection -> omsi.dataformat.omsi_file.common -> omsi.dataformat.omsi_file.analysis -> omsi.datastructures.dependency_data) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.base -> omsi.workflow.driver.cl_analysis_driver -> omsi.dataformat.omsi_file.main_file -> omsi.dataformat.omsi_file.experiment -> omsi.dataformat.omsi_file.msidata -> omsi.dataformat.omsi_file.metadata_collection -> omsi.dataformat.omsi_file.common -> omsi.dataformat.omsi_file.analysis -> omsi.datastructures.dependency_data) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.base -> omsi.workflow.executor.base -> omsi.datastructures.analysis_data -> omsi.dataformat.omsi_file.msidata -> omsi.dataformat.omsi_file.dependencies -> omsi.dataformat.omsi_file.common -> omsi.dataformat.omsi_file.analysis -> omsi.datastructures.dependency_data) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.base -> omsi.workflow.driver.cl_analysis_driver -> omsi.dataformat.omsi_file.analysis -> omsi.datastructures.dependency_data) (cyclic-import)
R:  1, 0: Cyclic import (omsi.dataformat.omsi_file.common -> omsi.dataformat.omsi_file.experiment -> omsi.dataformat.omsi_file.msidata -> omsi.dataformat.omsi_file.metadata_collection) (cyclic-import)
R:  1, 0: Cyclic import (omsi.dataformat.omsi_file.analysis -> omsi.datastructures.analysis_data) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.base -> omsi.workflow.executor.base -> omsi.workflow.common -> omsi.dataformat.omsi_file.common -> omsi.dataformat.omsi_file.analysis) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.base -> omsi.dataformat.omsi_file.analysis -> omsi.datastructures.dependency_data) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.base -> omsi.datastructures.analysis_data -> omsi.datastructures.dependency_data) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.analysis_views -> omsi.analysis.generic -> omsi.analysis.base) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.base -> omsi.workflow.driver.cl_analysis_driver -> omsi.workflow.common -> omsi.dataformat.omsi_file.common -> omsi.dataformat.omsi_file.analysis -> omsi.datastructures.dependency_data) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.analysis_views -> omsi.analysis.generic -> omsi.datastructures.analysis_data -> omsi.dataformat.omsi_file.analysis -> omsi.datastructures.dependency_data -> omsi.analysis.base) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.base -> omsi.workflow.executor.base -> omsi.datastructures.analysis_data -> omsi.dataformat.omsi_file.msidata -> omsi.dataformat.omsi_file.instrument -> omsi.dataformat.omsi_file.common -> omsi.dataformat.omsi_file.analysis -> omsi.datastructures.dependency_data) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.base -> omsi.workflow.executor.base -> omsi.datastructures.analysis_data -> omsi.dataformat.omsi_file.msidata -> omsi.dataformat.omsi_file.methods -> omsi.dataformat.omsi_file.common -> omsi.dataformat.omsi_file.analysis -> omsi.datastructures.dependency_data) (cyclic-import)
R:  1, 0: Cyclic import (omsi.analysis.generic -> omsi.datastructures.analysis_data -> omsi.dataformat.omsi_file.analysis) (cyclic-import)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:399
==omsi.workflow.driver.cl_analysis_driver:379
            else:
                log_helper.info(__name__, "Save to: " + unicode(self.output_target))

    def remove_output_target(self):
        """
        This function is used to delete any output target files created by the
        command line driver. This is done in case that an error occurred and
        we do not want to leave garbage files left over.

        *Side effects* The function modifies ``self.output_target``

        :return: Boolean indicating whether we succesfully cleaned up the output
        """
        success = False
        if self.__output_target_self is not None:
            try:
                os.remove(self.__output_target_self)
                log_helper.info(__name__, "Successfully removed output target: " + unicode(self.__output_target_self))
                success = True
            except:
                log_helper.error(__name__, "Clean-up of output failed. File may be left on system: "
                                 + unicode(self.__output_target_self))
        elif self.output_target is not None:
            log_helper.info(__name__, "Output target not removed because it was not created " +
                                      "by the analysis but potentially modified by it")
        else:
            success = True
        return success

    def main(self):
        """
        Default main function for running an analysis from the command line.
        The default implementation exposes all specified analysis parameters as command
        line options to the user. The default implementation also provides means to
        print a help text for the function.

        :raises: ValueError is raised in case that the analysis class is unknown
        """
        # Get the analysis object if needed
        if self.add_analysis_class_arg:
            try:
                self.get_analysis_class_from_cl()
            except (ImportError, AttributeError, ValueError):
                pass

        # Initialize the argument parser
        if self.parser is None:
            self.initialize_argument_parser()

        # Check if we have a valid analysis class
        if self.analysis_class is None:
            print self.parser.print_help()
            raise ValueError('Could not determine the analysis class.')
        if not issubclass(self.analysis_class, analysis_base):
            print self.parser.print_help()
            raise ValueError('Analysis class is not a subclass of analysis_base.')

        try:
            # Parse the command line arguments to determine the command line driver settings
            self.parse_cl_arguments()
            # Add and parse the command line arguments specific to the analysis to determine the analysis settings
            self.add_and_parse_analysis_arguments()
        except:
            self.remove_output_target()
            raise

        # Print the analysis settings
        if mpi_helper.get_rank() == self.mpi_root:
            self.print_settings()

        # Call the execute function of the analysis
        try:
            # Create the analysis object (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:347
==omsi.workflow.driver.cl_analysis_driver:328
                arg_name = "--" + arg_param['name']
                arg_action = 'store'
                arg_default = arg_param['default']
                arg_required = arg_param['required'] and arg_default is None
                arg_type = arg_param['dtype']
                arg_choices = arg_param['choices']
                arg_help = arg_param['help']
                arg_dest = arg_param['name']
                arg_group = arg_param.get_group_name()

                # Determine the group the argument belongs to
                argument_group = self.required_argument_group if arg_required else self.parser
                if arg_group in self.custom_argument_groups:
                    argument_group = self.custom_argument_groups[arg_group]

                # Add the argument to the proper group
                argument_group.add_argument(arg_name,               # <-- Required, user specified arg name
                                            action=arg_action,      #     Constant. We define this not the user.
                                            # nargs=1,                    Don't use. Leave as default
                                            # const=None,                 Don't use. We don't use this type of action
                                            default=arg_default,    # <-- Optional default value for the argument
                                            type=arg_type,          # <-- Optional dtype of the argument
                                            choices=arg_choices,    # <-- Optional Key may be missing.
                                            required=arg_required,  # <-- Optional
                                            help=arg_help,          # <-- Required
                                            # metavar               #     Don't use. Positional analysis arguments
                                            #                       #     are not allowed
                                            dest=arg_dest)          #     Automatically determined by the name
        # Add the help argument
        self.parser.add_argument('-h', '--help',
                                 action='help',
                                 default=argparse.SUPPRESS,
                                 help='show this help message and exit')
        parsed_arguments = vars(self.parser.parse_args())
        parsed_arguments.pop(self.analysis_class_arg_name, None) (duplicate-code)
R:  1, 0: Similar lines in 3 files
==omsi.analysis.base:573
==omsi.analysis.msi_filtering.omsi_tic_norm:201
==omsi.analysis.multivariate_stats.omsi_cx:209
            return None

    @classmethod
    def v_qspectrum(cls,
                    analysis_object,
                    x,
                    y,
                    viewer_option=0):
        """
        Get from which 3D analysis spectra in x/y should be extracted for presentation in the OMSI viewer

        **Developer Note:** h5py currently supports only a single index list. If the user provides an index-list
        for both x and y, then we need to construct the proper merged list and load the data manually, or if
        the data is small enough, one can load the full data into a numpy array which supports
        multiple lists in the selection.

        :param analysis_object: The omsi_file_analysis object for which slicing should be performed
        :param x: x selection string
        :param y: y selection string
        :param viewer_option: If multiple default viewer behaviors are available for a given
            analysis then this option is used to switch between them.

        :returns: The following two elements are expected to be returned by this function :

                1) 1D, 2D or 3D numpy array of the requested spectra. NOTE: The mass (m/z) axis must be \
                the last axis. For index selection x=1,y=1 a 1D array is usually expected. For indexList \
                selections x=[0]&y=[1] usually a 2D array is expected. For ragne selections x=0:1&y=1:2 we \
                one usually expects a 3D array.
                2) None in case that the spectra axis returned by v_qmz are valid for the returned spectrum. \
                Otherwise, return a 1D numpy array with the m/z values for the spectrum (i.e., if custom m/z \
                values are needed for interpretation of the returned spectrum).This may be needed, e.g., in \
                cases where a per-spectrum peak analysis is performed and the peaks for each spectrum appear \
                at different m/z values.
        """ (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:123
==omsi.workflow.driver.cl_analysis_driver:125
    def get_analysis_class_from_cl(self):
        """
        Internal helper function used to get the analysis class object based on the
        analysis_class_arg_name positional argument from the command line.

        *Side effects:* The function sets ``self.analysis_class`

        :raises: ImportError in case that the analysis module cannot be loaded
        :raises: AttributeError in case that the analysis class cannot be extracted from the module
        """
        if len(sys.argv) < 2 or sys.argv[1].startswith('--'):
            raise ValueError("Missing required input argument defining the analysis to be executed missing")

        # Get the analysis class we need to operate on as the first positional argument
        # Get the name of the analysis class and format the string to remove common formatting problems.
        analysis_script = sys.argv[1].replace('/', '.')
        if analysis_script.endswith('.py'):
            analysis_script = analysis_script.rstrip('.py')
        if analysis_script.startswith('.'):
            analysis_script = analysis_script.lstrip('.')

        # Determine the name of the module and name from the string
        analysis_class_name = analysis_script.split('.')[-1]
        analysis_module_name = analysis_script.rstrip(analysis_class_name)[:-1]
        if not analysis_module_name.startswith('omsi.analysis'):
            analysis_module_name = 'omsi.analysis.' + analysis_module_name

        # Import the module
        try:
            analysis_module_object = __import__(analysis_module_name, globals(), locals(), [analysis_class_name], -1)
        except ImportError as e:
            log_helper.error(__name__, e.message) (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.dataformat.imzml_file:225
==omsi.dataformat.mzml_file:424
        return dependencies

    def __getitem__(self, key):
        """Enable slicing of img files"""
        if self.data is not None:
            if self.select_dataset is None:
                return self.data[key]
            else:
                return self.data[self.select_dataset][key]
        else:
            raise ValueError("Slicing is currently only supported when the object has been initialized with readall")

    def close_file(self):
        """Close the mzml file"""
        pass

    @classmethod
    def is_valid_dataset(cls, name):
        """Check whether the given file or directory points to a img file.

           :param name: Name of the dir or file.
           :type name: String

           :returns: Boolean indicating whether the given file or folder is a valid img file.
        """
        if os.path.isdir(name):  # If we point to a directory, check if the dir contains an mzML file
            filelist = cls.get_files_from_dir(name)
            return len(filelist) > 0
        else:
            try:
                # Try to open the file and iterate over it (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.driver.cl_analysis_driver:276
==omsi.workflow.driver.cl_workflow_driver:310
        if self.output_save_arg_name in parsed_arguments and mpi_helper.get_rank() == self.mpi_root:
            # Determine the filename and experiment group from the path
            self.output_target = parsed_arguments.pop(self.output_save_arg_name)
            if self.output_target is not None:
                output_filename, output_object_path = omsi_file_common.parse_path_string(self.output_target)
                # Create the output file
                if output_filename is None:
                    raise ValueError("ERROR: Invalid save parameter specification " + self.output_target)
                elif os.path.exists(output_filename) and not os.path.isfile(output_filename):
                    raise ValueError("ERROR: Save parameter not specify a file.")
                if not os.path.exists(output_filename):
                    out_file = omsi_file(output_filename, mode='a')
                    self.output_target = out_file.create_experiment()
                    self. __output_target_self = output_filename
                else:
                    out_file = omsi_file(output_filename, mode='r+')
                    if output_object_path is not None:
                        self.output_target = omsi_file_common.get_omsi_object(out_file[output_object_path])
                    else:
                        if out_file.get_num_experiments() > 0:
                            self.output_target = out_file.get_experiment(0)
                        else:
                            self.output_target = out_file.create_experiment()
        else:
            self.output_target = parsed_arguments.pop(self.output_save_arg_name)

        # The --loglovel argument (duplicate-code)
R:  1, 0: Similar lines in 3 files
==omsi.workflow.analysis_driver.omsi_cl_driver:412
==omsi.workflow.driver.cl_analysis_driver:392
==omsi.workflow.driver.cl_workflow_driver:575
        success = False
        if self.__output_target_self is not None:
            try:
                os.remove(self.__output_target_self)
                log_helper.info(__name__, "Successfully removed output target: " + unicode(self.__output_target_self))
                success = True
            except:
                log_helper.error(__name__, "Clean-up of output failed. File may be left on system: "
                                 + unicode(self.__output_target_self))
        elif self.output_target is not None:
            log_helper.info(__name__, "Output target not removed because it was not created " +
                                      "by the analysis but potentially modified by it")
        else:
            success = True
        return success

    def main(self):
        """
        Default main function for running an analysis from the command line.
        The default implementation exposes all specified analysis parameters as command
        line options to the user. The default implementation also provides means to
        print a help text for the function.

        :raises: ValueError is raised in case that the analysis class is unknown
        """
        # Get the analysis object if needed (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:292
==omsi.workflow.driver.cl_workflow_driver:312
            self.output_target = parsed_arguments.pop(self.output_save_arg_name)
            if self.output_target is not None:
                output_filename, output_object_path = omsi_file_common.parse_path_string(self.output_target)
                # Create the output file
                if output_filename is None:
                    raise ValueError("ERROR: Invalid save parameter specification " + self.output_target)
                elif os.path.exists(output_filename) and not os.path.isfile(output_filename):
                    raise ValueError("ERROR: Save parameter not specify a file.")
                if not os.path.exists(output_filename):
                    out_file = omsi_file(output_filename, mode='a')
                    self.output_target = out_file.create_experiment()
                    self. __output_target_self = output_filename
                else:
                    out_file = omsi_file(output_filename, mode='r+')
                    if output_object_path is not None:
                        self.output_target = omsi_file_common.get_omsi_object(out_file[output_object_path])
                    else:
                        if out_file.get_num_experiments() > 0:
                            self.output_target = out_file.get_experiment(0)
                        else:
                            self.output_target = out_file.create_experiment()
        else:
            self.output_target = parsed_arguments.pop(self.output_save_arg_name)

        # Process the --profile profiling argument
        if self.profile_arg_name in parsed_arguments: (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:212
==omsi.workflow.driver.cl_analysis_driver:220
                              if arg_param.get_group_name() is not None}
            for group_name, group_description in arg_group_dict.iteritems():
                self.custom_argument_groups[group_name] = self.parser.add_argument_group(title=group_name,
                                                                                         description=group_description)

        # Create the optional positional argument for the analysis class
        if self.add_analysis_class_arg:
            self.parser.add_argument(self.analysis_class_arg_name,
                                     help='The omsi.analysis class.')

        # Add the argument for defining where we should save the analysis
        if self.add_output_arg:
            output_arg_help = 'Define the file and experiment where the analysis should be stored. ' + \
                              'A new file will be created if the given file does not exists ' + \
                              'but the directory does. The filename is expected to be of the from:  ' + \
                              '<filename>:<entry_#> . If no experiment index is given, then ' + \
                              'experiment index 0 (i.e, entry_0) will be assumed by default. A valid' + \
                              'path may, e.g, be "test.h5:/entry_0" or jus "test.h5"'
            self.parser.add_argument("--"+self.output_save_arg_name,
                                     action='store',
                                     default=None,
                                     type=str,
                                     required=False,
                                     help=output_arg_help)

        # Add the optional keyword argument for enabling profiling of the analysis (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:292
==omsi.workflow.driver.cl_analysis_driver:278
            self.output_target = parsed_arguments.pop(self.output_save_arg_name)
            if self.output_target is not None:
                output_filename, output_object_path = omsi_file_common.parse_path_string(self.output_target)
                # Create the output file
                if output_filename is None:
                    raise ValueError("ERROR: Invalid save parameter specification " + self.output_target)
                elif os.path.exists(output_filename) and not os.path.isfile(output_filename):
                    raise ValueError("ERROR: Save parameter not specify a file.")
                if not os.path.exists(output_filename):
                    out_file = omsi_file(output_filename, mode='a')
                    self.output_target = out_file.create_experiment()
                    self. __output_target_self = output_filename
                else:
                    out_file = omsi_file(output_filename, mode='r+')
                    if output_object_path is not None:
                        self.output_target = omsi_file_common.get_omsi_object(out_file[output_object_path])
                    else:
                        if out_file.get_num_experiments() > 0:
                            self.output_target = out_file.get_experiment(0)
                        else:
                            self.output_target = out_file.create_experiment()
        else:
            self.output_target = parsed_arguments.pop(self.output_save_arg_name)

        # Process the --profile profiling argument (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.base:1252
==omsi.datastructures.analysis_data:550
    def add_parameter(self,
                      name,
                      help,
                      dtype=unicode,
                      required=False,
                      default=None,
                      choices=None,
                      data=None,
                      group=None):
        """
        Add a new parameter for the analysis. This function is typically used in the constructor
        of a derived analysis to specify the parameters of the analysis.

        :param name: The name of the parameter
        :param help: Help string describing the parameter
        :param type: Optional type. Default is string.
        :param required: Boolean indicating whether the parameter is required (True) or optional (False). Default False.
        :param default: Optional default value for the parameter. Default None.
        :param choices: Optional list of choices with allowed data values. Default None, indicating no choices set.
        :param data: The data assigned to the parameter. None by default.
        :param group: Optional group string used to organize parameters. Default None, indicating that
            parameters are automatically organized by driver class (e.g. in required and optional parameters)

        :raises: ValueError is raised if the parameter with the given name already exists.
        """ (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.base:650
==omsi.analysis.multivariate_stats.omsi_cx:271
        return None, None

    @classmethod
    def v_qmz(cls,
              analysis_object,
              qslice_viewer_option=0,
              qspectrum_viewer_option=0):
        """
        Get the mz axes for the analysis

        :param analysis_object: The omsi_file_analysis object for which slicing should be performed
        :param qslice_viewer_option: If multiple default viewer behaviors are available for a given
            analysis then this option is used to switch between them for the qslice URL pattern.
        :param qspectrum_viewer_option: If multiple default viewer behaviors are available for a
            given analysis then this option is used to switch between them for the qspectrum URL pattern.

        :returns: The following four arrays are returned by the analysis:

            - mz_spectra : Array with the static mz values for the spectra.
            - label_spectra : Lable for the spectral mz axis
            - mz_slice : Array of the static mz values for the slices or None if identical to the mz_spectra.
            - label_slice : Lable for the slice mz axis or None if identical to label_spectra.
        """

        """EDIT_ME: Define the number of custom viewer options for qslice and qspectrum.""" (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.findpeaks.omsi_findpeaks_global:20
==omsi.analysis.findpeaks.omsi_findpeaks_local:21
        self.analysis_identifier = name_key
        dtypes = self.get_default_dtypes()
        groups = self.get_default_parameter_groups()
        self.add_parameter(name='msidata',
                           help='The MSI dataset to be analyzed',
                           dtype=dtypes['ndarray'],
                           group=groups['input'],
                           required=True)
        self.add_parameter(name='mzdata',
                           help='The m/z values for the spectra of the MSI dataset',
                           dtype=dtypes['ndarray'],
                           group=groups['input'],
                           required=True)
        self.add_parameter(name='integration_width',
                           help='The window over which peaks should be integrated',
                           dtype=float,
                           default=0.1,
                           group=groups['settings'],
                           required=True)
        self.add_parameter(name='peakheight',
                           help='Peak height parameter',
                           dtype=int, (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.base:725
==omsi.analysis.msi_filtering.omsi_tic_norm:338
            mz_slice = None
            label_slice = None

        return mz_spectra, label_spectra, mz_slice, label_slice, valuesX, labelX, valuesY, labelY, valuesZ, labelZ

    @classmethod
    def v_qspectrum_viewer_options(cls,
                                   analysis_object):
        """Get a list of strings describing the different default viewer options for the analysis for qspectrum.
           The default implementation tries to take care of handling the spectra retrieval for all the depencies
           but can naturally not decide how the qspectrum should be handled by a derived class. However, this
           implementation is often called at the end of custom implementations to also allow access to data from
           other dependencies.

            :param analysis_object: The omsi_file_analysis object for which slicing should be performed.  For most cases
                   this is not needed here as the support for slice operations is usually a static decission based
                   on the class type, however, in some cases additional checks may be needed (e.g., ensure that
                   the required data is available).

            :returns: List of strings indicating the different available viewer options. The list should be empty
                    if the analysis does not support qspectrum requests (i.e., v_qspectrum(...) is not available).
        """ (duplicate-code)
R:  1, 0: Similar lines in 3 files
==omsi.analysis.base:650
==omsi.analysis.msi_filtering.omsi_tic_norm:262
==omsi.analysis.multivariate_stats.omsi_cx:271
        return None, None

    @classmethod
    def v_qmz(cls,
              analysis_object,
              qslice_viewer_option=0,
              qspectrum_viewer_option=0):
        """
        Get the mz axes for the analysis

        :param analysis_object: The omsi_file_analysis object for which slicing should be performed
        :param qslice_viewer_option: If multiple default viewer behaviors are available for a given
            analysis then this option is used to switch between them for the qslice URL pattern.
        :param qspectrum_viewer_option: If multiple default viewer behaviors are available for a
            given analysis then this option is used to switch between them for the qspectrum URL pattern.

        :returns: The following four arrays are returned by the analysis:

            - mz_spectra : Array with the static mz values for the spectra.
            - label_spectra : Lable for the spectral mz axis
            - mz_slice : Array of the static mz values for the slices or None if identical to the mz_spectra.
            - label_slice : Lable for the slice mz axis or None if identical to label_spectra. (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.msi_filtering.omsi_tic_norm:362
==omsi.analysis.multivariate_stats.omsi_cx:400
        spectrum_viewer_options = custom_options + dependent_options
        return spectrum_viewer_options

    @classmethod
    def v_qslice_viewer_options(cls,
                                analysis_object):
        """
        Get a list of strings describing the different default viewer options for the analysis for qslice.
        The default implementation tries to take care of handling the spectra retrieval for all the depencies
        but can naturally not decide how the qspectrum should be handled by a derived class. However, this
        implementation is often called at the end of custom implementations to also allow access to data from
        other dependencies.

        :param analysis_object: The omsi_file_analysis object for which slicing should be performed.  For
            most cases this is not needed here as the support for slice operations is usually a static
            decision based on the class type, however, in some cases additional checks may be needed (e.g.,
            ensure that the required data is available).

        :returns: List of strings indicating the different available viewer options. The list should be empty if
                  the analysis does not support qslice requests (i.e., v_qslice(...) is not available).
        """ (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.driver.cl_analysis_driver:248
==omsi.workflow.driver.cl_workflow_driver:284
                                                      action='store',
                                                      default='INFO',
                                                      required=False,
                                                      help='Specify the level of logging to be used.',
                                                      choices=log_helper.log_levels.keys())

    def parse_cl_arguments(self):
        """
        The function assumes that the command line parser has been setup using the initialize_argument_parser(..)

        This function parses all arguments that are specific to the command-line parser itself. Analysis workflow
        arguments are added and parsed later by the add_and_parse_workflow_arguments(...) function.
        The reason for this is two-fold: i) to separate the parsing of analysis arguments and arguments of the
        command-line driver and ii) if the same HDF5 file is used as input and output target, then we need to
        open it first here in append mode before it gets opened in read mode later by the arguments.

        *Side effects:* The function sets:

            - ``self.output_target``
            - ``self.profile_analyses`` (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.driver.cl_analysis_driver:194
==omsi.workflow.driver.cl_workflow_driver:210
        parser_epilog = "how to specify ndarray data? \n" \
                        "---------------------------- \n" +\
                        "n-dimensional arrays stored in OpenMSI data files may be specified as \n" + \
                        "input parameters via the following syntax: \n" + \
                        "      -- MSI data: <filename>.h5:/entry_#/data_# \n" + \
                        "      -- Analysis data: <filename>.h5:/entry_#/analysis_#/<dataname> \n" + \
                        "      -- Arbitrary dataset: <filename>.h5:<object_path>\n" + \
                        "E.g. a valid definition may look like: 'test_brain_convert.h5:/entry_0/data_0'\n" + \
                        "In rear cases we may need to manually define an array (e.g., a mask)\n" + \
                        "Here we can use standard python syntax, e.g, '[1,2,3,4]' or '[[1, 3], [4, 5]]' \n" + \
                        "Remember to include the array string in quotes. \n" + \
                        "\n\n" + \
                        "This command-line tool has been auto-generated by BASTet (Berkeley Analysis & Storage Toolkit)"

        self.parser = argparse.ArgumentParser(description=parser_description,
                                              epilog=parser_epilog,
                                              formatter_class=RawDescriptionDefaultHelpArgParseFormatter,
                                              add_help=False)  # We'll add the help later in

        # Create the argument group for required and optional arguments (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:324
==omsi.workflow.driver.cl_analysis_driver:303
        if self.log_level_arg_name in parsed_arguments:
            user_log_level = parsed_arguments.pop(self.log_level_arg_name)
            if user_log_level in log_helper.log_levels.keys():
                log_helper.set_log_level(level=log_helper.log_levels[user_log_level])
            else:
                log_helper.error(module_name=__name__, message="Invalid log level specified")

    def add_and_parse_analysis_arguments(self):
        """
        The function assumes that the command line parser has been setup using the initialize_argument_parser(..)

        This function is responsible for adding all command line arguments that are specific to the analysis and
        to then parse those argument and save the relevant data in the self.analysis_arguments dictionary.
        Command-line arguments that are specific to the command line driver are removed, so that only
        arguments that can be consumed by the analysis are handed to the analysis.

        *Side effects:* The function sets ``self.analysis_arguments``

        """
        # Add all arguments from our analysis object (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.compound_stats.omsi_score_midas:182
==omsi.analysis.compound_stats.omsi_score_pactolus:162
        num_spectra = fpl_peak_arrayindex.shape[0]
        if spectrum_indexes is None:
            # Get the complete peak array index data
            spectrum_indexes = np.arange(0, num_spectra)
            enable_parallel = True
        else:
            if isinstance(spectrum_indexes, int):
                spectrum_indexes = np.asarray([spectrum_indexes, ])
            enable_parallel = False

        #############################################################
        # Parallel execution using MPI
        #############################################################
        # We have more than a single core AND we have multiple spectra to process
        if mpi_helper.get_size() > 1 and len(spectrum_indexes) > 1:
            # We were not asked to process a specific data subblock from a parallel process
            # but we need to initiate the parallel processing.
            if enable_parallel: (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.base:529
==omsi.analysis.multivariate_stats.omsi_cx:152
    @classmethod
    def v_qslice(cls,
                 analysis_object,
                 z,
                 viewer_option=0):
        """
        Get 3D analysis dataset for which z-slices should be extracted for presentation in the OMSI viewer

        :param analysis_object: The omsi_file_analysis object for which slicing should be performed
        :param z: Selection string indicting which z values should be selected.
        :param viewer_option: If multiple default viewer behaviors are available for a given analysis
            then this option is used to switch between them.

        :returns: numpy array with the data to be displayed in the image slice viewer. Slicing will
            be performed typically like [:,:,zmin:zmax].

        """
        # Convert the z selection to a python selection (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:180
==omsi.workflow.driver.cl_analysis_driver:187
        if self.analysis_class is not None:
            parser_description = "class description: \n\n" + \
                                 self.analysis_class.__doc__ + " \n\n" + \
                                 "execution description: \n\n" + \
                                 self.analysis_class.execute_analysis.__doc__
        else:
            parser_description = "NO ANALYSIS CLASS GIVEN"
        parser_epilog = "how to specify ndarray data? \n" \
                        "---------------------------- \n" +\
                        "n-dimensional arrays stored in OpenMSI data files may be specified as \n" + \
                        "input parameters via the following syntax: \n" + \
                        "      -- MSI data: <filename>.h5:/entry_#/data_# \n" + \
                        "      -- Analysis data: <filename>.h5:/entry_#/analysis_#/<dataname> \n" + \
                        "      -- Arbitrary dataset: <filename>.h5:<object_path>\n" + \
                        "E.g. a valid definition may look like: 'test_brain_convert.h5:/entry_0/data_0'\n" + \
                        "In rear cases we may need to manually define an array (e.g., a mask)\n" + \
                        "Here we can use standard python syntax, e.g, '[1,2,3,4]' or '[[1, 3], [4, 5]]' \n" + \ (duplicate-code)
R:  1, 0: Similar lines in 3 files
==omsi.analysis.base:529
==omsi.analysis.msi_filtering.omsi_tic_norm:171
==omsi.analysis.multivariate_stats.omsi_cx:152
    @classmethod
    def v_qslice(cls,
                 analysis_object,
                 z,
                 viewer_option=0):
        """
        Get 3D analysis dataset for which z-slices should be extracted for presentation in the OMSI viewer

        :param analysis_object: The omsi_file_analysis object for which slicing should be performed
        :param z: Selection string indicting which z values should be selected.
        :param viewer_option: If multiple default viewer behaviors are available for a given analysis
            then this option is used to switch between them.

        :returns: numpy array with the data to be displayed in the image slice viewer. Slicing will
            be performed typically like [:,:,zmin:zmax].

        """ (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.compound_stats.omsi_score_midas:103
==omsi.analysis.compound_stats.omsi_score_pactolus:77
                           group=groups['settings'])
        # Parallel execution parameters
        self.add_parameter(name='schedule',
                           help='Scheduling to be used for parallel MPI runs',
                           dtype=str,
                           required=False,
                           choices=mpi_helper.parallel_over_axes.SCHEDULES.values(),
                           group=groups['parallel'],
                           default=mpi_helper.parallel_over_axes.SCHEDULES['DYNAMIC'])
        self.add_parameter(name='collect',
                           help='Collect results to the MPI root rank when running in parallel',
                           dtype=dtypes['bool'],
                           required=False,
                           group=groups['parallel'],
                           default=True) (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.base:1381
==omsi.analysis.generic:300
    def read_from_omsi_file(self,
                            analysis_object,
                            load_data=True,
                            load_parameters=True,
                            load_runtime_data=True,
                            dependencies_omsi_format=True,
                            ignore_type_conflict=False):
        """
        See `omsi.analysis.analysis_base.read_from_omsi_file(...)` for details.
        The function is overwritten here mainly to initialize the self.real_analysis_type
        instance variable but otherwise uses the default behavior.

        """
        # Attempt to add all analysis parameters to avoid warnings when setting the parameters during
        # the data load process, when we would set parameters that are not defined yet (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.findpeaks.omsi_findpeaks_global:43
==omsi.analysis.findpeaks.omsi_findpeaks_local:44
                           group=groups['settings'],
                           required=True)
        self.add_parameter(name='slwindow',
                           help='Sliding window parameter',
                           dtype=int,
                           default=100,
                           group=groups['settings'],
                           required=True)
        self.add_parameter(name='smoothwidth',
                           help='Smooth width parameter',
                           dtype=int,
                           default=3,
                           group=groups['settings'],
                           required=True) (duplicate-code)
R:  1, 0: Similar lines in 4 files
==omsi.workflow.analysis_driver.omsi_cl_driver:363
==omsi.workflow.driver.cl_analysis_driver:344
==omsi.workflow.driver.cl_workflow_driver:442
==omsi.workflow.driver.cl_workflow_driver:478
                        argument_group.add_argument(arg_name,               # <-- Required, user specified arg name
                                                    action=arg_action,      #     Constant. We define this not the user.
                                                    # nargs=1,                    Don't use. Leave as default
                                                    # const=None,                 Don't use this type of action
                                                    default=arg_default,    # <-- Optional default value of the argument
                                                    type=arg_type,          # <-- Optional dtype of the argument
                                                    choices=arg_choices,    # <-- Optional Key may be missing.
                                                    required=arg_required,  # <-- Optional
                                                    help=arg_help,          # <-- Required
                                                    # metavar               #     Don't use. Positional analysis
                                                    #                       #     arguments are not allowed
                                                    dest=arg_dest)          #     Automatically determined by the name
 (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:60
==omsi.workflow.driver.cl_workflow_driver:93
    output_save_arg_name = 'save'
    """Name of the key-word argument used to define"""

    profile_arg_name = 'profile'
    """Name of the keyword argument used to enable profiling of the analysis"""

    profile_mem_arg_name = 'memprofile'
    """Name of the keyword argument used to enable profiling of memory usage of an analysis"""

    log_level_arg_name = 'loglevel'
    """Name of the keyword argument used to specify the level of logging to be used"""

    def __init__(self, (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:385
==omsi.workflow.driver.cl_analysis_driver:364
        parsed_arguments.pop(self.log_level_arg_name, None)
        self.analysis_arguments = parsed_arguments

    def print_settings(self):
        """
        Print the analysis settings.
        """
        log_helper.info(__name__, "Inputs:")
        for key, value in self.analysis_arguments.iteritems():
            log_helper.info(__name__, "   " + unicode(key) + " = " + unicode(value))
        if self.output_target is not None:
            if isinstance(self.output_target, omsi_file_common):
                h5py_object = omsi_file_common.get_h5py_object(self.output_target) (duplicate-code)
R:  1, 0: Similar lines in 3 files
==omsi.analysis.compound_stats.omsi_score_midas:105
==omsi.analysis.compound_stats.omsi_score_pactolus:79
==omsi.analysis.findpeaks.omsi_findpeaks_local:64
        self.add_parameter(name='schedule',
                           help='Scheduling to be used for parallel MPI runs',
                           dtype=str,
                           required=False,
                           choices=mpi_helper.parallel_over_axes.SCHEDULES.values(),
                           group=groups['parallel'],
                           default=mpi_helper.parallel_over_axes.SCHEDULES['DYNAMIC'])
        self.add_parameter(name='collect',
                           help='Collect results to the MPI root rank when running in parallel',
                           dtype=dtypes['bool'],
                           required=False,
                           group=groups['parallel'],
                           default=True) (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.compound_stats.omsi_score_midas:205
==omsi.analysis.compound_stats.omsi_score_pactolus:186
                    main_data=spectrum_indexes,                             # Process the spectra independently
                    split_axes=split_axis,                                  # Split along axes
                    main_data_param_name='spectrum_indexes',                # data input param
                    root=self.mpi_root,                                     # The root MPI task
                    schedule=self['schedule'],                              # Parallel scheduling scheme
                    comm=self.mpi_comm)                                     # MPI communicator
                # Execute the analysis in parallel
                result = scheduler.run()
                # Collect the output data to the root rank if requested
                if self['collect']:
                    result = scheduler.collect_data()

                # Compile the data from the parallel execution (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.dataformat.imzml_file:162
==omsi.dataformat.mzml_file:266
    @classmethod
    def test(cls):
        """
        Test method
        """
        pass

    @staticmethod
    def __compute_num_scans(filename=None):
        """
        Internal helper function used to compute the number of scans in the mzml file.
        """ (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.dataformat.img_file:249
==omsi.dataformat.mzml_file:523
        else:
            return None

    @classmethod
    def get_files_from_dir(cls, dirname):
        """
        Get a list of all basenames of all img files in a given directory.
        Note: The basenames include the dirname.
        """
        filelist = []
        for l in os.listdir(dirname):
            currname = os.path.join(dirname, l) (duplicate-code)
R:  1, 0: Similar lines in 3 files
==omsi.workflow.analysis_driver.omsi_cl_driver:461
==omsi.workflow.driver.cl_analysis_driver:441
==omsi.workflow.driver.cl_workflow_driver:621
        except:
            self.remove_output_target()
            raise

        # Print the analysis settings
        if mpi_helper.get_rank() == self.mpi_root:
            self.print_settings()

        # Call the execute function of the analysis
        try:
            # Create the analysis object (duplicate-code)
R:  1, 0: Similar lines in 3 files
==omsi.dataformat.img_file:250
==omsi.dataformat.imzml_file:289
==omsi.dataformat.mzml_file:524
            return None

    @classmethod
    def get_files_from_dir(cls, dirname):
        """
        Get a list of all basenames of all img files in a given directory.
        Note: The basenames include the dirname.
        """
        filelist = []
        for l in os.listdir(dirname):
            currname = os.path.join(dirname, l) (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.base:572
==omsi.analysis.findpeaks.omsi_findpeaks_global:78
        else:
            return None

    @classmethod
    def v_qspectrum(cls,
                    analysis_object,
                    x,
                    y,
                    viewer_option=0):
        """
        Get from which 3D analysis spectra in x/y should be extracted for presentation in the OMSI viewer (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:187
==omsi.workflow.driver.cl_workflow_driver:210
        parser_epilog = "how to specify ndarray data? \n" \
                        "---------------------------- \n" +\
                        "n-dimensional arrays stored in OpenMSI data files may be specified as \n" + \
                        "input parameters via the following syntax: \n" + \
                        "      -- MSI data: <filename>.h5:/entry_#/data_# \n" + \
                        "      -- Analysis data: <filename>.h5:/entry_#/analysis_#/<dataname> \n" + \
                        "      -- Arbitrary dataset: <filename>.h5:<object_path>\n" + \
                        "E.g. a valid definition may look like: 'test_brain_convert.h5:/entry_0/data_0'\n" + \
                        "In rear cases we may need to manually define an array (e.g., a mask)\n" + \
                        "Here we can use standard python syntax, e.g, '[1,2,3,4]' or '[[1, 3], [4, 5]]' \n" + \ (duplicate-code)
R:  1, 0: Similar lines in 3 files
==omsi.workflow.analysis_driver.omsi_cl_driver:490
==omsi.workflow.driver.cl_analysis_driver:458
==omsi.workflow.driver.cl_workflow_driver:655
        except:
            if mpi_helper.get_rank() == self.mpi_root:
                self.remove_output_target()
            raise

        # Finalize the saving of results on rank our mpi root rank. NOTE: When running in serial
        # the condition of  mpi_helper.get_rank() ==  self.mpi_root evaluates to True because
        # our mpi_root is 0 and the mpi_helper returns 0 for the rank when running in serial.
        if mpi_helper.get_rank() == self.mpi_root:
            # Print the profiling results of time and usage (duplicate-code)
R:  1, 0: Similar lines in 3 files
==omsi.analysis.findpeaks.omsi_findpeaks_global:79
==omsi.analysis.msi_filtering.omsi_tic_norm:201
==omsi.analysis.multivariate_stats.omsi_cx:209
            return None

    @classmethod
    def v_qspectrum(cls,
                    analysis_object,
                    x,
                    y,
                    viewer_option=0):
        """Implement support for qspectrum URL requests for the viewer"""
        # Get the h5py dataset with the peak_cube data (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.findpeaks.omsi_findpeaks_global:117
==omsi.analysis.findpeaks.omsi_findpeaks_local:179
    @classmethod
    def v_qmz(cls,
              analysis_object,
              qslice_viewer_option=0,
              qspectrum_viewer_option=0):
        """Implement support for qmz URL requests for the viewer"""
        mz_spectra = None
        label_spectra = None
        mz_slice = None
        label_slice = None (duplicate-code)
R:  1, 0: Similar lines in 3 files
==omsi.analysis.compound_stats.omsi_score_midas:208
==omsi.analysis.compound_stats.omsi_score_pactolus:189
==omsi.analysis.findpeaks.omsi_findpeaks_local:368
                                                          root=self.mpi_root,                   # The root MPI task
                                                          schedule=self['schedule'],            # Parallel schedule
                                                          comm=self.mpi_comm)                   # MPI communicator
                # Execute the analysis in parallel
                result = scheduler.run()
                # Collect the output data to the root rank if requested
                if self['collect']:
                    result = scheduler.collect_data()

                # TODO Record runtime information data from the scheduler in our provenance data (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.driver.cl_analysis_driver:373
==omsi.workflow.driver.cl_workflow_driver:529
            log_helper.info(__name__, "   " + unicode(key) + " = " + unicode(value))
        if self.output_target is not None:
            if isinstance(self.output_target, omsi_file_common):
                h5py_object = omsi_file_common.get_h5py_object(self.output_target)
                log_helper.info(__name__, "Save to: " + unicode(h5py_object.file.filename)
                                + u":" + unicode(h5py_object.name))
            else:
                log_helper.info(__name__, "Save to: " + unicode(self.output_target))
 (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:200
==omsi.workflow.driver.cl_analysis_driver:208
        self.parser = argparse.ArgumentParser(description=parser_description,
                                              epilog=parser_epilog,
                                              formatter_class=RawDescriptionDefaultHelpArgParseFormatter,
                                              add_help=False)  # We'll add the help later in

        # Create the argument group for required arguments
        self.required_argument_group = self.parser.add_argument_group(title="required analysis arguments")

        # Create custom argument groups from the analysis (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.base:649
==omsi.analysis.findpeaks.omsi_findpeaks_local:176
        else:
            return None, None

    @classmethod
    def v_qmz(cls,
              analysis_object,
              qslice_viewer_option=0,
              qspectrum_viewer_option=0):
        """Implement support for qmz URL requests for the viewer""" (duplicate-code)
R:  1, 0: Similar lines in 4 files
==omsi.analysis.base:575
==omsi.analysis.generic:256
==omsi.analysis.msi_filtering.omsi_tic_norm:203
==omsi.analysis.multivariate_stats.omsi_cx:211
    @classmethod
    def v_qspectrum(cls,
                    analysis_object,
                    x,
                    y,
                    viewer_option=0):
        """
        Get from which 3D analysis spectra in x/y should be extracted for presentation in the OMSI viewer
 (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.driver.cl_analysis_driver:509
==omsi.workflow.driver.cl_workflow_driver:707
                log_helper.info(__name__, "Time to execute analysis: " + exec_time_string,
                                root=self.mpi_root, comm=self.mpi_comm)
            except:
                raise

        # Save the analysis to file
        if self.output_target is not None:
            from omsi.dataformat.omsi_file.analysis import omsi_analysis_manager (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:231
==omsi.workflow.driver.cl_workflow_driver:252
                                                      action='store',
                                                      default=None,
                                                      type=str,
                                                      required=False,
                                                      help=output_arg_help)

        # Add the optional keyword argument for enabling profiling of the analysis
        if self.add_profile_arg: (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:259
==omsi.workflow.driver.cl_analysis_driver:246
        if self.add_log_level_arg:
            self.parser.add_argument("--"+self.log_level_arg_name,
                                     action='store',
                                     default='INFO',
                                     required=False,
                                     help='Specify the level of logging to be used.',
                                     choices=log_helper.log_levels.keys())
 (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.greedy_workflow_driver:47
==omsi.workflow.executor.greedy_executor:78
            num_tasks = 0
            num_tasks_ready = 0
            for analysis in all_analyses:
                if analysis.update_analysis:
                    num_tasks += 1
                    if len(analysis.check_ready_to_execute()) == 0:
                        num_tasks_ready += 1
            if num_tasks == 0: (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.dataformat.imzml_file:281
==omsi.dataformat.mzml_file:478
        basename = None
        if os.path.isdir(name):  # If we point to a directory, check if the dir contains an mzML file
            filelist = cls.get_files_from_dir(name)
            if len(filelist) > 0:
                basename = filelist[0]
        else:
            basename = name
        if basename is not None: (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.msi_filtering.omsi_tic_norm:300
==omsi.analysis.multivariate_stats.omsi_cx:321
            labelZ = 'pixel index Z'
        else:
            valuesZ = None
            labelZ = None

        # Both viewer_options point to a data dependency
        if qspectrum_viewer_option >= num_custom_spectrum_options and \
                qslice_viewer_option >= num_custom_slice_options: (duplicate-code)
R:  1, 0: Similar lines in 3 files
==omsi.analysis.findpeaks.omsi_findpeaks_local:177
==omsi.analysis.msi_filtering.omsi_tic_norm:262
==omsi.analysis.multivariate_stats.omsi_cx:271
        return None, None

    @classmethod
    def v_qmz(cls,
              analysis_object,
              qslice_viewer_option=0,
              qspectrum_viewer_option=0):
        """ (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.findpeaks.omsi_findpeaks_global:155
==omsi.analysis.multivariate_stats.omsi_nmf:129
                                                        qslice_viewer_option=qslice_viewer_option-1,
                                                        qspectrum_viewer_option=0)
            # NOTE: if qspectrum and qslice share the same axis, this call will not return the
            # copied data, i.e., we need to copy the qspectrum values to the qslice values.
            if mz_slice is None:
                mz_slice = temp_a
                label_slice = temp_b
        elif qspectrum_viewer_option > 0 and qslice_viewer_option == 0: (duplicate-code)
R:  1, 0: Similar lines in 6 files
==omsi.analysis.base:575
==omsi.analysis.findpeaks.omsi_findpeaks_global:81
==omsi.analysis.findpeaks.omsi_findpeaks_local:95
==omsi.analysis.generic:256
==omsi.analysis.msi_filtering.omsi_tic_norm:203
==omsi.analysis.multivariate_stats.omsi_cx:211
    @classmethod
    def v_qspectrum(cls,
                    analysis_object,
                    x,
                    y,
                    viewer_option=0):
        """
        Get from which 3D analysis spectra in x/y should be extracted for presentation in the OMSI viewer (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.findpeaks.omsi_findpeaks_global:81
==omsi.analysis.generic:256
    @classmethod
    def v_qspectrum(cls,
                    analysis_object,
                    x,
                    y,
                    viewer_option=0):
        """
        Implement support for qspectrum URL requests for the viewer (duplicate-code)
R:  1, 0: Similar lines in 4 files
==omsi.analysis.base:652
==omsi.analysis.generic:267
==omsi.analysis.msi_filtering.omsi_tic_norm:264
==omsi.analysis.multivariate_stats.omsi_cx:273
    @classmethod
    def v_qmz(cls,
              analysis_object,
              qslice_viewer_option=0,
              qspectrum_viewer_option=0):
        """
        Get the mz axes for the analysis
 (duplicate-code)
R:  1, 0: Similar lines in 5 files
==omsi.analysis.base:529
==omsi.analysis.findpeaks.omsi_findpeaks_local:83
==omsi.analysis.generic:246
==omsi.analysis.msi_filtering.omsi_tic_norm:171
==omsi.analysis.multivariate_stats.omsi_cx:152
    @classmethod
    def v_qslice(cls,
                 analysis_object,
                 z,
                 viewer_option=0):
        """Get 3D analysis dataset for which z-slices should be extracted for presentation in the OMSI viewer

           :param analysis_object: The omsi_file_analysis object for which slicing should be performed (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.driver.cl_analysis_driver:239
==omsi.workflow.driver.cl_workflow_driver:252
                                                      action='store',
                                                      default=None,
                                                      type=str,
                                                      required=False,
                                                      help=output_arg_help)

        # Add the optional keyword argument for enabling profiling of the analysis (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.driver.cl_analysis_driver:9
==omsi.workflow.driver.cl_workflow_driver:10
from omsi.workflow.common import RawDescriptionDefaultHelpArgParseFormatter
import omsi.shared.mpi_helper as mpi_helper
import numpy as np
import os
from omsi.shared.log import log_helper

# High-priority items (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:539
==omsi.workflow.driver.cl_analysis_driver:511
            except:
                raise

        # Save the analysis to file
        if self.output_target is not None:
            from omsi.dataformat.omsi_file.analysis import omsi_analysis_manager
            omsi_analysis_manager.create_analysis_static(analysis_parent=self.output_target, (duplicate-code)
R:  1, 0: Similar lines in 3 files
==omsi.workflow.analysis_driver.omsi_cl_driver:530
==omsi.workflow.driver.cl_analysis_driver:501
==omsi.workflow.driver.cl_workflow_driver:699
                    max_exec_time = str(exec_time_array.max())
                    min_exec_time = str(exec_time_array.min())
                    mean_exec_time = str(exec_time_array.mean())
                    exec_time_string = max_exec_time + " s " + \
                                       "    ( min = " + min_exec_time + " , mean = " + mean_exec_time + " )"
                # Serial case: We only have a single time to worry about
                else: (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:157
==omsi.workflow.driver.cl_analysis_driver:161
            raise

        # Determine the self.analysis parameter
        try:
            self.analysis_class = getattr(analysis_module_object, analysis_class_name)
        except AttributeError as e:
            log_helper.error(__name__, e.message) (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:69
==omsi.workflow.driver.cl_analysis_driver:53
    log_level_arg_name = 'loglevel'
    """Name of the keyword argument used to specify the level of logging to be used"""

    def __init__(self,
                 analysis_class,
                 add_analysis_class_arg=False,
                 add_output_arg=True, (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.msi_filtering.omsi_tic_norm:285
==omsi.analysis.multivariate_stats.omsi_cx:302
        num_custom_spectrum_options = 0

        # Compute the output
        mz_spectra = None
        label_spectra = None
        mz_slice = None
        label_slice = None (duplicate-code)
R:  1, 0: Similar lines in 3 files
==omsi.analysis.msi_filtering.omsi_tic_norm:24
==omsi.analysis.multivariate_stats.omsi_cx:23
==omsi.analysis.multivariate_stats.omsi_kmeans:16
        dtypes = self.get_default_dtypes()
        groups = self.get_default_parameter_groups()
        self.add_parameter(name='msidata',
                           help='The MSI matrix to be analyzed',
                           dtype=dtypes['ndarray'],
                           required=True,
                           group=groups['input']) (duplicate-code)
R:  1, 0: Similar lines in 3 files
==omsi.analysis.findpeaks.omsi_findpeaks_global:134
==omsi.analysis.findpeaks.omsi_findpeaks_local:199
==omsi.analysis.multivariate_stats.omsi_nmf:108
            labelZ = 'pixel index Z'
        else:
            valuesZ = None
            labelZ = None

        # We do not need to handle the qslice_viewer_option separately here since there is only one option right now
        if qspectrum_viewer_option == 0 and qslice_viewer_option == 0:  # Loadings (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:261
==omsi.workflow.driver.cl_workflow_driver:284
                                                      action='store',
                                                      default='INFO',
                                                      required=False,
                                                      help='Specify the level of logging to be used.',
                                                      choices=log_helper.log_levels.keys())
 (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:109
==omsi.workflow.driver.cl_workflow_driver:150
        self.add_output_arg = add_output_arg
        self.add_profile_arg = add_profile_arg
        self.add_mem_profile_arg = add_mem_profile_arg
        self.add_log_level_arg = add_log_level_arg
        self.parser = None
        self.required_argument_group = None (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.greedy_workflow_driver:38
==omsi.workflow.executor.greedy_executor:66
        all_analyses = self.get_analyses()
        iterations = 0
        while True:
            # Run all analyses that are ready
            for analysis in all_analyses:
                if analysis.update_analysis and len(analysis.check_ready_to_execute()) == 0: (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.tools.misc.create_peak_cube_overview:11
==omsi.tools.misc.make_thumb:2
from omsi.dataformat.omsi_file.main_file import omsi_file

try:
    from PIL import Image
except ImportError:
    import Image (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.compound_stats.omsi_score_midas:34
==omsi.analysis.compound_stats.omsi_score_pactolus:32
        self.add_parameter(name='fpl_data',
                           help='The raw findpeaks local dataset to be analyzed. Either the finpeaks local ' +
                                'group in the file or the omsi_findpeaks_local analysis object',
                           dtype=dtypes['ndarray'],
                           group=groups['input'],
                           required=True) (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.base:1279
==omsi.datastructures.analysis_data:579
                                                 help=help,
                                                 dtype=dtype,
                                                 required=required,
                                                 default=default,
                                                 choices=choices,
                                                 data=data, (duplicate-code)
R:  1, 0: Similar lines in 6 files
==omsi.analysis.base:652
==omsi.analysis.findpeaks.omsi_findpeaks_global:117
==omsi.analysis.findpeaks.omsi_findpeaks_local:179
==omsi.analysis.generic:267
==omsi.analysis.msi_filtering.omsi_tic_norm:264
==omsi.analysis.multivariate_stats.omsi_cx:273
    @classmethod
    def v_qmz(cls,
              analysis_object,
              qslice_viewer_option=0,
              qspectrum_viewer_option=0):
        """ (duplicate-code)
R:  1, 0: Similar lines in 6 files
==omsi.analysis.base:529
==omsi.analysis.findpeaks.omsi_findpeaks_global:60
==omsi.analysis.findpeaks.omsi_findpeaks_local:83
==omsi.analysis.generic:246
==omsi.analysis.msi_filtering.omsi_tic_norm:171
==omsi.analysis.multivariate_stats.omsi_cx:152
    @classmethod
    def v_qslice(cls,
                 analysis_object,
                 z,
                 viewer_option=0):
        """ (duplicate-code)
R:  1, 0: Similar lines in 3 files
==omsi.workflow.analysis_driver.omsi_cl_driver:225
==omsi.workflow.driver.cl_analysis_driver:233
==omsi.workflow.driver.cl_workflow_driver:246
                              'A new file will be created if the given file does not exists ' + \
                              'but the directory does. The filename is expected to be of the from:  ' + \
                              '<filename>:<entry_#> . If no experiment index is given, then ' + \
                              'experiment index 0 (i.e, entry_0) will be assumed by default. A valid' + \
                              'path may, e.g, be "test.h5:/entry_0" or jus "test.h5"' (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.workflow.analysis_driver.omsi_cl_driver:3
==omsi.workflow.driver.cl_analysis_driver:3
import sys
import argparse
from omsi.analysis.base import analysis_base
from omsi.dataformat.omsi_file.common import omsi_file_common
from omsi.dataformat.omsi_file.main_file import omsi_file (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.dataformat.imzml_file:36
==omsi.dataformat.mzml_file:47
        if os.path.isdir(basename):
            filelist = self.get_files_from_dir(basename)
            if len(filelist) > 0:
                basename = filelist[0]
            else: (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.generic:330
==omsi.dataformat.omsi_file.analysis:872
            load_data=load_data,
            load_parameters=load_parameters,
            load_runtime_data=load_runtime_data,
            dependencies_omsi_format=dependencies_omsi_format,
            ignore_type_conflict=ignore_type_conflict) (duplicate-code)
R:  1, 0: Similar lines in 2 files
==omsi.analysis.base:223
==omsi.analysis.generic:173
                                       link_name=None,
                                       dataname=key,
                                       omsi_object=self,
                                       selection=None,
                                       help=None) (duplicate-code)
