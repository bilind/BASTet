

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Developing a new Analysis for BASTet &mdash; BASTet: Berkeley Analysis and Storage Toolkit Documentation devel documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="BASTet: Berkeley Analysis and Storage Toolkit Documentation devel documentation" href="index.html"/>
        <link rel="next" title="Defining and Executing Analysis Workflows" href="basic_workflows.html"/>
        <link rel="prev" title="Integrating new file formats" href="custom_filereader.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="index.html" class="fa fa-home"> BASTet: Berkeley Analysis and Storage Toolkit Documentation</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="convert_files.html">Converting and Files and Making them Accessible</a><ul>
<li class="toctree-l2"><a class="reference internal" href="convert_files.html#converting-an-msi-file-at-nersc">Converting an MSI file at NERSC</a></li>
<li class="toctree-l2"><a class="reference internal" href="convert_files.html#making-a-converted-file-accessible-to-openmsi-private">Making a converted file accessible to OpenMSI (Private)</a></li>
<li class="toctree-l2"><a class="reference internal" href="convert_files.html#changing-file-permissions">Changing file permissions:</a></li>
<li class="toctree-l2"><a class="reference internal" href="convert_files.html#converttoomsi-usage-and-options"><code class="docutils literal"><span class="pre">convertToOMSI</span></code>: Usage and Options</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="custom_filereader.html">Integrating new file formats</a><ul>
<li class="toctree-l2"><a class="reference internal" href="custom_filereader.html#developing-a-file-reader">Developing a file reader</a></li>
<li class="toctree-l2"><a class="reference internal" href="custom_filereader.html#integrating-the-file-reader-with-openmsi">Integrating the file reader with OpenMSI</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Developing a new Analysis for BASTet</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#integrating-a-new-analysis-using-the-openmsi-analysis-template">Integrating a new Analysis using the OpenMSI Analysis Template</a></li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-customizing-core-features">Advanced: Customizing core features</a></li>
<li class="toctree-l2"><a class="reference internal" href="#wrapping-a-function-the-quick-and-dirty-way">Wrapping a function: The quick-and-dirty way</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="basic_workflows.html">Defining and Executing Analysis Workflows</a><ul>
<li class="toctree-l2"><a class="reference internal" href="basic_workflows.html#step-1-create-the-analysis-tasks">Step 1: Create the analysis tasks:</a></li>
<li class="toctree-l2"><a class="reference internal" href="basic_workflows.html#step-2-define-analysis-inputs">Step 2: Define analysis inputs:</a></li>
<li class="toctree-l2"><a class="reference internal" href="basic_workflows.html#step-3-execute">Step 3: Execute</a></li>
<li class="toctree-l2"><a class="reference internal" href="basic_workflows.html#example-normalizing-an-image">Example: Normalizing an image</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="basic_workflows.html#workflow-tools">Workflow Tools</a><ul>
<li class="toctree-l2"><a class="reference internal" href="basic_workflows.html#workflow-scripts">Workflow Scripts</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="HDF5_format.html">OMSI Data Format</a><ul>
<li class="toctree-l2"><a class="reference internal" href="HDF5_format.html#data-layout">Data Layout</a></li>
<li class="toctree-l2"><a class="reference internal" href="HDF5_format.html#accessing-omsi-data-files">Accessing OMSI data files</a></li>
<li class="toctree-l2"><a class="reference internal" href="HDF5_format.html#convert-mass-spectrometry-imaging-data-to-omsi-hdf5-format">Convert Mass Spectrometry Imaging Data to OMSI (HDF5) format</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="HDF5_format_performance.html">HDF5 I/O Performance</a><ul>
<li class="toctree-l2"><a class="reference internal" href="HDF5_format_performance.html#test-platforms">Test Platforms</a></li>
<li class="toctree-l2"><a class="reference internal" href="HDF5_format_performance.html#test-cases">Test Cases</a></li>
<li class="toctree-l2"><a class="reference internal" href="HDF5_format_performance.html#dataset-layout">Dataset Layout</a></li>
<li class="toctree-l2"><a class="reference internal" href="HDF5_format_performance.html#chunking-part-1">Chunking: Part 1</a></li>
<li class="toctree-l2"><a class="reference internal" href="HDF5_format_performance.html#chunking-part-2">Chunking: Part 2</a></li>
<li class="toctree-l2"><a class="reference internal" href="HDF5_format_performance.html#compression">Compression</a></li>
<li class="toctree-l2"><a class="reference internal" href="HDF5_format_performance.html#local-scalability-multi-processing">Local Scalability: Multi-processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="HDF5_format_performance.html#discussion">Discussion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="omsi.html">omsi Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="omsi.html#subpackages">Subpackages</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">BASTet: Berkeley Analysis and Storage Toolkit Documentation</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Developing a new Analysis for BASTet</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="_sources/custom_analysis.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="developing-a-new-analysis-for-bastet">
<h1>Developing a new Analysis for BASTet<a class="headerlink" href="#developing-a-new-analysis-for-bastet" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview:<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The OpenMSI Toolkit includes a basic template for implementing new analyses as part of OpenMSI. The template is located in <code class="docutils literal"><span class="pre">omsi.templates.omsi_analysis_template.py</span></code>. The template provides step-by-step instructions on how to implement a new analysis. Simply search top-to-bottom for EDIT_ME markers to find locations that need to be edited and what changes need to be made.</p>
<p>The implementation of a new analysis is divided into three main steps. We here provide a brief overview of these steps. A detailed walk-through the required implementation is provided in the following sections.</p>
<p><strong>Step 1) Basic integration of your analysis with OpenMSI (Required)</strong></p>
<blockquote>
<div><p>The basic integration is simple and should requires only minimal additional effort. The basic integration with the OpenMSI provides:</p>
<blockquote>
<div><ul class="simple">
<li>full integration of the analysis with the OpenMSI file format and API</li>
<li>full support for OpenMSI&#8217;s data provenance capabilities</li>
<li>full integration with analysis drivers (e.g, the command line driver) enabling direct execution of the analysis with automatic handling of user input specification, help, etc.</li>
<li>basic integration of the analysis with the website, in that a user will be able to browse the analysis in the online file browser. The basic integration automatically provides full support for the <code class="docutils literal"><span class="pre">qmetadata</span></code> and <code class="docutils literal"><span class="pre">qcube</span></code> URL data access patterns. The basic integration provides limited support for the <code class="docutils literal"><span class="pre">qslice</span></code>, <code class="docutils literal"><span class="pre">qspectrum</span></code>, and <code class="docutils literal"><span class="pre">qmz</span></code> patterns, in that it automatically exposes all dependencies of the analysis that support these patterns but it does not expose the data of the analysis itself. This is part of step 2.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>Step 2)  Integrating your analysis with the OpenMSI web-based viewer (Recommended)</strong></p>
<p>Once the basic integration is complete, you may want integrate your analysis fully with the OpenMSI online viewer, in order to make your analysis easily accesible to the OpenMSI user community. This step requires the implementation of the <code class="docutils literal"><span class="pre">qslice</span></code>, <code class="docutils literal"><span class="pre">qspectrum</span></code>, and <code class="docutils literal"><span class="pre">qmz</span></code> URL patterns for the analysis. This step completes the integration with the OpenMSI framework itself.</p>
<p><strong>Step 3) Making your analysis self-sufficient (Recommended)</strong></p>
<p>This step makes your analysis &#8220;self-sufficient&#8221; in that it allows you to execute your analysis from the command-line.</p>
<div class="section" id="some-important-features-of-analysis-base">
<h3>Some important features of <code class="docutils literal"><span class="pre">analysis_base</span></code><a class="headerlink" href="#some-important-features-of-analysis-base" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">omsi.analysis.analysis_base</span></code> is the base class for all omsi analysis functionality. The class provides a large set of functionality designed to facilitate i) storage of analysis data in the omsi HDF5 file format and ii) integration of new analysis capabilities with the OpenMSI web API and the OpenMSI web-based viewer (see Viewer functions below for details), iii) support for data provenance, and iv) in combination with the <cite>omsi_analysis_driver</cite> module enable the direct execution of analysis, e.g, from the command line</p>
<div class="section" id="slicing">
<h4>Slicing<a class="headerlink" href="#slicing" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal"><span class="pre">analysis_base</span></code> implements basic slicing to access data stored in the main member variables. By default the data is retrieved from __data_list by the __getitem__(key) function, which implements the [..] operator, i.e., the functions returns __data_list[key][&#8216;data&#8217;]. The key is a string indicating the name of the paramter to be retrieved. If the key is not found in the __data_list then the function will try to retrieve the data from __parameter_list instead. By adding &#8220;parameter/key&#8221; or &#8220;dependency/key&#8221; one may also explicitly retrieve values from the __parameter_list and __dependency_list.</p>
</div>
<div class="section" id="important-member-variables">
<h4>Important Member Variables<a class="headerlink" href="#important-member-variables" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">analysis_identifier</span></code> defines the name for the analysis used as key in search operations.</li>
<li><code class="docutils literal"><span class="pre">__data_list</span></code> defines a list of <code class="docutils literal"><span class="pre">omsi.analysis.analysis_data.analysis_data</span></code> objects to be written to the HDF5 file. Derived classes need to add all data that should be saved for the analysis in the omsi HDF5 file to this dictionary. See <code class="docutils literal"><span class="pre">omsi.analysis.analysis_data</span></code> for details.</li>
<li><code class="docutils literal"><span class="pre">parameters</span></code>  List of <code class="docutils literal"><span class="pre">parameter_data</span></code> to be written to the HDF5 file. Derived classes need to add all parameter data that should be saved for the analysis in the omsi HDF5 file to this dictionary using the provided <code class="docutils literal"><span class="pre">add_parameter(...)</span></code> function. See <code class="docutils literal"><span class="pre">omsi.analysis.analysis_data</span></code> and <code class="docutils literal"><span class="pre">add_parameter(..)</span></code> function of <code class="docutils literal"><span class="pre">analysis_base</span></code> for details.</li>
<li><code class="docutils literal"><span class="pre">data_names</span></code> is a list of strings of all names of analysis output datasets. These are the target names for __data_list. <strong>NOTE</strong> Names of parameters specified in <code class="docutils literal"><span class="pre">parameters</span></code> and <code class="docutils literal"><span class="pre">data_names</span></code> should be distinct.</li>
</ul>
</div>
<div class="section" id="i-o-functions">
<h4>I/O functions<a class="headerlink" href="#i-o-functions" title="Permalink to this headline">¶</a></h4>
<p>These functions can be optionally overwritten to control how the analysis data should be written/read from the omsi HDF5 file. Default implementations are provided here, which should be sufficient for most cases.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">write_analysis_data</span></code> By default all data is written by <code class="docutils literal"><span class="pre">omsi.dataformat.omsi_file.analysis.omsi_file_analysis</span></code>. By implementing this function we can implement the write for the main data (i.e., what is stored in self.__data_list) ourselves. In practice (at least in the serial case) this should not be needed. However, overwriting the function can be useful when implementing an analysis using MPI and we want to avoid gathering the data on rank the root rank (usually rank 0).</li>
<li><code class="docutils literal"><span class="pre">add_custom_data_to_omsi_file</span></code>: The default implementation is empty as the default data write is  managed by the omsi_file_experiment.create_analysis() function.  Overwrite this function, in case that the analysis needs to write data to the HDF5 omsi file beyond what the defualt omsi data API does.</li>
<li><code class="docutils literal"><span class="pre">read_from_omsi_file</span></code>: The default implementation tries to reconstruct the original data as far  as possible, however, in particular in case that a custom add_custom_data_to_omsi_file            funtion has been implemented, the default implementation may not be sufficien. The default implementation reconstructs: i) analysis_identifier and reads all custom data into ii)__data_list. Note, an error will be raised in case that the analysis type specified in the HDF5 file does not match the analysis type specified by get_analysis_type(). This function can be optionally overwritten to implement a custom data read.</li>
</ul>
</div>
<div class="section" id="web-api-functions">
<h4>Web API Functions<a class="headerlink" href="#web-api-functions" title="Permalink to this headline">¶</a></h4>
<p>Several convenient functions are used to allow the OpenMSI online viewer to interact with the analysis and to visualize it. The default implementations provided here simply indicate that the analysis does not support the data access operations required by the online viewer. Overwrite these functions in the derived analysis classes in order to interface them with the viewer. All viewer-related functions start with <code class="docutils literal"><span class="pre">v\_...</span></code> .</p>
<p>NOTE: the default implementation of the viewer functions defined in <code class="docutils literal"><span class="pre">analysis_base</span></code> are designed to take care of the common requirement for providing viewer access to data from all depencies of an analysis. In many cases, the default implementation is often sill called at the end of custom viewer functions.</p>
<p>NOTE: The viewer functions typically support a viewerOption parameter. viewerOption=0 is expected to refer to the analysis itself.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">v_qslice</span></code>: Retrieve/compute data slices as requested via qslice URL requests. The corrsponding view of the DJANGO data access server already translates all input parameters and takes care of generating images/plots if needed. This function is only responsible for retrieving the data.</li>
<li><code class="docutils literal"><span class="pre">v_qspectrum</span></code>: Retrieve/compute spectra as requested via qspectrum URL requests. The corrsponding view of the DJANGO data access server already translates all input parameters and takes care of generating images/plots if needed. This function is only responsible for retrieving the data.</li>
<li><code class="docutils literal"><span class="pre">v_qmz</span></code>: Define the m/z axes for image slices and spectra as requested by qspectrum URL requests.</li>
<li><code class="docutils literal"><span class="pre">v_qspectrum_viewer_options</span></code>: Define a list of strings, describing the different viewer options available for the analysis for qspectrum requests (i.e., <code class="docutils literal"><span class="pre">v_qspectrum</span></code>). This feature allows the analysis developer to define multiple different visualization modes for the analysis. For example, when performing a data rediction (e.g., PCA or NMF) one may want to show the raw spectra or the loadings vector of the projection in the spectrum view (v_qspectrum). By providing different viewer options we allow the user to decide which option they are most interested in.</li>
<li><code class="docutils literal"><span class="pre">v_qslice_viewer_options</span></code>: Define a list of strings, describing the different viewer options available for the analysis for qslice requests (i.e., <code class="docutils literal"><span class="pre">v_qslice</span></code>). This feature allows the analysis developer to define multiple different visualization modes for the analysis. For example, when performing a data rediction (e.g., PCA or NMF) one may want to show the raw spectra or the loadings vector of the projection in the spectrum view (v_qspectrum). By providing different viewer options we allow the user to decide which option they are most interested in.</li>
</ul>
</div>
<div class="section" id="executing-saving-and-restoring-an-analysis-object">
<h4>Executing, saving, and restoring an analysis object<a class="headerlink" href="#executing-saving-and-restoring-an-analysis-object" title="Permalink to this headline">¶</a></h4>
<p>Using the command-line driver we can directly execute analysis as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">python</span> <span class="n">omsi</span><span class="o">/</span><span class="n">analysis</span><span class="o">/</span><span class="n">omsi_analysis_driver</span> <span class="o">&lt;</span><span class="n">analysis_module_class</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">analysis_parameters</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>E.g. to execute a non-negative matrix factorization (NMF) using the <cite>omsi.analysis.multivariate_stats.omsi_nmf</cite> module we can simply:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">python</span> <span class="n">omsi</span><span class="o">/</span><span class="n">analysis</span><span class="o">/</span><span class="n">omsi_analysis_driver</span><span class="o">.</span><span class="n">py</span> <span class="n">multivariate_stats</span><span class="o">/</span><span class="n">omsi_nmf</span><span class="o">.</span><span class="n">py</span>
    <span class="o">--</span><span class="n">msidata</span> <span class="s">&quot;test_brain_convert.h5:/entry_0/data_0&quot;</span>
    <span class="o">--</span><span class="n">save</span> <span class="s">&quot;test_ana_save.h5&quot;</span>
</pre></div>
</div>
<p>Any analysis based on the infrastructure provided by <code class="docutils literal"><span class="pre">analysis_base</span></code> is fully integrated with OpenMSI file API provided by``omsi.dataformat.omsi_file``. This means the analysis can be directly saved to an OMSI HDF5 file and  the saved analysis can be restored from file. In OMSI files, analyses are generally associated with experiments, so that we use the <code class="docutils literal"><span class="pre">omsi.dataformat.omsi_file.omsi_file_experiment</span></code> API here.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</pre></div></td><td class="code"><div class="highlight"><pre><span class="c"># Open the MSI file and get the desired experiment</span>
<span class="kn">from</span> <span class="nn">omsi.dataformat.omsi_file</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">omsi_file</span><span class="p">(</span> <span class="n">filename</span><span class="p">,</span> <span class="s">&#39;a&#39;</span> <span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">get_experiment</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c"># Execute the analysis</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">get_msidata</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">omsi_myanalysis</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">msidata</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">integration_width</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">msidata_dependency</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>

<span class="c"># Save the analysis object.</span>
<span class="hll"><span class="n">analysis_object</span> <span class="p">,</span> <span class="n">analysis_index</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">create_analysis</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span>
</span>
<span class="c"># This single line is sufficient to store the complete analysis to the omsi file.</span>
<span class="c"># By default the call will block until the write is complete. Setting the</span>
<span class="c"># parameter flushIO=False enables buffered write, so that the call will</span>
<span class="c"># return once all data write operations have been scheduled. Here we get</span>
<span class="c"># an omsi.dataformat.omsi_file.omsi_file_analysis</span>
<span class="c"># object for management of the data stored in HDF5 and the integer index of the analysis.</span>

<span class="hll"><span class="c"># To restore an analysis from file, i.e., read all the analysis data from file</span>
</span><span class="hll"><span class="c"># and store it in a corresponding analysis object we can do the following.</span>
</span><span class="hll"><span class="c"># Similar to the read_from_omsi_file(...) function of analysis_base</span>
</span><span class="hll"><span class="c"># mentioned below, we can decide via parameter settings of the function,</span>
</span><span class="c"># which portions of the analysis should be loaded into memory</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">analysis_object</span><span class="o">.</span><span class="n">restore_analysis</span><span class="p">()</span>

<span class="c"># If we want to now re-execute the same analysis we can simply call</span>
<span class="n">a2</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>

<span class="c"># If we want to rerun the analysis but change one or more parameter settings,</span>
<span class="c"># then we can simply change those parameters when calling the execute function</span>
<span class="n">d2</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">get_msidata</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Get another MSI dataset</span>
<span class="n">a2</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">msidata</span><span class="o">=</span><span class="n">d2</span><span class="p">)</span>  <span class="c"># Execute the analysis on the new MSI dataset</span>

<span class="c"># The omsi_file_analysis class also provides a convenient function that allows us</span>
<span class="c"># to recreate, i.e., restore and run the analysis, in a single function call</span>
<span class="n">a3</span> <span class="o">=</span> <span class="n">analysis_object</span><span class="o">.</span><span class="n">recreate_analysis</span><span class="p">()</span>

<span class="c"># The recreate_analysis(...) function supports additional keyword arguments</span>
<span class="c"># which will be passed to the execute(...) call of the analysis, so that we</span>
<span class="c"># can change parameter settings for the analysis also when using the</span>
<span class="c"># recreate analysis call.</span>

<span class="c"># If we know the type of analysis object (which we can also get from file), then we</span>
<span class="c"># naturally also restore the analysis from file ourselves via</span>
<span class="n">a4</span> <span class="o">=</span> <span class="n">omsi_myanalysis</span><span class="p">()</span><span class="o">.</span><span class="n">read_from_omsi_file</span><span class="p">(</span><span class="n">analysisGroup</span><span class="o">=</span><span class="n">analysis_object</span><span class="p">,</span> \
                                           <span class="n">load_data</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> \
                                           <span class="n">load_parameters</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>\
                                           <span class="n">load_runtime_data</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> \
                                           <span class="n">dependencies_omsi_format</span><span class="o">=</span><span class="bp">True</span> <span class="p">)</span>
<span class="c"># By setting load_data and/or load_parameters to False, we create h5py instead of</span>
<span class="c"># numpy objects, avoiding the actual load of the data. CAUTION: To avoid the accidental</span>
<span class="c"># overwrite of data we recommend to use load_data and load_parameters as False only</span>
<span class="c"># when the file has been opened in read-only mode &#39;r&#39;.</span>

<span class="c"># Rerunning the same analysis again</span>
<span class="n">a4</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
</div>
<div class="section" id="integrating-a-new-analysis-using-the-openmsi-analysis-template">
<h2>Integrating a new Analysis using the OpenMSI Analysis Template<a class="headerlink" href="#integrating-a-new-analysis-using-the-openmsi-analysis-template" title="Permalink to this headline">¶</a></h2>
<div class="section" id="step-1-basic-integration">
<h3>Step 1) Basic integration<a class="headerlink" href="#step-1-basic-integration" title="Permalink to this headline">¶</a></h3>
<p>The simple steps outlined below provide you now with full integration of your analysis with the OpenMSI file format and API and full support for OpenMSI&#8217;s data provenance capabilities. It also provides basic integration of your analysis with the OpenMSI website, in that a user will be able to browse your analysis in the online file browser. The basic integration also automatically provides full support for the <code class="docutils literal"><span class="pre">qmetadata</span></code> and <code class="docutils literal"><span class="pre">qcube</span></code> URL data access patterns, so that you can start to program against your analysis remotely. The basic integration provides limited support for the <code class="docutils literal"><span class="pre">qslice</span></code>, <code class="docutils literal"><span class="pre">qspectrum</span></code>, and <code class="docutils literal"><span class="pre">qmz</span></code> patterns, in that it automatically exposes all dependencies of the analysis that support these patterns but it does not expose the data of your analysis itself. This is part of step 2. Once you have completed the basic integation yout final analysis code should look something like this:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">omsi_mypeakfinder</span><span class="p">(</span><span class="n">analysis_base</span><span class="p">)</span> <span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_key</span><span class="o">=</span><span class="s">&quot;undefined&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initalize the basic data members&quot;&quot;&quot;</span>

<span class="hll">        <span class="nb">super</span><span class="p">(</span><span class="n">omsi_mypeakfinder</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
</span><span class="hll">
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">analysis_identifier</span> <span class="o">=</span> <span class="n">name_key</span>
        <span class="c"># Define the names of the outputs generated by the analysis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_names</span> <span class="o">=</span> <span class="p">[</span> <span class="s">&#39;peak_cube&#39;</span> <span class="p">,</span> <span class="s">&#39;peak_mz&#39;</span> <span class="p">]</span>

        <span class="c"># Define the input parameters of the analysis</span>
        <span class="n">dtypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_default_dtypes</span><span class="p">()</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_default_parameter_groups</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;msidata&#39;</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s">&#39;The MSI dataset to be analyzed&#39;</span><span class="p">,</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="p">[</span><span class="s">&#39;ndarray&#39;</span><span class="p">],</span>
                           <span class="n">group</span><span class="o">=</span><span class="n">groups</span><span class="p">[</span><span class="s">&#39;input&#39;</span><span class="p">],</span>
                           <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;mzdata&#39;</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s">&#39;The m/z values for the spectra of the MSI dataset&#39;</span><span class="p">,</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="p">[</span><span class="s">&#39;ndarray&#39;</span><span class="p">],</span>
                           <span class="n">group</span><span class="o">=</span><span class="n">groups</span><span class="p">[</span><span class="s">&#39;input&#39;</span><span class="p">],</span>
                           <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;integration_width&#39;</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s">&#39;The window over which peaks should be integrated&#39;</span><span class="p">,</span>
<span class="hll">                           <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
</span><span class="hll">                           <span class="n">default</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
</span><span class="hll">                           <span class="n">group</span><span class="o">=</span><span class="n">groups</span><span class="p">[</span><span class="s">&#39;settings&#39;</span><span class="p">],</span>
</span>                           <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;peakheight&#39;</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s">&#39;Peak height parameter&#39;</span><span class="p">,</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                           <span class="n">default</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                           <span class="n">group</span><span class="o">=</span><span class="n">groups</span><span class="p">[</span><span class="s">&#39;settings&#39;</span><span class="p">],</span>
                           <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">execute_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;...&quot;&quot;&quot;</span>
        <span class="c"># Copy parameters to local variables. This is purely for convenience and is not mandatory.</span>
        <span class="c"># NOTE: Input parameters are automatically record (i.e., we don&#39;t need to to anything special.</span>
        <span class="n">msidata</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;msidata&#39;</span><span class="p">]</span>
        <span class="n">mzdata</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;mzdata&#39;</span><span class="p">]</span>
        <span class="n">integration_width</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;integration_width&#39;</span><span class="p">]</span>
        <span class="n">peakheight</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;peakheight&#39;</span><span class="p">]</span>

        <span class="c"># Implementation of my peakfinding algorithm</span>

        <span class="o">...</span>

        <span class="c"># Return the result.</span>
        <span class="c"># NOTE: We need to return the output in the order we specified them in self.data_names</span>
        <span class="c"># NOTE: The outputs will be automatically recorded (i.e., we don&#39;t need to anything special).</span>
        <span class="k">return</span> <span class="n">peakCube</span><span class="p">,</span> <span class="n">peakMZ</span>
        <span class="bp">self</span><span class="p">[</span><span class="s">&#39;peak_cube&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peakCube</span>

    <span class="o">...</span>

<span class="c"># Defining a main function is optional. However, allowing a user to directly execute your analysis</span>
<span class="c"># from the command line is simple, as we can easily reuse the command-line driver module</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">omsi.analysis.omsi_analysis_driver</span> <span class="kn">import</span> <span class="n">cl_analysis_driver</span>
    <span class="n">cl_analysis_driver</span><span class="p">(</span><span class="n">analysis_class</span><span class="o">=</span><span class="n">omsi_mypeakfinder</span><span class="p">)</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<div class="section" id="creating-a-new-analysis-skeleton">
<h4>1.1 Creating a new analysis skeleton<a class="headerlink" href="#creating-a-new-analysis-skeleton" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Copy the analysis template to the appropriate location where your analysis should live (NOTE: The analysis template may have been updated since this documentation was written). Any new analysis should be located in a submodule of the <code class="docutils literal"><span class="pre">omsi.analysis.</span></code> module. E.g., if you implement a new peak finding algorithm, it should be placed in omsi/analysis/findpeaks. For example:</li>
</ul>
<div class="highlight-none"><div class="highlight"><pre>cp omsi/templates/omsi_analysis_template.py openmsi-tk/omsi/analysis/findpeaks/omsi_mypeakfinder.py
</pre></div>
</div>
<ul class="simple">
<li>Replace all occurrences of <code class="docutils literal"><span class="pre">omsi_analysis_template</span></code> in the file with the name of your analysis class, e.g, omsi_mypeakfinder. You can do this easily using &#8220;Replace All&#8221; feature of most text editors.  or on most Unix systems  (e.g, Linux or MacOS) on the commandline via:</li>
</ul>
<div class="highlight-none"><div class="highlight"><pre>cd openmsi-tk/omsi/analysis/findpeaks
sed -i.bak &#39;s/omsi_analysis_template/omsi_mypeakfinder/&#39; omsi_mypeakfinder.py
rm omsi_mypeakfinder.py.bak
</pre></div>
</div>
<ul class="simple">
<li>Add your analysis to the <code class="docutils literal"><span class="pre">__init__.py</span></code> file of the python module where your analysis lives. In the <code class="docutils literal"><span class="pre">__init__.py</span></code> file you need to add the name of your analysis class to the <code class="docutils literal"><span class="pre">all__</span></code> list and add a an import of your class, e.g,  <code class="docutils literal"><span class="pre">from</span> <span class="pre">omsi_mypeakfinder</span> <span class="pre">import</span> <span class="pre">*</span></code> . For example:</li>
</ul>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="hll"><span class="n">all__</span> <span class="o">=</span> <span class="p">[</span> <span class="s">&quot;omsi_mypeakfinder&quot;</span><span class="p">,</span>  <span class="s">&quot;omsi_findpeaks_global&quot;</span> <span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</span><span class="kn">from</span> <span class="nn">omsi_findpeaks_global</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">omsi_findpeaks_local</span> <span class="kn">import</span> <span class="o">*</span>
<span class="o">...</span>
</pre></div>
</td></tr></table></div>
<ul class="simple">
<li>The analysis template contains documentation on how to implement a new analysis. Simply search for <cite>EDIT_ME</cite> to locate where you should add code and descriptions of what code to add.</li>
</ul>
</div>
<div class="section" id="specifying-analysis-inputs-and-outputs">
<h4>1.2 Specifying analysis inputs and outputs<a class="headerlink" href="#specifying-analysis-inputs-and-outputs" title="Permalink to this headline">¶</a></h4>
<p>In the <code class="docutils literal"><span class="pre">__init__</span></code> function specify the names of the input parameters of your analysis as well as the names of the output data generated by your analysis. Note, the <code class="docutils literal"><span class="pre">__init__</span></code> function should have a signature that allows us to instantiate the analysis without having to provide any inputs. E.g.,</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_key</span><span class="o">=</span><span class="s">&quot;undefined&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Initalize the basic data members&quot;&quot;&quot;</span>

    <span class="nb">super</span><span class="p">(</span><span class="n">omsi_mypeakfinder</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
<span class="hll">    <span class="bp">self</span><span class="o">.</span><span class="n">analysis_identifier</span> <span class="o">=</span> <span class="n">name_key</span>
</span><span class="hll">
</span>    <span class="c"># Define the names of the outputs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;peak_cube&#39;</span><span class="p">,</span> <span class="s">&#39;peak_mz&#39;</span><span class="p">]</span>

    <span class="c"># Define the input parameters</span>
    <span class="n">dtypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_default_dtypes</span><span class="p">()</span>  <span class="c"># List of default data types. Build-in types are</span>
                                        <span class="c"># available as well but can be safely used directly as well</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_default_parameter_groups</span><span class="p">()</span> <span class="c"># List of default groups to organize parameters. We suggest</span>
                                                 <span class="c"># to use the &#39;input&#39; group for all input data to be analyzed</span>
                                                 <span class="c"># as this will make the integration with OpenMSI easier</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;msidata&#39;</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s">&#39;The MSI dataset to be analyzed&#39;</span><span class="p">,</span>
                       <span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="p">[</span><span class="s">&#39;ndarray&#39;</span><span class="p">],</span>
                       <span class="n">group</span><span class="o">=</span><span class="n">groups</span><span class="p">[</span><span class="s">&#39;input&#39;</span><span class="p">],</span>
                       <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;mzdata&#39;</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s">&#39;The m/z values for the spectra of the MSI dataset&#39;</span><span class="p">,</span>
                       <span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="p">[</span><span class="s">&#39;ndarray&#39;</span><span class="p">],</span>
                       <span class="n">group</span><span class="o">=</span><span class="n">groups</span><span class="p">[</span><span class="s">&#39;input&#39;</span><span class="p">],</span>
                       <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;integration_width&#39;</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s">&#39;The window over which peaks should be integrated&#39;</span><span class="p">,</span>
                       <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                       <span class="n">default</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                       <span class="n">group</span><span class="o">=</span><span class="n">groups</span><span class="p">[</span><span class="s">&#39;settings&#39;</span><span class="p">],</span>
                       <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;peakheight&#39;</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s">&#39;Peak height parameter&#39;</span><span class="p">,</span>
                       <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                       <span class="n">default</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                       <span class="n">group</span><span class="o">=</span><span class="n">groups</span><span class="p">[</span><span class="s">&#39;settings&#39;</span><span class="p">],</span>
                       <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="implementing-the-execute-analysis-function">
<h4>1.3: Implementing the <code class="docutils literal"><span class="pre">execute_analysis</span></code> function<a class="headerlink" href="#implementing-the-execute-analysis-function" title="Permalink to this headline">¶</a></h4>
<p><strong>1.3.1</strong> Document your execute_analysis function. OpenMSI typically uses Sphynx notation in the doc-string. The doc-string of the execute_analysis(..) function and the class are used by the analysis driver modules to provide a description of your analysis as part of the help and will also be included in the help string generated by the <cite>get_help_string()</cite> inherited via <cite>analysis_base</cite> function.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">execute_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="p">:</span>
<span class="hll">    <span class="sd">&quot;&quot;&quot;This analysis computes global peaks in MSI data...</span>
</span><span class="hll"><span class="sd">    &quot;&quot;&quot;</span>
</span></pre></div>
</td></tr></table></div>
<p><strong>1.3.2</strong>  Implement your analysis. For convenience it is often useful to assign the your parameters to local variables, although, this is by no means required. Note, all values are stored as 1D+ numpy arrays, however, are automatically converted for you, so that we can just do:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">integration_width</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;integration_width&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p><strong>1.3.4</strong> Return the outputs of your analysis in the same order as specified in the <cite>self.data_names</cite> you specified in your <cite>__init__</cite> function (here <cite>[&#8216;peak_cube&#8217;, &#8216;peak_mz&#8217;]</cite>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">return</span> <span class="n">peakCube</span><span class="p">,</span> <span class="n">peakMZ</span>
</pre></div>
</div>
<p>Results returned by your analysis will be automatically saved to the respective output variables. This allows users to conveniently access your results and it enables the OpenMSI file API to save your results to file. We here automatically convert single scalars to 1D numpy arrays to ensure consistency. Although, the data write function can handle a large range of python built_in types by automatically converting them to numpy for storage in HDF5, we generally recommend to convert use numpy directly here to save your data.</p>
<p>With this you have now completed the basic integration of your analysis with the OpenMSI framework.</p>
</div>
</div>
<div class="section" id="step-2-integrating-the-analysis-with-the-openmsi-web-api">
<h3>Step 2) Integrating the Analysis with the OpenMSI Web API:<a class="headerlink" href="#step-2-integrating-the-analysis-with-the-openmsi-web-api" title="Permalink to this headline">¶</a></h3>
<p>Once the analysis is stored in the OMSI file format, integration with <code class="docutils literal"><span class="pre">qmetadata</span></code> and <code class="docutils literal"><span class="pre">qcube</span></code> calls of the web API is automatic. The <code class="docutils literal"><span class="pre">qmetadata</span></code> and <code class="docutils literal"><span class="pre">qcube</span></code> functions provide general purpose access to the data so that we can immediatly start to program against our analysis.</p>
<p>Some applications&#8212;such as the OpenMSI web-based viewer&#8212;utilize the simplified, special data access patterns <code class="docutils literal"><span class="pre">qslice</span></code>, <code class="docutils literal"><span class="pre">qspectrum</span></code>, and <code class="docutils literal"><span class="pre">qmz</span></code> in order to interact with the data. The default implementation of these function available in <code class="docutils literal"><span class="pre">omsi.analysis.analysis_base</span></code> exposes the data from all depencdencies of the analysis that support these patterns. For full integration with the web API, however, we need to implement this functionality in our analysis class. The <code class="docutils literal"><span class="pre">qmz</span></code> pattern in particular is relevant to both the <code class="docutils literal"><span class="pre">qslice</span></code> and <code class="docutils literal"><span class="pre">qspectrum</span></code> pattern and should be always implemented as soon as one of the two patterns is defined.</p>
<div class="section" id="implementing-the-qslice-pattern">
<h4>2.1 Implementing the <code class="docutils literal"><span class="pre">qslice</span></code> pattern<a class="headerlink" href="#implementing-the-qslice-pattern" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">omsi_myanalysis</span><span class="p">(</span><span class="n">analysis_base</span><span class="p">)</span> <span class="p">:</span>
    <span class="o">...</span>

<span class="hll">    <span class="nd">@classmethod</span>
</span><span class="hll">    <span class="k">def</span> <span class="nf">v_qslice</span><span class="p">(</span><span class="n">cls</span> <span class="p">,</span> <span class="n">anaObj</span> <span class="p">,</span> <span class="n">z</span> <span class="p">,</span> <span class="n">viewer_option</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span>
</span>        <span class="sd">&quot;&quot;&quot;Implement support for qslice URL requests for the viewer</span>

<span class="sd">           anaObj: The omsi_file_analysis object for which slicing should be performed.</span>
<span class="sd">           z: Selection string indicting which z values should be selected.</span>
<span class="sd">           viewer_option: An analysis can provide different default viewer behaviors</span>
<span class="sd">                         for how slice operation should be performed on the data.</span>
<span class="sd">                         This is a simple integer indicating which option is used.</span>

<span class="sd">           :returns: numpy array with the data to be displayed in the image slice</span>
<span class="sd">                     viewer. Slicing will be performed typically like [:,:,zmin:zmax].</span>

<span class="sd">        &quot;&quot;&quot;</span>
<span class="hll">        <span class="kn">from</span> <span class="nn">omsi.shared.omsi_data_selection</span> <span class="kn">import</span> <span class="o">*</span>
</span>        <span class="c">#Implement custom analysis viewer options</span>
<span class="hll">        <span class="k">if</span> <span class="n">viewer_option</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
</span><span class="hll">            <span class="n">dataset</span> <span class="o">=</span>  <span class="n">anaObj</span><span class="p">[</span> <span class="s">&#39;labels&#39;</span> <span class="p">]</span> <span class="c">#We assume labels was a 3D image cube of labels</span>
</span><span class="hll">            <span class="n">zselect</span> <span class="o">=</span> <span class="n">selection_string_to_object</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
</span><span class="hll">            <span class="k">return</span> <span class="n">dataset</span><span class="p">[</span> <span class="p">:</span> <span class="p">,</span> <span class="p">:,</span> <span class="n">zselect</span> <span class="p">]</span>
</span>
        <span class="c">#Expose recursively the slice options for any data dependencies. This is useful</span>
        <span class="c">#to allow one to trace back data and generate comlex visualizations involving</span>
        <span class="c">#multiple different data sources that have some from of dependency in that they</span>
        <span class="c">#led to the generation of this anlaysis. This behavior is already provided by</span>
        <span class="c">#the default implementation of this function ins analysis_base.</span>
<span class="hll">        <span class="k">elif</span> <span class="n">viewer_option</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">:</span>
</span><span class="hll">            <span class="c">#Note, the base class does not know out out viewer_options so we need to adjust</span>
</span><span class="hll">            <span class="c">#the vieweOption accordingly by substracting the number of our custom options.</span>
</span><span class="hll">            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">omsi_myanalysis</span><span class="p">,</span><span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">v_qslice</span><span class="p">(</span> <span class="n">anaObj</span> <span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">viewer_option</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span>        <span class="c">#Invalid viewer_option</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

<span class="hll">     <span class="nd">@classmethod</span>
</span><span class="hll">        <span class="k">def</span> <span class="nf">v_qslice_viewer_options</span><span class="p">(</span><span class="n">cls</span> <span class="p">,</span> <span class="n">anaObj</span> <span class="p">)</span> <span class="p">:</span>
</span>            <span class="sd">&quot;&quot;&quot;Define which viewer_options are supported for qspectrum URL&#39;s&quot;&quot;&quot;</span>
            <span class="c">#Get the options for all data dependencies</span>
<span class="hll">            <span class="n">dependent_options</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">omsi_findpeaks_global</span><span class="p">,</span><span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">v_qslice_viewer_options</span><span class="p">(</span><span class="n">anaObj</span><span class="p">)</span>
</span>            <span class="c">#Define our custom viewer options</span>
<span class="hll">            <span class="n">re</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Labels&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">dependent_options</span>
</span><span class="hll">            <span class="k">return</span> <span class="n">re</span>
</span></pre></div>
</td></tr></table></div>
<p>NOTE: We here convert the selection string to a python selection (i.e., a list, slice, or integer) object using the <code class="docutils literal"><span class="pre">omsi.shared.omsi_data_selection.check_selection_string(...)</span></code> . This has the advantage that we can use the given selection directly in our code and avoids the use of a potentially dangerous <code class="docutils literal"><span class="pre">eval</span></code> , e.g., <code class="docutils literal"><span class="pre">return</span> <span class="pre">eval(&quot;dataset[:,:,</span> <span class="pre">%s]&quot;</span> <span class="pre">%(z,))</span></code> . While we can also check the validity of the  seletion string  using  <code class="docutils literal"><span class="pre">omsi.shared.omsi_data_selection.check_selection_string(...)</span></code> , it is recommened to convert the string to a valid python selection to avoid possible attacks.</p>
</div>
<div class="section" id="implementing-the-qspectrum-pattern">
<h4>2.2 Implementing the <code class="docutils literal"><span class="pre">qspectrum</span></code> pattern<a class="headerlink" href="#implementing-the-qspectrum-pattern" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">omsi_myanalysis</span><span class="p">(</span><span class="n">analysis_base</span><span class="p">)</span> <span class="p">:</span>
    <span class="o">...</span>
<span class="hll">    <span class="nd">@classmethod</span>
</span><span class="hll">    <span class="k">def</span> <span class="nf">v_qspectrum</span><span class="p">(</span> <span class="n">cls</span><span class="p">,</span> <span class="n">anaObj</span> <span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">,</span> <span class="n">viewer_option</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span>
</span>        <span class="sd">&quot;&quot;&quot;Implement support for qspectrum URL requests for the viewer.</span>

<span class="sd">           anaObj: The omsi_file_analysis object for which slicing should be performed</span>
<span class="sd">           x: x selection string</span>
<span class="sd">           y: y selection string</span>
<span class="sd">           viewer_option: If multiple default viewer behaviors are available for a given</span>
<span class="sd">                         analysis then this option is used to switch between them.</span>

<span class="sd">           :returns: The following two elemnts are expected to be returned by this function :</span>

<span class="sd">                1) 1D, 2D or 3D numpy array of the requested spectra. NOTE: The spectrum axis,</span>
<span class="sd">                e.g., mass (m/z), must be the last axis. For index selection x=1,y=1 a 1D array</span>
<span class="sd">                is usually expected. For indexList selections x=[0]&amp;y=[1] usually a 2D array</span>
<span class="sd">                is expected. For range selections x=0:1&amp;y=1:2 we one usually expect a 3D array.</span>
<span class="sd">                This behavior is consistent with numpy and h5py.</span>

<span class="sd">                2) None in case that the spectra axis returned by v_qmz are valid for the</span>
<span class="sd">                returned spectrum. Otherwise, return a 1D numpy array with the m/z values</span>
<span class="sd">                for the spectrum (i.e., if custom m/z values are needed for interpretation</span>
<span class="sd">                of the returned spectrum).This may be needed, e.g., in cases where a</span>
<span class="sd">                per-spectrum peak analysis is performed and the peaks for each spectrum</span>
<span class="sd">                appear at different m/z values.</span>

<span class="sd">            Developer Note: h5py currently supports only a single index list. If the user provides</span>
<span class="sd">            an index-list for both x and y, then we need to construct the proper merged list and</span>
<span class="sd">            load the data manually, or, if the data is small enough, one can load the full data</span>
<span class="sd">            into a numpy array which supports mulitple lists in the selection. This, however, is</span>
<span class="sd">            only recommended for small datasets.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">customMZ</span> <span class="o">=</span> <span class="bp">None</span>
<span class="hll">        <span class="k">if</span> <span class="n">viewer_option</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
</span><span class="hll">            <span class="kn">from</span> <span class="nn">omsi.shared.omsi_data_selection</span> <span class="kn">import</span> <span class="o">*</span>
</span><span class="hll">            <span class="n">dataset</span> <span class="o">=</span>  <span class="n">anaObj</span><span class="p">[</span> <span class="s">&#39;labels&#39;</span> <span class="p">]</span>
</span><span class="hll">            <span class="k">if</span> <span class="p">(</span><span class="n">check_selection_string</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">selection_type</span><span class="p">[</span><span class="s">&#39;indexlist&#39;</span><span class="p">])</span> <span class="ow">and</span>  \
</span>               <span class="p">(</span><span class="n">check_selection_string</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">selection_type</span><span class="p">[</span><span class="s">&#39;indexlist&#39;</span><span class="p">])</span> <span class="p">:</span>
                <span class="c">#Assuming that the data is small enough, we can handle the multiple list</span>
                <span class="c">#selection case here just by loading the full data use numpy to do the</span>
                <span class="c">#subselection. Note, this version would work for all selection types but</span>
                <span class="c">#we would like to avoid loading the full data if we don&#39;t have to.</span>
<span class="hll">                <span class="n">xselect</span> <span class="o">=</span> <span class="n">selection_string_to_object</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class="hll">                <span class="n">yselect</span> <span class="o">=</span> <span class="n">selection_string_to_object</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</span><span class="hll">                <span class="n">data</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[:][</span><span class="n">xselect</span><span class="p">,</span><span class="n">yselect</span><span class="p">,:]</span>
</span>                <span class="c">#Since we alredy confirmed that both selection strings are index lists we could</span>
                <span class="c">#also just do an eval as follows.</span>
                <span class="c">#data = eval(&quot;dataset[:][%s,%s, :]&quot; %(x,y))</span>
            <span class="k">else</span> <span class="p">:</span>
<span class="hll">                <span class="n">xselect</span> <span class="o">=</span> <span class="n">selection_string_to_object</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class="hll">                <span class="n">yselect</span> <span class="o">=</span> <span class="n">selection_string_to_object</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</span><span class="hll">                <span class="n">data</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">xselect</span><span class="p">,</span><span class="n">yselect</span><span class="p">,:]</span>
</span>            <span class="c">#Return the spectra and indicate that no customMZ data values (i.e. None) are needed</span>
<span class="hll">            <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="bp">None</span>
</span>        <span class="c">#Expose recursively the slice options for any data dependencies. This is useful</span>
        <span class="c">#to allow one to trace back data and generate comlex visualizations involving</span>
        <span class="c">#multiple different data sources that have some from of dependency in that they</span>
        <span class="c">#led to the generation of this anlaysis. This behavior is already provided by</span>
        <span class="c">#the default implementation of this function ins analysis_base.</span>
<span class="hll">        <span class="k">elif</span> <span class="n">viewer_option</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">:</span>
</span>            <span class="c">#Note, the base class does not know out out viewer_options so we need to adjust</span>
            <span class="c">#the vieweOption accordingly by substracting the number of our custom options.</span>
<span class="hll">            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">omsi_findpeaks_global</span><span class="p">,</span><span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">v_qspectrum</span><span class="p">(</span> <span class="n">anaObj</span> <span class="p">,</span> <span class="n">x</span> <span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">viewer_option</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span>
        <span class="k">return</span> <span class="n">data</span> <span class="p">,</span> <span class="n">customMZ</span>

    <span class="nd">@classmethod</span>
<span class="hll">    <span class="k">def</span> <span class="nf">v_qspectrum_viewer_options</span><span class="p">(</span><span class="n">cls</span> <span class="p">,</span> <span class="n">anaObj</span> <span class="p">)</span> <span class="p">:</span>
</span>        <span class="sd">&quot;&quot;&quot;Define which viewer_options are supported for qspectrum URL&#39;s&quot;&quot;&quot;</span>
        <span class="c">#Get the options for all data dependencies</span>
<span class="hll">        <span class="n">dependent_options</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">omsi_findpeaks_global</span><span class="p">,</span><span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">v_qspectrum_viewer_options</span><span class="p">(</span><span class="n">anaObj</span><span class="p">)</span>
</span>        <span class="c">#Define our custom viewer options</span>
<span class="hll">        <span class="n">re</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Labels&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">dependent_options</span>
</span><span class="hll">        <span class="k">return</span> <span class="n">re</span>
</span></pre></div>
</td></tr></table></div>
</div>
<div class="section" id="implementing-the-qmz-pattern">
<h4>2.3 Implementing the <code class="docutils literal"><span class="pre">qmz</span></code> pattern<a class="headerlink" href="#implementing-the-qmz-pattern" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nc">omsi_myanalysis</span><span class="p">(</span><span class="n">analysis_base</span><span class="p">)</span> <span class="p">:</span>
    <span class="o">...</span>

    <span class="nd">@classmethod</span>
<span class="hll">        <span class="k">def</span> <span class="nf">v_qmz</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">anaObj</span><span class="p">,</span> <span class="n">qslice_viewer_option</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">qspectrum_viewer_option</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span>
</span><span class="hll">            <span class="sd">&quot;&quot;&quot;Implement support for qmz URL requests for the viewer.</span>
</span>
<span class="sd">                Get the mz axes for the analysis</span>

<span class="sd">                anaObj: The omsi_file_analysis object for which slicing should be performed.</span>
<span class="sd">                qslice_viewer_option: If multiple default viewer behaviors are available for</span>
<span class="sd">                            a given analysis then this option is used to switch between them</span>
<span class="sd">                            for the qslice URL pattern.</span>
<span class="sd">                qspectrum_viewer_option: If multiple default viewer behaviors are available</span>
<span class="sd">                            for a given analysis then this option is used to switch between</span>
<span class="sd">                            them for the qspectrum URL pattern.</span>

<span class="sd">                :returns: The following four arrays are returned by the analysis:</span>

<span class="sd">                  - mzSpectra : 1D numpy array with the static mz values for the spectra.</span>
<span class="sd">                  - labelSpectra : String with lable for the spectral mz axis</span>
<span class="sd">                  - mzSlice : 1D numpy array of the static mz values for the slices or</span>
<span class="sd">                              None if identical to the mzSpectra array.</span>
<span class="sd">                  - labelSlice : String with label for the slice mz axis or None if</span>
<span class="sd">                                 identical to labelSpectra.</span>
<span class="sd">                  - valuesX: The values for the x axis of the image (or None)</span>
<span class="sd">                  - labelX: Label for the x axis of the image</span>
<span class="sd">                  - valuesY: The values for the y axis of the image (or None)</span>
<span class="sd">                  - labelY: Label for the y axis of the image</span>
<span class="sd">                  - valuesZ: The values for the z axis of the image (or None)</span>
<span class="sd">                  - labelZ: Label for the z axis of the image</span>

<span class="sd">                 Developer Note: Here we need to handle the different possible combinations</span>
<span class="sd">                 for the differnent viewer_option patterns. It is in general safe to populate</span>
<span class="sd">                 mzSlice and lableSlice also if they are identical with the spectrum settings,</span>
<span class="sd">                 however, this potentially has a significant overhead when the data is transfered</span>
<span class="sd">                 via a slow network connection, this is why we allow those values to be None</span>
<span class="sd">                 in case that they are identical.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c">#The four values to be returned</span>
            <span class="n">mzSpectra</span> <span class="o">=</span>  <span class="bp">None</span>
            <span class="n">labelSpectra</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">mzSlice</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">labelSlice</span> <span class="o">=</span> <span class="bp">None</span>
<span class="hll">            <span class="n">peak_cube_shape</span> <span class="o">=</span> <span class="n">anaObj</span><span class="p">[</span> <span class="s">&#39;labels&#39;</span> <span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="c">#We assume labels was a 3D image cube of labels</span>
</span><span class="hll">            <span class="n">valuesX</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">peak_cube_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span><span class="hll">            <span class="n">labelX</span> <span class="o">=</span> <span class="s">&#39;pixel index X&#39;</span>
</span><span class="hll">            <span class="n">valuesY</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">peak_cube_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span><span class="hll">            <span class="n">labelY</span> <span class="o">=</span> <span class="s">&#39;pixel index Y&#39;</span>
</span><span class="hll">            <span class="n">valuesZ</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">peak_cube_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak_cube_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="bp">None</span>
</span><span class="hll">            <span class="n">labelZ</span> <span class="o">=</span> <span class="s">&#39;pixel index Z&#39;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak_cube_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="bp">None</span>
</span>
<span class="hll">            <span class="c">#Both qslice and qspectrum here point to our custom analysis</span>
</span><span class="hll">            <span class="k">if</span> <span class="n">qspectrum_viewer_option</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">qslice_viewer_option</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c">#Loadings</span>
</span>                <span class="n">mzSpectra</span> <span class="o">=</span>  <span class="n">anaObj</span><span class="p">[</span> <span class="s">&#39;labels&#39;</span> <span class="p">][:]</span>
                <span class="n">labelSpectra</span> <span class="o">=</span> <span class="s">&quot;Labels&quot;</span>
<span class="hll">            <span class="c">#Both viewer_options point to a data dependency</span>
</span><span class="hll">            <span class="k">elif</span> <span class="n">qspectrum_viewer_option</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">qslice_viewer_option</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">:</span>
</span>                <span class="n">mzSpectra</span><span class="p">,</span> <span class="n">labelSpectra</span><span class="p">,</span> <span class="n">mzSlice</span><span class="p">,</span> <span class="n">labelSlice</span> <span class="o">=</span> \
                       <span class="nb">super</span><span class="p">(</span><span class="n">omsi_findpeaks_global</span><span class="p">,</span><span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">v_qmz</span><span class="p">(</span> <span class="n">anaObj</span><span class="p">,</span> \
                             <span class="n">qslice_viewer_option</span><span class="o">-</span><span class="mi">1</span> <span class="p">,</span> <span class="n">qspectrum_viewer_option</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="hll">            <span class="c">#Only the a qlice options point to a data dependency</span>
</span><span class="hll">            <span class="k">elif</span> <span class="n">qspectrum_viewer_option</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">qslice_viewer_option</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">:</span>
</span>                <span class="n">mzSpectra</span> <span class="o">=</span>  <span class="n">anaObj</span><span class="p">[</span> <span class="s">&#39;peak_mz&#39;</span> <span class="p">][:]</span>
                <span class="n">labelSpectra</span> <span class="o">=</span> <span class="s">&quot;m/z&quot;</span>
                <span class="n">tempA</span><span class="p">,</span> <span class="n">tempB</span><span class="p">,</span> <span class="n">mzSlice</span><span class="p">,</span> <span class="n">labelSlice</span><span class="p">,</span> <span class="n">valuesX</span><span class="p">,</span> <span class="n">labelX</span><span class="p">,</span> <span class="n">valuesY</span><span class="p">,</span> <span class="n">labelY</span><span class="p">,</span> <span class="n">valuesZ</span><span class="p">,</span> <span class="n">labelZ</span> <span class="o">=</span> \
                        <span class="nb">super</span><span class="p">(</span><span class="n">omsi_findpeaks_global</span><span class="p">,</span><span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">v_qmz</span><span class="p">(</span> <span class="n">anaObj</span><span class="p">,</span> \
                              <span class="n">qslice_viewer_option</span><span class="o">-</span><span class="mi">1</span> <span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="hll">            <span class="c">#Only the qspectrum option points to a data dependency</span>
</span><span class="hll">            <span class="k">elif</span> <span class="n">qspectrum_viewer_option</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">qslice_viewer_option</span><span class="o">==</span><span class="mi">0</span> <span class="p">:</span>
</span>                <span class="n">mzSlice</span> <span class="o">=</span>  <span class="n">anaObj</span><span class="p">[</span> <span class="s">&#39;peak_mz&#39;</span> <span class="p">][:]</span>
                <span class="n">labelSlice</span> <span class="o">=</span> <span class="s">&quot;m/z&quot;</span>
                <span class="c"># Ignore the spatial axes and slize axis as we use our own</span>
                <span class="n">mzSpectra</span><span class="p">,</span> <span class="n">labelSpectra</span><span class="p">,</span> <span class="n">tempA</span><span class="p">,</span> <span class="n">tempB</span><span class="p">,</span> <span class="n">vX</span><span class="p">,</span> <span class="n">lX</span><span class="p">,</span> <span class="n">vY</span><span class="p">,</span> <span class="n">lY</span><span class="p">,</span> <span class="n">vZ</span><span class="p">,</span> <span class="n">lZ</span> <span class="o">=</span> \
                        <span class="nb">super</span><span class="p">(</span><span class="n">omsi_findpeaks_global</span><span class="p">,</span><span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">v_qmz</span><span class="p">(</span> <span class="n">anaObj</span><span class="p">,</span> \
                              <span class="mi">0</span> <span class="p">,</span> <span class="n">qspectrum_viewer_option</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="hll">            <span class="k">return</span> <span class="n">mzSpectra</span><span class="p">,</span> <span class="n">labelSpectra</span><span class="p">,</span> <span class="n">mzSlice</span><span class="p">,</span> <span class="n">labelSlice</span><span class="p">,</span> <span class="n">valuesX</span><span class="p">,</span> <span class="n">labelX</span><span class="p">,</span> <span class="n">valuesY</span><span class="p">,</span> <span class="n">labelY</span><span class="p">,</span> <span class="n">valuesZ</span><span class="p">,</span> <span class="n">labelZ</span>
</span></pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="step-3-making-your-analysis-self-sufficient">
<h3>Step 3) Making your analysis self-sufficient<a class="headerlink" href="#step-3-making-your-analysis-self-sufficient" title="Permalink to this headline">¶</a></h3>
<p>Making your analysis self sufficient is trivial. If you used the analysis template provided by the toolkit, then you have already completed this step for free. In order to allow a user to run our analysis from the command line we need a main function. We here can simply reuse the command line driver provided by the toolkit. Using the command line driver we can run the analysis via:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">python</span> <span class="n">omsi</span><span class="o">/</span><span class="n">analysis</span><span class="o">/</span><span class="n">omsi_analysis_driver</span><span class="o">.</span><span class="n">py</span> <span class="n">findpeaks</span><span class="o">.</span><span class="n">omsi_mypeakfinder</span>
    <span class="o">--</span><span class="n">msidata</span> <span class="s">&quot;test_brain_convert.h5:/entry_0/data_0&quot;</span>
    <span class="o">--</span><span class="n">mzdata</span> <span class="s">&quot;test_brain_convert.h5:/entry_0/data_0/mz&quot;</span>
    <span class="o">--</span><span class="n">save</span> <span class="s">&quot;test_ana_save.h5&quot;</span>
</pre></div>
</div>
<p>To now enable us to execute our analysis module itself we simply need to add the following code (which is already part of the template)</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">omsi.analysis.omsi_analysis_driver</span> <span class="kn">import</span> <span class="n">cl_analysis_driver</span>
    <span class="n">cl_analysis_driver</span><span class="p">(</span><span class="n">analysis_class</span><span class="o">=</span><span class="n">omsi_mypeakfinder</span><span class="p">)</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>With this we can now directly execute our analysis from the command line, get a command-line help, specify all our input parameters on the command line, and save our analysis to file. To run the analysis we can now do:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">python</span> <span class="n">omsi</span><span class="o">/</span><span class="n">analysis</span><span class="o">/</span><span class="n">findpeaks</span><span class="o">/</span><span class="n">omsi_findpeaks_global</span><span class="o">.</span><span class="n">py</span>
    <span class="o">--</span><span class="n">msidata</span> <span class="s">&quot;test_brain_convert.h5:/entry_0/data_0&quot;</span>
    <span class="o">--</span><span class="n">mzdata</span> <span class="s">&quot;test_brain_convert.h5:/entry_0/data_0/mz&quot;</span>
    <span class="o">--</span><span class="n">save</span> <span class="s">&quot;test_ana_save.h5&quot;</span>
</pre></div>
</div>
<p>This will run our peak finder on the given input data and save the result to the first experiment in the test_ana_save.h5 (the output file will be automatically created if it does not exist).</p>
<p>The command line driver also provides us a well-formated help based on the our parameter specification and the doc-string of the analysis class and its execute_analysis(...) function. E.g:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64</pre></div></td><td class="code"><div class="highlight"><pre><span class="hll"><span class="gp">&gt;&gt;&gt; </span><span class="n">python</span> <span class="n">omsi</span><span class="o">/</span><span class="n">analysis</span><span class="o">/</span><span class="n">findpeaks</span><span class="o">/</span><span class="n">omsi_findpeaks_global</span><span class="o">.</span><span class="n">py</span> <span class="o">--</span><span class="n">help</span>
</span>
<span class="go">usage: omsi_findpeaks_global.py [-h] [--save SAVE] --msidata MSIDATA --mzdata</span>
<span class="go">                                MZDATA [--integration_width INTEGRATION_WIDTH]</span>
<span class="go">                                [--peakheight PEAKHEIGHT]</span>
<span class="go">                                [--slwindow SLWINDOW]</span>
<span class="go">                                [--smoothwidth SMOOTHWIDTH]</span>

<span class="go">class description:</span>

<span class="go">    Basic global peak detection analysis. The default implementation</span>
<span class="go">    computes the peaks on the average spectrum and then computes the peak-cube data,</span>
<span class="go">    i.e., the values for the detected peaks at each pixel.</span>

<span class="go">    TODO: The current version assumes 2D data</span>


<span class="go">execution description:</span>

<span class="go">        Execute the global peak finding for the given msidata and mzdata.</span>


<span class="go">optional arguments:</span>
<span class="go">  -h, --help            show this help message and exit</span>
<span class="go">  --save SAVE           Define the file and experiment where the analysis</span>
<span class="go">                        should be stored. A new file will be created if the</span>
<span class="go">                        given file does not exists but the directory does. The</span>
<span class="go">                        filename is expected to be of the from:</span>
<span class="go">                        &lt;filename&gt;:&lt;entry_#&gt; . If no experiment index is</span>
<span class="go">                        given, then experiment index 0 (i.e, entry_0) will be</span>
<span class="go">                        assumed by default. A validpath may, e.g, be</span>
<span class="go">                        &quot;test.h5:/entry_0&quot; or jus &quot;test.h5&quot; (default: None)</span>

<span class="go">analysis settings:</span>
<span class="go">  Analysis settings</span>

<span class="go">  --integration_width INTEGRATION_WIDTH</span>
<span class="go">                        The window over which peaks should be integrated</span>
<span class="go">                        (default: 0.1)</span>
<span class="go">  --peakheight PEAKHEIGHT</span>
<span class="go">                        Peak height parameter (default: 2)</span>
<span class="go">  --slwindow SLWINDOW   Sliding window parameter (default: 100)</span>
<span class="go">  --smoothwidth SMOOTHWIDTH</span>
<span class="go">                        Smooth width parameter (default: 3)</span>

<span class="go">input data:</span>
<span class="go">  Input data to be analyzed</span>

<span class="go">  --msidata MSIDATA     The MSI dataset to be analyzed (default: None)</span>
<span class="go">  --mzdata MZDATA       The m/z values for the spectra of the MSI dataset</span>
<span class="go">                        (default: None)</span>

<span class="go">how to specify ndarray data?</span>
<span class="go">----------------------------</span>
<span class="go">n-dimensional arrays stored in OpenMSI data files may be specified as</span>
<span class="go">input parameters via the following syntax:</span>
<span class="go">      -- MSI data: &lt;filename&gt;.h5:/entry_#/data_#</span>
<span class="go">      -- Analysis data: &lt;filename&gt;.h5:/entry_#/analysis_#/&lt;dataname&gt;</span>
<span class="go">      -- Arbitrary dataset: &lt;filename&gt;.h5:&lt;object_path&gt;</span>
<span class="go">E.g. a valid definition may look like: &#39;test_brain_convert.h5:/entry_0/data_0&#39;</span>
<span class="go">In rear cases we may need to manually define an array (e.g., a mask)</span>
<span class="go">Here we can use standard python syntax, e.g, &#39;[1,2,3,4]&#39; or &#39;[[1, 3], [4, 5]]&#39;</span>

<span class="go">This command-line tool has been auto-generated using the OpenMSI Toolkit</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="advanced-customizing-core-features">
<h2>Advanced: Customizing core features<a class="headerlink" href="#advanced-customizing-core-features" title="Permalink to this headline">¶</a></h2>
<div class="section" id="custom-data-save">
<h3>Custom data save<a class="headerlink" href="#custom-data-save" title="Permalink to this headline">¶</a></h3>
<p>In most cases the default data save and restore functions should be sufficient. However, the <code class="docutils literal"><span class="pre">analysis_base</span></code> API also supports implementation of custom HDF5 write. To extend the existing data write code, simple implement the following function provided by <code class="docutils literal"><span class="pre">analysis_base</span></code> .</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span class="hll"><span class="k">def</span> <span class="nf">add_custom_data_to_omsi_file</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span> <span class="n">analysisGroup</span><span class="p">)</span> <span class="p">:</span>
</span>    <span class="sd">&quot;&quot;&quot;This function can be optionally overwritten to implement a custom data write</span>
<span class="sd">       function for the analysis to be used by the omsi_file API.</span>

<span class="sd">       Note, this function should be used only to add additional data to the analysis</span>
<span class="sd">       group. The data that is written by default is typically still written by the</span>
<span class="sd">       omsi_file_experiment.create_analysis() function, i.e., the following data is</span>
<span class="sd">       wirtten by default: i) analysis_identifier ,ii) get_analysis_type,</span>
<span class="sd">       iii)__data_list, iv) __parameter_list , v) __dependency_list. Since the</span>
<span class="sd">       omsi_file.experiment.create_analysis() functions takes care of setting up the</span>
<span class="sd">       basic structure of the analysis storage (included the subgroubs for storing</span>
<span class="sd">       parameters and data dependencies) this setup can generally be assumed to exist</span>
<span class="sd">       before this function is called. This function is called automatically at the</span>
<span class="sd">       end omsi_file.experiment.create_analysis() (i.e, actually</span>
<span class="sd">       omsi_file_analysis.__populate_analysis__(..)) so that this function does not need</span>
<span class="sd">       to be called explicitly.</span>

<span class="sd">       Keyword Arguments:</span>

<span class="sd">       :param analysisGroup: The omsi_file_analysis object of the group for the</span>
<span class="sd">                             analysis that can be used for writing.</span>

<span class="sd">       &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="custom-analysis-restore">
<h3>Custom analysis restore<a class="headerlink" href="#custom-analysis-restore" title="Permalink to this headline">¶</a></h3>
<p>Similarly in order implement custom data restore behavior we can overwrite the default implementation of <code class="xref py py-meth docutils literal"><span class="pre">omsi.analysis.analysis_base.analysis_base.read_from_omsi_file()</span></code> . In this case one will usually call the default implementation via <code class="docutils literal"><span class="pre">super(omsi_myanalysis,self).read_from_omsi_file(...)</span></code> first and then add any additional behavior.</p>
</div>
<div class="section" id="custom-analysis-execution">
<h3>Custom analysis execution<a class="headerlink" href="#custom-analysis-execution" title="Permalink to this headline">¶</a></h3>
<p>Analysis are typically executed using the <code class="xref py py-meth docutils literal"><span class="pre">omsi.analysis.analysis_base.analysis_base.execute()</span></code> function we inherit from py:class:<cite>omsi.analysis.analysis_base.analysis_base</cite>. The <code class="docutils literal"><span class="pre">execute()</span></code> function controls many pieces, from recording and defining input parameters and outputs to executing the actual analysis. We, therefore, for NOT recommend to overwrite the <code class="docutils literal"><span class="pre">exceute(..)</span></code> function, but rather to customize specific portions of the execution. To do this, <cite>execute()</cite> is broken into a number of functions which are called in a specific order. In this way we can easily overwrite select functions to customize a particular feature without having to overwrite the complete <code class="docutils literal"><span class="pre">execute(..)</span></code> function.</p>
<div class="section" id="customizing-setting-of-parameters">
<h4>Customizing setting of parameters<a class="headerlink" href="#customizing-setting-of-parameters" title="Permalink to this headline">¶</a></h4>
<p>First, the execute function uses <code class="xref py py-meth docutils literal"><span class="pre">omsi.analysis.analysis_base.analysis_base.update_analysis_parameters()</span></code> to set all parameters that have been passed to execute accordingly. The default implementation of <code class="docutils literal"><span class="pre">update_analysis_parameters(..)</span></code>, hence, simply calls <code class="docutils literal"><span class="pre">self.set_parameter_values(...)</span></code> to set all parameter values. We can customize this behavior simply by overwriting the <code class="docutils literal"><span class="pre">update_analysis_parameters(...)</span></code> function.</p>
</div>
<div class="section" id="customizing-setting-of-default-settings">
<h4>Customizing setting of default settings<a class="headerlink" href="#customizing-setting-of-default-settings" title="Permalink to this headline">¶</a></h4>
<p>Second, the execute function uses the <code class="xref py py-meth docutils literal"><span class="pre">omsi.analysis.analysis_base.analysis_base.define_missing_parameters()</span></code> function to set any required parameters that have not been set by the user to their respective values. Overwrite this function to customize how default parameter values are determined/set.</p>
</div>
<div class="section" id="customizing-the-recording-of-runtime-information">
<h4>Customizing the recording of runtime information<a class="headerlink" href="#customizing-the-recording-of-runtime-information" title="Permalink to this headline">¶</a></h4>
<p>The recording of runtime information is performed using the <code class="xref py py-meth docutils literal"><span class="pre">omsi.shared.run_info_data.run_info_dict()</span></code> data structure. This data structure provides a series of functions that are called in order, in particular:</p>
<ul class="simple">
<li><code class="xref py py-meth docutils literal"><span class="pre">omsi.shared.run_info_data.run_info_dict.clear()</span></code> : This function is called first to clear the runtime dictionary. This is the same as the standard dict.clear.</li>
<li><code class="xref py py-meth docutils literal"><span class="pre">omsi.shared.run_info_data.run_info_dict.record_preexecute()</span></code> : This function is called before the <code class="docutils literal"><span class="pre">execute_analysis</span></code> function is called and records basic system information,</li>
<li><code class="xref py py-meth docutils literal"><span class="pre">omsi.shared.run_info_data.run_info_dict.record_postexecute()</span></code> : This function is called after the  <code class="docutils literal"><span class="pre">execute_analysis</span></code> function has completed to record additional information, e.g, the time and duration of the analysis,</li>
<li><code class="xref py py-meth docutils literal"><span class="pre">omsi.shared.run_info_data.run_info_dict..runinfo_clean_up()</span></code> : This function is called at the end to clean up the recorded runtime information. By default, <code class="docutils literal"><span class="pre">runinfo_clean_up()</span></code> removes any empty entries, i.e., key/value pairs where the value is either None or an empty string.</li>
</ul>
<p>We can customize any of these function by implementing a derived class of <code class="xref py py-meth docutils literal"><span class="pre">omsi.shared.run_info_data.run_info_dict()</span></code> where we can overwrite the functions. In order to use our derived class we can then assign our object to <code class="xref py py-meth docutils literal"><span class="pre">omsi.analysis.analysis_base.analysis_base.run_info()</span></code>. This design allows us to modularly use the runtime information tracking also for other tasks, not just with our analysis base infrastructure.</p>
</div>
<div class="section" id="customizing-the-analysis-execution">
<h4>Customizing the analysis execution<a class="headerlink" href="#customizing-the-analysis-execution" title="Permalink to this headline">¶</a></h4>
<p>The analysis is completely implemented in the <code class="xref py py-meth docutils literal"><span class="pre">omsi.analysis.analysis_base.analysis_base.execute_analysis()</span></code> function, which we have to implement in our derived class, i.e, running the analysis is fully custom anyways.</p>
</div>
<div class="section" id="customizing-the-recording-of-analysis-outputs">
<h4>Customizing the recording of analysis outputs<a class="headerlink" href="#customizing-the-recording-of-analysis-outputs" title="Permalink to this headline">¶</a></h4>
<p>Finally (i.e., right before returning analysis results), <code class="docutils literal"><span class="pre">execute(..)</span></code> uses the <code class="xref py py-meth docutils literal"><span class="pre">omsi.analysis.analysis_base.analysis_base.record_execute_analysis_outputs()</span></code> function to save all analysis outputs. Analysis outputs are stored in the self.__data_list variable. We can save analysis outputs simply by slicing and assignment, e.g., <cite>self[output_name] = my_output</cite>. By overwriting <cite>record_execute_analysis_outputs(...)</cite> we can customize the recording of data outputs.</p>
</div>
</div>
</div>
<div class="section" id="wrapping-a-function-the-quick-and-dirty-way">
<h2>Wrapping a function: The quick-and-dirty way<a class="headerlink" href="#wrapping-a-function-the-quick-and-dirty-way" title="Permalink to this headline">¶</a></h2>
<p>Sometimes developers just want to debug some analysis function or experiment with different variants of a code. At the same time, we want to be able to track the results of these kind of experiments in a simple fashion. The <a class="reference internal" href="omsi.analysis.html#module-omsi.analysis.generic" title="omsi.analysis.generic"><code class="xref py py-meth docutils literal"><span class="pre">omsi.analysis.generic()</span></code></a> provides us with such a quick-and-dirty solution. We say quick-and-dirty because it sacrifices some generality and features in favor for a very simple process.</p>
<p>Using the <a class="reference internal" href="omsi.analysis.html#omsi.analysis.generic.analysis_generic.from_function" title="omsi.analysis.generic.analysis_generic.from_function"><code class="xref py py-meth docutils literal"><span class="pre">omsi.analysis.generic.analysis_generic.from_function()</span></code></a> or <a class="reference internal" href="omsi.analysis.html#omsi.analysis.generic.bastet_analysis" title="omsi.analysis.generic.bastet_analysis"><code class="xref py py-meth docutils literal"><span class="pre">omsi.analysis.generic.bastet_analysis()</span></code></a> decorator, we can easily construct a generic <a class="reference internal" href="omsi.analysis.html#omsi.analysis.base.analysis_base" title="omsi.analysis.base.analysis_base"><code class="xref py py-class docutils literal"><span class="pre">omsi.analysis.base.analysis_base</span></code></a> instance container object for a given function. We can then use this container object to execute our function, while tracking its provenance as well as save the results to file as we would with any other analysis object. This approach allows us to easily track, record, safe, share and reproduce code experiments with only minimal extra effort needed. Here we briefly outline the two main options to do this:</p>
<div class="section" id="option-1-explicitly-track-specific-excutions-of-a-function">
<h3>Option 1: Explicitly track specific excutions of a function<a class="headerlink" href="#option-1-explicitly-track-specific-excutions-of-a-function" title="Permalink to this headline">¶</a></h3>
<p>Instead of calling our analysis function <code class="docutils literal"><span class="pre">f()</span></code> directly, we create an instance of <a class="reference internal" href="omsi.analysis.html#omsi.analysis.generic.analysis_generic" title="omsi.analysis.generic.analysis_generic"><code class="xref py py-meth docutils literal"><span class="pre">omsi.analysis.generic.analysis_generic()</span></code></a> via <code class="docutils literal"><span class="pre">g</span> <span class="pre">=</span> <span class="pre">analysis_generic.from_function(f)</span></code> which we then use instead of our function. To execute our function we can now either call <code class="docutils literal"><span class="pre">g.execute(...)</span></code> as usual or treat <code class="docutils literal"><span class="pre">g</span></code> as a function and call it directly <code class="docutils literal"><span class="pre">g(...)</span></code></p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="hll"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
</span><span class="kn">from</span> <span class="nn">omsi.analysis.generic</span> <span class="kn">import</span> <span class="n">analysis_generic</span>

<span class="c"># Define some example function we want to wrap to track results</span>
<span class="k">def</span> <span class="nf">mysum</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="c"># Create an analysis object for our function</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">analysis_generic</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">mysum</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>  <span class="c"># This is the same as:  g(np.arange(10))</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="option-2-implicitly-track-the-last-execution-of-a-function">
<h3>Option 2: Implicitly track the last execution of a function<a class="headerlink" href="#option-2-implicitly-track-the-last-execution-of-a-function" title="Permalink to this headline">¶</a></h3>
<p>If we are only interested in recording the last execution of our function, then we can alternatively wrap our function directly using the <code class="docutils literal"><span class="pre">&#64;bastet_analysis</span></code> decorator. The main difference between the two approaches is that using the decorator we only record the last execution of our function, while using the explicit approach of option 1, we can create as many wrapped instances of our functions as we want and track the execution of each independently.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="hll"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
</span><span class="kn">from</span> <span class="nn">omsi.shared.log</span> <span class="kn">import</span> <span class="n">log_helper</span>
<span class="n">log_helper</span><span class="o">.</span><span class="n">set_log_level</span><span class="p">(</span><span class="s">&#39;DEBUG&#39;</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">omsi.analysis.generic</span> <span class="kn">import</span> <span class="n">bastet_analysis</span>
<span class="kn">from</span> <span class="nn">omsi.dataformat.omsi_file.main_file</span> <span class="kn">import</span> <span class="n">omsi_file</span>

<span class="c"># Define some example function and wrap it</span>
<span class="nd">@bastet_analysis</span>
<span class="k">def</span> <span class="nf">mysum</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Our own sum function&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="c"># Execute the analysis</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">mysum</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="example-1-defining-and-using-wrapped-functions">
<h3>Example 1: Defining and using wrapped functions<a class="headerlink" href="#example-1-defining-and-using-wrapped-functions" title="Permalink to this headline">¶</a></h3>
<p>The code example shown below illustrates the &#8220;wrapping&#8221; of a simple example function <code class="docutils literal"><span class="pre">mysum(a)</span></code>, which simply uses <code class="docutils literal"><span class="pre">numpy.sum</span></code> to compute the sum of objects in an array. (NOTE: We could naturally also use <code class="docutils literal"><span class="pre">numpy.sum</span></code> directly, we use <code class="docutils literal"><span class="pre">mysum(a)</span></code> mainly to illustrate that this approach also works wit functions defined in the interpreter.)</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">omsi.shared.log</span> <span class="kn">import</span> <span class="n">log_helper</span>
<span class="n">log_helper</span><span class="o">.</span><span class="n">set_log_level</span><span class="p">(</span><span class="s">&#39;INFO&#39;</span><span class="p">)</span>
<span class="hll"><span class="kn">from</span> <span class="nn">omsi.analysis.generic</span> <span class="kn">import</span> <span class="n">analysis_generic</span>
</span><span class="kn">from</span> <span class="nn">omsi.dataformat.omsi_file.main_file</span> <span class="kn">import</span> <span class="n">omsi_file</span>

<span class="c"># Define some example function we want to wrap to track results</span>
<span class="k">def</span> <span class="nf">mysum</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="hll"><span class="c"># Create an analysis object for our function</span>
</span><span class="hll"><span class="n">g</span> <span class="o">=</span> <span class="n">analysis_generic</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">mysum</span><span class="p">)</span>
</span>
<span class="hll"><span class="c"># Execute the analysis</span>
</span><span class="hll"><span class="n">res</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</span><span class="n">log_helper</span><span class="o">.</span><span class="n">log_var</span><span class="p">(</span><span class="n">__name__</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">res</span><span class="p">)</span>  <span class="c"># Logging the result</span>

<span class="hll"><span class="c"># Save the analysis to file</span>
</span><span class="n">f</span> <span class="o">=</span> <span class="n">omsi_file</span><span class="p">(</span><span class="s">&#39;autowrap_test.h5&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_experiment</span><span class="p">()</span>
<span class="n">exp_index</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">get_experiment_index</span><span class="p">()</span>
<span class="hll"><span class="n">ana_obj</span><span class="p">,</span> <span class="n">ana_index</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">create_analysis</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</span><span class="c"># Close the file</span>
<span class="n">f</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
<span class="k">del</span> <span class="n">f</span>

<span class="hll"><span class="c"># Restore the analysis from file</span>
</span><span class="n">f</span> <span class="o">=</span> <span class="n">omsi_file</span><span class="p">(</span><span class="s">&#39;autowrap_test.h5&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">get_experiment</span><span class="p">(</span><span class="n">exp_index</span><span class="p">)</span>
<span class="hll"><span class="n">a</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">get_analysis</span><span class="p">(</span><span class="n">ana_index</span><span class="p">)</span>
</span><span class="hll"><span class="n">g2</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">restore_analysis</span><span class="p">()</span>
</span><span class="n">res2</span> <span class="o">=</span> <span class="n">g2</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
<span class="n">log_helper</span><span class="o">.</span><span class="n">log_var</span><span class="p">(</span><span class="n">__name__</span><span class="p">,</span> <span class="n">res2</span><span class="o">=</span><span class="n">res2</span><span class="p">)</span>  <span class="c"># Logging the result</span>
<span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="n">res2</span><span class="p">:</span>
    <span class="n">log_helper</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">__name__</span><span class="p">,</span> <span class="s">&quot;CONGRATULATIONS---The results matched&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">log_helper</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">__name__</span><span class="p">,</span> <span class="s">&quot;SORRY---The results did not match&quot;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>When we run our script, we can see that we were able to successfully capture the
execution of our function and recreate the analysis from file.</p>
<div class="highlight-bash"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre>machine:dir username<span class="nv">$ </span>python autowrap_function.py
2015-09-29 15:21:32,729 - __main__ - INFO - <span class="nv">res</span> <span class="o">=</span> 45
2015-09-29 15:21:32,778 - __main__ - INFO - <span class="nv">res2</span> <span class="o">=</span> 45
<span class="hll">2015-09-29 15:21:32,778 - __main__ - INFO - CONGRATULATIONS---The results matched
</span></pre></div>
</td></tr></table></div>
<p>The figure below shows a view of the file generated by our wrapped function execution example shown above.</p>
<div class="figure" id="wrap-function-result-figure">
<a class="reference internal image-reference" href="_images/wrap_function_result.png"><img alt="Baseline performance for slice selection" src="_images/wrap_function_result.png" style="width: 747.0px; height: 872.0px;" /></a>
</div>
<p>Note, we can use the wrapped function objects as usual in an analysis workflow to combine our functions with other analyses. For example, the simple example shown below shows how we can quickly define a simple filter to set all intensities that are less than 10 to a value of 0 before executing an analysis. We here first execute global peak finding to reduce the data, than apply a simple wrapped filter function to filter the data values, and then compute NMF on the filtered data.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">omsi.dataformat.omsi_file</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">omsi.analysis.findpeaks.omsi_findpeaks_global</span> <span class="kn">import</span> <span class="n">omsi_findpeaks_global</span>
<span class="kn">from</span> <span class="nn">omsi.analysis.multivariate_stats.omsi_nmf</span> <span class="kn">import</span> <span class="n">omsi_nmf</span>
<span class="hll"><span class="kn">from</span> <span class="nn">omsi.analysis.generic</span> <span class="kn">import</span> <span class="n">analysis_generic</span>
</span><span class="hll"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">omsi_file</span><span class="p">(</span><span class="s">&#39;/Users/oruebel/Devel/openmsi-data/msidata/20120711_Brain.h5&#39;</span> <span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">get_experiment</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">get_msidata</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c"># Specify the analysis workflow</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">omsi_findpeaks_global</span><span class="p">()</span>
<span class="n">a1</span><span class="p">[</span><span class="s">&#39;msidata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
<span class="n">a1</span><span class="p">[</span><span class="s">&#39;mzdata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">mz</span>

<span class="c"># Wrap a simple function to filter all peaks with less than 10 counts</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">a</span><span class="p">[</span><span class="n">a</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">a</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">analysis_generic</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">a2</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[</span><span class="s">&#39;peak_cube&#39;</span><span class="p">]</span>    <span class="c"># Use the peak_cube from a1 as input for the filter</span>

<span class="c"># Create an NMF for the filtered data</span>
<span class="n">a3</span> <span class="o">=</span> <span class="n">omsi_nmf</span><span class="p">()</span>
<span class="n">a3</span><span class="p">[</span><span class="s">&#39;msidata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">a2</span><span class="p">[</span><span class="s">&#39;output_0&#39;</span><span class="p">]</span>  <span class="c"># Make the output of our analysis the input of the NMF</span>
<span class="n">a3</span><span class="p">[</span><span class="s">&#39;numIter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c"># Run our simple workflow, i.e.,: peak_finder --&gt; our_filter --&gt; nmf</span>
<span class="n">a3</span><span class="o">.</span><span class="n">execute_recursive</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
<p>By default, the outputs are named and numbered using the schema <code class="docutils literal"><span class="pre">output_#</span></code>, i.e., in the above example we used <code class="docutils literal"><span class="pre">a2['output_0']</span></code> to access the output our wrapped function. To define user-defined names for the outputs of a wrapped function we can simply provide a list of strings to the input parameter <code class="docutils literal"><span class="pre">output_names</span></code> of the <code class="docutils literal"><span class="pre">analysis_generic.from_function(...)</span></code>.</p>
<p><strong>NOTE:</strong> Wrapping functions directly is not recommended for production workflows but is intended for development and debugging purposes only. This mechanism relies on that the library does the right thing in automatically determining input parameters, outputs, and their types and that we can handle all those types in the end-to-end process, from definition to storage. We do our best to make this mechanism work with a broad set of cases but we do not guarantee that the simple wrapping always work.</p>
</div>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="basic_workflows.html" class="btn btn-neutral float-right" title="Defining and Executing Analysis Workflows">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="custom_filereader.html" class="btn btn-neutral" title="Integrating new file formats"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Oliver Rübel and Ben Bowen.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'devel',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>